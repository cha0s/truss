{
    "docs": [
        {
            "location": "/",
            "text": "Truss\n\n\nHi, what are you?\n\n\nTruss is an opinionated JavaScript application framework. It is\norganized into \npackages\n which implement\n\nhooks\n, as a means of communicating between each other and\ninfluencing the way the application behaves.\n\n\nHi, why are you?\n\n\nThe intention of Truss is to lay the foundation allowing you to build rich,\npowerful applications in an elegant and structured way; without needing to\nhack on or change the core codebase. Everything you need should be doable by\ncreating a new package. If you find the opposite to be true, feel free to\n\nopen an issue\n!\n\n\nHi, how dare you?\n\n\n[[Insert deepest condolences for lack of/incomprehensible/otherwise wanting\ndocumentation with vague reassurance that it will someday not be the\ncase \nHERE\n]]\n\n\nTODO\n\n\nSee the \nTODO list\n.",
            "title": "README"
        },
        {
            "location": "/#truss",
            "text": "Hi, what are you?  Truss is an opinionated JavaScript application framework. It is\norganized into  packages  which implement hooks , as a means of communicating between each other and\ninfluencing the way the application behaves.  Hi, why are you?  The intention of Truss is to lay the foundation allowing you to build rich,\npowerful applications in an elegant and structured way; without needing to\nhack on or change the core codebase. Everything you need should be doable by\ncreating a new package. If you find the opposite to be true, feel free to open an issue !  Hi, how dare you?  [[Insert deepest condolences for lack of/incomprehensible/otherwise wanting\ndocumentation with vague reassurance that it will someday not be the\ncase  HERE ]]  TODO  See the  TODO list .",
            "title": "Truss"
        },
        {
            "location": "/guide/errors/",
            "text": "Error handling\n\n\n\nTruss provides a mechanism to define errors that can be transmitted over the\nwire.\n\n\nThis is accomplished by subclassing\n\nTransmittableError\n.\nLet's look at an example.\n\n\nDefine an error\n\n\nSay we'd like to implement an error saying that one user can't add another\nuser as a friend. We might implement that like so:\n\n\nvar TransmittableError = require('errors').TransmittableError;\n\nfunction FriendRequestError(message, addingUserName, addedUserName) {\n  TransmittableError.apply(this, arguments);\n\n  this.addingUserName = addingUserName;\n  this.addedUserName = addedUserName;\n}\n\nFriendRequestError.prototype = new TransmittableError();\nFriendRequestError.prototype.key = 'friendRequest';\nFriendRequestError.prototype.template = ':message :addingUserName cannot add :addedUserName as a friend!';\nFriendRequestError.prototype.toJSON = function() {\n  return {\n    key: this.key,\n    message: this.message,\n    addingUserName: this.addingUserName,\n    addedUserName: this.addedUserName\n  };\n};\n\n\n\n\nWe now have our friend request error! You'll want to return it (in an array)\nfrom your package's implementation of\n\ntrussTransmittableErrors\n.\n\n\nInstantiate an error\n\n\nYou can instantiate one of these errors:\n\n\nvar errors = require('errors');\nvar error = errors.instantiate('friendRequest', 'Friend request error!', 'Alice', 'Bob');\n\n\n\n\nNotice the arguments to \nerrors.instantiate\n are first the key, followed by\nthe arguments defined by your subclass constructor.\n\n\nRender a formatted error\n\n\nTo see the error output you could do something like:\n\n\nvar errors = require('errors');\nconsole.error(errors.message(error));\n\n\n\n\nwhich would output:\n\n\nFriend request error! Alice cannot add Bob as a friend!\n\n\n\n\nYou might be wondering, why is the 'message' formatting function on \nerrors\n\ninstead of on \nTransmittableError::prototype\n? The reason is because\n\nerrors.message\n is designed to work not only if you pass it an instance of\n\nTransmittableError\n, but also instances of \nError\n, as well as primitive\ntypes.\n\n\nRender an error stack\n\n\nYou can view the stack of any error in a similar way:\n\n\nvar errors = require('errors');\nconsole.error(errors.stack(error));",
            "title": "Error handling"
        },
        {
            "location": "/guide/errors/#define-an-error",
            "text": "Say we'd like to implement an error saying that one user can't add another\nuser as a friend. We might implement that like so:  var TransmittableError = require('errors').TransmittableError;\n\nfunction FriendRequestError(message, addingUserName, addedUserName) {\n  TransmittableError.apply(this, arguments);\n\n  this.addingUserName = addingUserName;\n  this.addedUserName = addedUserName;\n}\n\nFriendRequestError.prototype = new TransmittableError();\nFriendRequestError.prototype.key = 'friendRequest';\nFriendRequestError.prototype.template = ':message :addingUserName cannot add :addedUserName as a friend!';\nFriendRequestError.prototype.toJSON = function() {\n  return {\n    key: this.key,\n    message: this.message,\n    addingUserName: this.addingUserName,\n    addedUserName: this.addedUserName\n  };\n};  We now have our friend request error! You'll want to return it (in an array)\nfrom your package's implementation of trussTransmittableErrors .",
            "title": "Define an error"
        },
        {
            "location": "/guide/errors/#instantiate-an-error",
            "text": "You can instantiate one of these errors:  var errors = require('errors');\nvar error = errors.instantiate('friendRequest', 'Friend request error!', 'Alice', 'Bob');  Notice the arguments to  errors.instantiate  are first the key, followed by\nthe arguments defined by your subclass constructor.",
            "title": "Instantiate an error"
        },
        {
            "location": "/guide/errors/#render-a-formatted-error",
            "text": "To see the error output you could do something like:  var errors = require('errors');\nconsole.error(errors.message(error));  which would output:  Friend request error! Alice cannot add Bob as a friend!  You might be wondering, why is the 'message' formatting function on  errors \ninstead of on  TransmittableError::prototype ? The reason is because errors.message  is designed to work not only if you pass it an instance of TransmittableError , but also instances of  Error , as well as primitive\ntypes.",
            "title": "Render a formatted error"
        },
        {
            "location": "/guide/errors/#render-an-error-stack",
            "text": "You can view the stack of any error in a similar way:  var errors = require('errors');\nconsole.error(errors.stack(error));",
            "title": "Render an error stack"
        },
        {
            "location": "/guide/packages/",
            "text": "Package system\n\n\n\nTruss is organized into packages which implement hooks.\n\n\nA package is essentially a node.js module. Exporting a \npkgmanRegister\n\nfunction allows Truss to register your package in its package manager. This is\nhow you can implement hooks, allowing you to augment, modify, and even define\nyour application's behavior.\n\n\nThe simplest example of a package would be something like:\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('trussPreBootstrap', function() {\n    console.log('I hooked into Truss!');\n  });\n};\n\n\n\n\nThis package simply hooks into the\n\ntrussPreBootstrap\n hook and logs\na message to the console when that hook is invoked. Obviously this particular\npackage isn't super useful!\n\n\nHooks are how Truss allows packages to implement (or invoke) dynamic behavior.\nHooks can also serve as a form of message passing between packages.\n\n\nTo implement a hook, export a \npkgmanRegister\n method which takes a \nregistrar\n\nargument, and use the registrar to register your hook:\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('someHook', function() {\n    doStuff();\n  });\n\n  registrar.registerHook('someOtherHook', function(arg) {\n    doOtherStuffWith(arg);\n  });\n};\n\n\n\n\nTo invoke a hook, require \npkgman\n and use the \ninvoke\n method:\n\n\nvar pkgman = require('pkgman');\n\nvar results = pkgman.invoke('someOtherHook', arg);\n\n\n\n\nAny arguments following the hook name will be passed along to the\nimplementations. Hooks are invoked synchronously. For more information about\n\npkgman\n, see \nthe pkgman documentation\n.",
            "title": "Package system"
        },
        {
            "location": "/guide/concepts/",
            "text": "This page explains various concepts and conventions used in Truss.\n\n\nMiddleware hook specification\n\n\nTruss invokes various hooks\n(\ntrussBootstrapMiddleware\n, and more...)\nwhich allow packages to define middleware to be dispatched during various\nprocesses.\n\n\nMiddleware hooks return a specification that looks like:\n\n\n{\n  label: 'What the middleware functions do',\n  middleware: [\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    },\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    }\n  ]\n}\n\n\n\n\nThe \nlabel\n exists only to provide debugging information so you can see if any\nof your middleware are having problems by checking the debug console logs.\n\n\nThe \nmiddleware\n are applied serially, meaning the first function in the array\nis dispatched first, followed by the second, etc.\n\n\nSee the\n\nmiddleware module\n\nfor even more information about defining middleware.",
            "title": "Concepts and conventions"
        },
        {
            "location": "/guide/concepts/#middleware-hook-specification",
            "text": "Truss invokes various hooks\n( trussBootstrapMiddleware , and more...)\nwhich allow packages to define middleware to be dispatched during various\nprocesses.  Middleware hooks return a specification that looks like:  {\n  label: 'What the middleware functions do',\n  middleware: [\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    },\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    }\n  ]\n}  The  label  exists only to provide debugging information so you can see if any\nof your middleware are having problems by checking the debug console logs.  The  middleware  are applied serially, meaning the first function in the array\nis dispatched first, followed by the second, etc.  See the middleware module \nfor even more information about defining middleware.",
            "title": "Middleware hook specification"
        },
        {
            "location": "/hooks/",
            "text": "Hook reference\n\n\n\ntrussBootstrapMiddleware\n\n\nDefine middleware to run when the server application is bootstrapping.\n\n\nThis hook is where most of the major initialization work happens on the\nserver. You use this to spin up HTTP/sockets/database/whatever.\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(next) {\n  ...\n}\n\n\n\n\n1 implementation\n\n  \n\n    \ntruss-repl (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nsrc/main (server)\ninvocation\n  \n\n\n\n\n\ntrussConfigServer\n\n\nDefine server-side configuration settings.\n\n\nPackages may use this hook to define default configuration for server-side\nfunctionality. These settings can be overridden in the settings file.\n\n\nImplementations must return\n\n\n\nA recursive object which will be folded into the server configuration under\nthe package name key. For instance, say we have a package \nmy-package\n which\ndefines the hook like:\n\n\nregistrar.registerHook('trussConfigServer', function() {\n  return {\n    one: 68,\n    two: {\n      three: 419\n    }\n  };\n});\n\n\n\n\nYou would then find those values in the configuration at:\n\n\nconfig.get('packageSettings:my-package:one');\nconfig.get('packageSettings:my-package:two:three');\n\n\n\n\nSee \nthe default configuration file\n for\nan example of how settings may be overridden. This should always be preferred\nto actually changing the code in a given package's hook.\n\n\n1 implementation\n\n  \n\n    \ntruss-repl (server)\nimplementation\n  \n\n\n\n\n\n2 invocations\n\n  \n\n    \nGruntfile (server)\ninvocation\n    \nsrc/main (server)\ninvocation\n  \n\n\n\n\n\ntrussGruntConfig\n\n\nHook into the Grunt build process.\n\n\nThis hook allows packages to define Grunt tasks, configure existing tasks, and\nload NPM tasks. This is achieved through the first implementation parameter\nwhich is an instance of the class\n\nGruntConfiguration\n. The\n\ngrunt\n object is passed in through the second parameter in case it's needed.\n\n\nOne of the most common uses of this hook is to copy any asset files your\npackage may include to the \napp\n directory, where they can be served to\nclients.\n\n\n1 implementation\n\n  \n\n    \ntruss-dox (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nGruntfile (server)\ninvocation\n  \n\n\n\n\n\ntrussGruntConfigAlter\n\n\nAlter the Grunt build process.\n\n\nThis hook allows packages to alter Grunt configuration specified through\n\ntrussGruntConfig\n.\n\n\nThe first implementation parameter is an instance of the class\n\nGruntConfiguration\n. The \ngrunt\n\nobject is passed in through the second parameter in case it's needed.\n\n\n1 invocation\n\n  \n\n    \nGruntfile (server)\ninvocation\n  \n\n\n\n\n\ntrussPreBootstrap\n\n\nInvoked before the application bootstrap phase.\n\n\nMitigate slow build times\n\n\n\nIf your package \nrequire\ns heavy modules, you should require them in an\nimplementation of hook \ntrussPreBootstrap\n. For instance, say you have a\npackage like:\n\n\nvar someHeavyModule = require('some-heavy-module');\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};\n\n\n\n\nThis will slow the build process down, since \nsome-heavy-module\n must be\nloaded when loading your package. Use this pattern instead:\n\n\nvar someHeavyModule = null;\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('trussPreBootstrap', function() {\n    someHeavyModule = require('some-heavy-module');\n  });\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};\n\n\n\n\nSo that the heavy module will not be \nrequire\nd until hook\n\ntrussPreBootstrap\n is invoked.\n\n\n1 invocation\n\n  \n\n    \nsrc/main (server)\ninvocation\n  \n\n\n\n\n\ntrussProcessExit\n\n\nFinal cleanups as the process is exiting.\n\n\nThe application tries its hardest to always invoke this hook, even in the\nevent of a raised signal or unhandled exception.\n\n\nYou should not schedule asynchronous events, as they are not guaranteed to be\ndispatched. See\n\nthe Node.js documentation\n\nfor more information.\n\n\n1 implementation\n\n  \n\n    \ntruss-repl (server)\nimplementation\n  \n\n\n\n\n\n1 invocation\n\n  \n\n    \nserver (server)\ninvocation\n  \n\n\n\n\n\ntrussReplContext\n\n\nAdd to the REPL context.\n\n\nPackages may use this hook to provide access to parts of their state to the\nREPL context.\n\n\nImplementations accept the following arguments:\n\n\n\n\n(Object) \ncontext\n - The context object.\n\n\n\n\nTo set context variables, simply set them on the context object.\n\n\n1 invocation\n\n  \n\n    \ntruss-repl (server)\ninvocation\n  \n\n\n\n\n\ntrussTransmittableErrors\n\n\nDefine errors that can be transmitted easily over the wire.\n\n\nSee \nthe documentation on errors\n for more information.\n\n\nImplementations must return\n\n\n\nAn array of subclasses of\n\nTransmittableError\n.\n\n\n1 invocation\n\n  \n\n    \nsrc/errors (server)\ninvocation",
            "title": "Hooks"
        },
        {
            "location": "/hooks/#trussbootstrapmiddleware",
            "text": "Define middleware to run when the server application is bootstrapping.  This hook is where most of the major initialization work happens on the\nserver. You use this to spin up HTTP/sockets/database/whatever.  Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(next) {\n  ...\n}  1 implementation \n   \n     truss-repl (server) implementation      1 invocation \n   \n     src/main (server) invocation",
            "title": "trussBootstrapMiddleware"
        },
        {
            "location": "/hooks/#trussconfigserver",
            "text": "Define server-side configuration settings.  Packages may use this hook to define default configuration for server-side\nfunctionality. These settings can be overridden in the settings file.  Implementations must return  A recursive object which will be folded into the server configuration under\nthe package name key. For instance, say we have a package  my-package  which\ndefines the hook like:  registrar.registerHook('trussConfigServer', function() {\n  return {\n    one: 68,\n    two: {\n      three: 419\n    }\n  };\n});  You would then find those values in the configuration at:  config.get('packageSettings:my-package:one');\nconfig.get('packageSettings:my-package:two:three');  See  the default configuration file  for\nan example of how settings may be overridden. This should always be preferred\nto actually changing the code in a given package's hook.  1 implementation \n   \n     truss-repl (server) implementation      2 invocations \n   \n     Gruntfile (server) invocation      src/main (server) invocation",
            "title": "trussConfigServer"
        },
        {
            "location": "/hooks/#trussgruntconfig",
            "text": "Hook into the Grunt build process.  This hook allows packages to define Grunt tasks, configure existing tasks, and\nload NPM tasks. This is achieved through the first implementation parameter\nwhich is an instance of the class GruntConfiguration . The grunt  object is passed in through the second parameter in case it's needed.  One of the most common uses of this hook is to copy any asset files your\npackage may include to the  app  directory, where they can be served to\nclients.  1 implementation \n   \n     truss-dox (server) implementation      1 invocation \n   \n     Gruntfile (server) invocation",
            "title": "trussGruntConfig"
        },
        {
            "location": "/hooks/#trussgruntconfigalter",
            "text": "Alter the Grunt build process.  This hook allows packages to alter Grunt configuration specified through trussGruntConfig .  The first implementation parameter is an instance of the class GruntConfiguration . The  grunt \nobject is passed in through the second parameter in case it's needed.  1 invocation \n   \n     Gruntfile (server) invocation",
            "title": "trussGruntConfigAlter"
        },
        {
            "location": "/hooks/#trussprebootstrap",
            "text": "Invoked before the application bootstrap phase.  Mitigate slow build times  If your package  require s heavy modules, you should require them in an\nimplementation of hook  trussPreBootstrap . For instance, say you have a\npackage like:  var someHeavyModule = require('some-heavy-module');\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};  This will slow the build process down, since  some-heavy-module  must be\nloaded when loading your package. Use this pattern instead:  var someHeavyModule = null;\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('trussPreBootstrap', function() {\n    someHeavyModule = require('some-heavy-module');\n  });\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};  So that the heavy module will not be  require d until hook trussPreBootstrap  is invoked.  1 invocation \n   \n     src/main (server) invocation",
            "title": "trussPreBootstrap"
        },
        {
            "location": "/hooks/#trussprocessexit",
            "text": "Final cleanups as the process is exiting.  The application tries its hardest to always invoke this hook, even in the\nevent of a raised signal or unhandled exception.  You should not schedule asynchronous events, as they are not guaranteed to be\ndispatched. See the Node.js documentation \nfor more information.  1 implementation \n   \n     truss-repl (server) implementation      1 invocation \n   \n     server (server) invocation",
            "title": "trussProcessExit"
        },
        {
            "location": "/hooks/#trussreplcontext",
            "text": "Add to the REPL context.  Packages may use this hook to provide access to parts of their state to the\nREPL context.  Implementations accept the following arguments:   (Object)  context  - The context object.   To set context variables, simply set them on the context object.  1 invocation \n   \n     truss-repl (server) invocation",
            "title": "trussReplContext"
        },
        {
            "location": "/hooks/#trusstransmittableerrors",
            "text": "Define errors that can be transmitted easily over the wire.  See  the documentation on errors  for more information.  Implementations must return  An array of subclasses of TransmittableError .  1 invocation \n   \n     src/errors (server) invocation",
            "title": "trussTransmittableErrors"
        },
        {
            "location": "/packages/",
            "text": "Package reference\n\n\n\nPackages are how Truss organizes functionality.\n\n\nThis page provides a listing of packages in this project, along with a short\ndescription of the functionality they provide.\n\n\nServer-side\n\n\ntruss-dox\n\n\nGrunt build process - Documentation\n\n\nBuild the documentation in \ngh-pages\n.\n\n\nImplements hooks\n  \n\n    \ntrussGruntConfig\nimplementation\n\n  \n\n\n\n\n\n\n\ntruss-dox/\ndynamic\n\n\nGrunt build process - Dynamic documentation\n\n\n\n\ntruss-repl\n\n\nREPL\n\n\nRuns a REPL and allows packages to add values to its context.\n\n\nImplements hooks\n  \n\n    \ntrussConfigServer\nimplementation\n\n    \ntrussProcessExit\nimplementation\n\n    \ntrussBootstrapMiddleware\nimplementation\n\n  \n\n\n\n\n\nInvokes hooks\n  \n\n    \ntrussReplContext\ninvocation",
            "title": "Packages"
        },
        {
            "location": "/packages/#server-side",
            "text": "",
            "title": "Server-side"
        },
        {
            "location": "/packages/#truss-dox",
            "text": "Grunt build process - Documentation  Build the documentation in  gh-pages .  Implements hooks    \n     trussGruntConfig implementation",
            "title": "truss-dox"
        },
        {
            "location": "/packages/#truss-doxdynamic",
            "text": "Grunt build process - Dynamic documentation",
            "title": "truss-dox/dynamic"
        },
        {
            "location": "/packages/#truss-repl",
            "text": "REPL  Runs a REPL and allows packages to add values to its context.  Implements hooks    \n     trussConfigServer implementation \n     trussProcessExit implementation \n     trussBootstrapMiddleware implementation \n     Invokes hooks    \n     trussReplContext invocation",
            "title": "truss-repl"
        },
        {
            "location": "/todos/",
            "text": "TODO list\n\n\n\nTruss \u2014 like any project \u2014 always presents a path for improvement.\nThis is a dynamically generated list of TODO items, each with context.\n\n\n\n\n\n# Gather all source files.\n_allSourceFiles = ->\n  new Promise (resolve, reject) ->\n\n\n\n\nTODO: Hook belongs here.\n\n\n    glob(\n      '{{client,custom,packages,src}/**/*.{coffee,litcoffee},*.{coffee,litcoffee},config/default.settings.yml}'\n      (error, files) ->\n\n\n\n\nthe above found in packages/truss-dox/dynamic.coffee:183",
            "title": "TODO list"
        },
        {
            "location": "/todos/#todo-hook-belongs-here",
            "text": "glob(\n      '{{client,custom,packages,src}/**/*.{coffee,litcoffee},*.{coffee,litcoffee},config/default.settings.yml}'\n      (error, files) ->  the above found in packages/truss-dox/dynamic.coffee:183",
            "title": "TODO: Hook belongs here."
        },
        {
            "location": "/source/config/default.settings/",
            "text": "Default application configuration.\n\n\n\n\nPackage list\n\n\nThe list of packages active for this application.\n\n\npackageList:\n\n\n\n\nDevelopment\n\n\nProject documentation. Safe to disable on production.\n\n\n  - 'truss-dox'\n\n\n\n\nProduction\n\n\nREPL to control the application.\n\n\n  - 'truss-repl'\n\n\n\n\nPackage configuration\n\n\nValues for packages which correspond with the values provided by packages'\nimplementations of hook \ntrussConfigServer\n.\n\n\npackageConfig: {\n}\n\n\n\n\nBootstrap middleware\n\n\nThe list of middleware that run in the bootstrap phase. This is where you\nspin up your HTTP/socket server, or whatever else. The list contains the\nnames of packages which have an implementation of hook\n\ntrussBootstrapMiddleware\n.\n\n\nbootstrapMiddleware:\n\n\n\n\nSpin up the REPL.\n\n\n  - 'truss-repl'",
            "title": "default.settings.yml"
        },
        {
            "location": "/source/config/default.settings/#default-application-configuration",
            "text": "",
            "title": "Default application configuration."
        },
        {
            "location": "/source/config/default.settings/#package-list",
            "text": "The list of packages active for this application.  packageList:  Development  Project documentation. Safe to disable on production.    - 'truss-dox'  Production  REPL to control the application.    - 'truss-repl'",
            "title": "Package list"
        },
        {
            "location": "/source/config/default.settings/#package-configuration",
            "text": "Values for packages which correspond with the values provided by packages'\nimplementations of hook  trussConfigServer .  packageConfig: {\n}",
            "title": "Package configuration"
        },
        {
            "location": "/source/config/default.settings/#bootstrap-middleware",
            "text": "The list of middleware that run in the bootstrap phase. This is where you\nspin up your HTTP/socket server, or whatever else. The list contains the\nnames of packages which have an implementation of hook trussBootstrapMiddleware .  bootstrapMiddleware:  Spin up the REPL.    - 'truss-repl'",
            "title": "Bootstrap middleware"
        },
        {
            "location": "/source/Gruntfile/",
            "text": "Gruntfile\n\n\nEntry point for the Grunt build process.\n\n\n{fork} = require \"#{__dirname}/src/bootstrap\"\n\nmodule.exports = (grunt) ->\n\n\n\n\nFork so we can bootstrap a Truss environment.\n\n\n  if child = fork()\n    grunt.registerTask 'bootstrap', ->\n\n      done = @async()\n\n      child.on 'close', (code) ->\n\n        return done() if code is 0\n\n        grunt.fail.fatal 'Child process failed', code\n\n\n\n\nForward all tasks.\n\n\n    {tasks} = require 'grunt/lib/grunt/cli'\n    grunt.registerTask tasks[0] ? 'default', ['bootstrap']\n    grunt.registerTask(task, (->)) for task in tasks.slice 1\n\n    return\n\n\n\n\nLoad configuration.\n\n\n  fs = require 'fs'\n\n  yaml = require 'js-yaml'\n\n  config = require 'config'\n\n\n\n\nSet environment variables into config.\n\n\n  config.set 'path', __dirname\n  config.set k, v for k, v of process.env\n\n\n\n\nRead configuration file.\n\n\n  settingsFilename = config.get 'path'\n  settingsFilename += '/config/settings.yml'\n\n  throw new Error '\n    Settings file not found!\n    You should copy config/default.settings.yml to config/settings.yml\n  ' unless fs.existsSync settingsFilename\n\n  settings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\n  config.set k, v for k, v of settings\n\n\n\n\nRegister the configured packages.\n\n\n  pkgman = require 'pkgman'\n  pkgman.registerPackageList config.get 'packageList'\n\n\n\n\nLoad the packages' configuration settings and set into the default config.\n\n\nInvoke hook \ntrussConfigServer\n\n\n  packageConfig = new config.Config()\n  for path, value of pkgman.invoke 'trussConfigServer'\n    packageConfig.set path.replace(/\\//g, ':'), value\n\n  config.setDefaults packageConfig: packageConfig.toJSON()\n\n\n\n\nSpin up the server.\n\n\n\n\n\nrequire('main').start()\n\n\n\n\n\nconfig.load()\nconfig.loadPackageSettings()\n\n\n\n\n\nGruntConfiguration\n\n\n  class GruntConfiguration\n\n\n\n\nconstructor\n\n\n    constructor: ->\n\n      @_npmTasks = []\n      @_taskConfig = {}\n      @_tasks = {}\n\n      @pkg = grunt.file.readJSON 'package.json'\n\n\n\n\nGruntConfiguration#configureTask\n\n\n\n\n\n\n(String) \ntask\n - The name of the task to configure.\n\n\n\n\n\n\n(String) \nkey\n - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.\n\n\n\n\n\n\n(Object) \nconfig_\n - The configuration to set. See the documentation\nfor the particular grunt task being configured to learn how to configure\nit.\n\n\n\n\n\n\nConfigure a Grunt task.\n\n\n    configureTask: (task, key, config_) ->\n\n      (@_taskConfig[task] ?= {})[key] = config_\n\n      return\n\n\n\n\nGruntConfiguration#taskConfiguration\n\n\n\n\n\n\n(String) \ntask\n - The name of the task to configure.\n\n\n\n\n\n\n(String) \nkey\n - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.\n\n\n\n\n\n\nGet the configuration for a Grunt task.\n\n\n    taskConfiguration: (task, key) -> @_taskConfig[task]?[key]\n\n\n\n\nGruntConfiguration#loadNpmTasks\n\n\n\n\n(String Array) \ntasks\n - The list of NPM tasks to load.\n\n\n\n\nLoad NPM tasks.\n\n\n    loadNpmTasks: (tasks) ->\n\n      @_npmTasks.push task for task in tasks\n\n      return\n\n\n\n\nGruntConfiguration#registerTask\n\n\n\n\n\n\n(String) \ntask\n - The name of the task to configure.\n\n\n\n\n\n\n(String Array or Function) \nsubtasksOrFunction\n - Either an array of\nstrings which define the dependencies for the task, or a function which\nwill be executed for the task.\n\n\n\n\n\n\nRegister a Grunt task.\n\n\n    registerTask: (task, subtasksOrFunction) ->\n\n      if 'function' is typeof subtasksOrFunction\n        @_tasks[task] = subtasksOrFunction\n      else\n        (@_tasks[task] ?= []).push subtasksOrFunction...\n\n      return\n\n\n\n\nGruntConfiguration#copyAppFiles\n\n\n\n\n\n\n(String) \npath\n - The path of the files to copy.\n\n\n\n\n\n\n(String) \nkey\n - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.\n\n\n\n\n\n\n(String) \ndest\n - The destination where the files will be copied.\nDefaults to \n'app'\n.\n\n\n\n\n\n\nCopy package files to \napp\n.\n\n\n    copyAppFiles: (path, key, dest = 'app') ->\n      dest ?= 'app'\n\n      gruntConfig.configureTask 'copy', key, files: [\n        src: '**/*'\n        dest: dest\n        expand: true\n        cwd: path\n      ]\n\n      gruntConfig.configureTask(\n        'watch', key\n\n        files: [\n          \"#{path}/**/*\"\n        ]\n        tasks: [\"build:#{key}\"]\n      )\n\n  gruntConfig = new GruntConfiguration()\n\n  gruntConfig.registerTask 'production', ['build']\n  gruntConfig.registerTask 'default', ['buildOnce']\n\n  gruntConfig.registerTask 'buildOnce', do ->\n    built = false\n\n    ->\n      return if built\n      built = true\n\n      grunt.task.run 'build'\n\n\n\n\nInvoke hook \ntrussGruntConfig\n\n\n  pkgman.invoke 'trussGruntConfig', gruntConfig, grunt\n\n\n\n\nInvoke hook \ntrussGruntConfigAlter\n\n\n  pkgman.invoke 'trussGruntConfigAlter', gruntConfig, grunt\n\n\n\n\nInitialize configuration.\n\n\n  grunt.initConfig gruntConfig._taskConfig\n\n\n\n\nLoad NPM tasks.\n\n\n  npmTasksLoaded = {}\n  for task in gruntConfig._npmTasks\n    continue if npmTasksLoaded[task]?\n    npmTasksLoaded[task] = true\n    grunt.loadNpmTasks task\n\n\n\n\nRegister custom tasks.\n\n\n  grunt.registerTask task, actions for task, actions of gruntConfig._tasks",
            "title": "Gruntfile.coffee"
        },
        {
            "location": "/source/Gruntfile/#gruntfile",
            "text": "Entry point for the Grunt build process.  {fork} = require \"#{__dirname}/src/bootstrap\"\n\nmodule.exports = (grunt) ->  Fork so we can bootstrap a Truss environment.    if child = fork()\n    grunt.registerTask 'bootstrap', ->\n\n      done = @async()\n\n      child.on 'close', (code) ->\n\n        return done() if code is 0\n\n        grunt.fail.fatal 'Child process failed', code  Forward all tasks.      {tasks} = require 'grunt/lib/grunt/cli'\n    grunt.registerTask tasks[0] ? 'default', ['bootstrap']\n    grunt.registerTask(task, (->)) for task in tasks.slice 1\n\n    return  Load configuration.    fs = require 'fs'\n\n  yaml = require 'js-yaml'\n\n  config = require 'config'  Set environment variables into config.    config.set 'path', __dirname\n  config.set k, v for k, v of process.env  Read configuration file.    settingsFilename = config.get 'path'\n  settingsFilename += '/config/settings.yml'\n\n  throw new Error '\n    Settings file not found!\n    You should copy config/default.settings.yml to config/settings.yml\n  ' unless fs.existsSync settingsFilename\n\n  settings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\n  config.set k, v for k, v of settings  Register the configured packages.    pkgman = require 'pkgman'\n  pkgman.registerPackageList config.get 'packageList'  Load the packages' configuration settings and set into the default config.  Invoke hook  trussConfigServer    packageConfig = new config.Config()\n  for path, value of pkgman.invoke 'trussConfigServer'\n    packageConfig.set path.replace(/\\//g, ':'), value\n\n  config.setDefaults packageConfig: packageConfig.toJSON()",
            "title": "Gruntfile"
        },
        {
            "location": "/source/Gruntfile/#spin-up-the-server",
            "text": "require('main').start()   config.load()\nconfig.loadPackageSettings()",
            "title": "Spin up the server."
        },
        {
            "location": "/source/Gruntfile/#gruntconfiguration",
            "text": "class GruntConfiguration",
            "title": "GruntConfiguration"
        },
        {
            "location": "/source/Gruntfile/#constructor",
            "text": "constructor: ->\n\n      @_npmTasks = []\n      @_taskConfig = {}\n      @_tasks = {}\n\n      @pkg = grunt.file.readJSON 'package.json'",
            "title": "constructor"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationconfiguretask",
            "text": "(String)  task  - The name of the task to configure.    (String)  key  - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.    (Object)  config_  - The configuration to set. See the documentation\nfor the particular grunt task being configured to learn how to configure\nit.    Configure a Grunt task.      configureTask: (task, key, config_) ->\n\n      (@_taskConfig[task] ?= {})[key] = config_\n\n      return",
            "title": "GruntConfiguration#configureTask"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationtaskconfiguration",
            "text": "(String)  task  - The name of the task to configure.    (String)  key  - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.    Get the configuration for a Grunt task.      taskConfiguration: (task, key) -> @_taskConfig[task]?[key]",
            "title": "GruntConfiguration#taskConfiguration"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationloadnpmtasks",
            "text": "(String Array)  tasks  - The list of NPM tasks to load.   Load NPM tasks.      loadNpmTasks: (tasks) ->\n\n      @_npmTasks.push task for task in tasks\n\n      return",
            "title": "GruntConfiguration#loadNpmTasks"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationregistertask",
            "text": "(String)  task  - The name of the task to configure.    (String Array or Function)  subtasksOrFunction  - Either an array of\nstrings which define the dependencies for the task, or a function which\nwill be executed for the task.    Register a Grunt task.      registerTask: (task, subtasksOrFunction) ->\n\n      if 'function' is typeof subtasksOrFunction\n        @_tasks[task] = subtasksOrFunction\n      else\n        (@_tasks[task] ?= []).push subtasksOrFunction...\n\n      return",
            "title": "GruntConfiguration#registerTask"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationcopyappfiles",
            "text": "(String)  path  - The path of the files to copy.    (String)  key  - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.    (String)  dest  - The destination where the files will be copied.\nDefaults to  'app' .    Copy package files to  app .      copyAppFiles: (path, key, dest = 'app') ->\n      dest ?= 'app'\n\n      gruntConfig.configureTask 'copy', key, files: [\n        src: '**/*'\n        dest: dest\n        expand: true\n        cwd: path\n      ]\n\n      gruntConfig.configureTask(\n        'watch', key\n\n        files: [\n          \"#{path}/**/*\"\n        ]\n        tasks: [\"build:#{key}\"]\n      )\n\n  gruntConfig = new GruntConfiguration()\n\n  gruntConfig.registerTask 'production', ['build']\n  gruntConfig.registerTask 'default', ['buildOnce']\n\n  gruntConfig.registerTask 'buildOnce', do ->\n    built = false\n\n    ->\n      return if built\n      built = true\n\n      grunt.task.run 'build'  Invoke hook  trussGruntConfig    pkgman.invoke 'trussGruntConfig', gruntConfig, grunt  Invoke hook  trussGruntConfigAlter    pkgman.invoke 'trussGruntConfigAlter', gruntConfig, grunt  Initialize configuration.    grunt.initConfig gruntConfig._taskConfig  Load NPM tasks.    npmTasksLoaded = {}\n  for task in gruntConfig._npmTasks\n    continue if npmTasksLoaded[task]?\n    npmTasksLoaded[task] = true\n    grunt.loadNpmTasks task  Register custom tasks.    grunt.registerTask task, actions for task, actions of gruntConfig._tasks",
            "title": "GruntConfiguration#copyAppFiles"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/",
            "text": "Grunt build process - Dynamic documentation\n\n\n{exec} = require 'child_process'\nfs = require 'fs'\npath = require 'path'\n{Transform} = require 'stream'\n\n_ = require 'lodash'\n{LineStream} = require 'byline'\nglob = require 'glob'\nPromise = require 'bluebird'\n\n\n\n\nImplement a Transform stream to accumulate hook invocations from a source\nfile.\n\n\nclass HookInvocations extends Transform\n\n  constructor: ->\n    super\n\n    @list = []\n\n  _transform: (chunk, encoding, done) ->\n    line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# #### Invoke hook `([^`]+)`/\n      @list.push matches[1]\n\n    done()\n\n\n\n\nImplement a Transform stream to accumulate hook implementations from a\nsource file.\n\n\nclass HookImplementations extends Transform\n\n  constructor: ->\n    super\n\n    @list = []\n\n  _transform: (chunk, encoding, done) ->\n    line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# #### Implements hook `([^`]+)`/\n      @list.push matches[1]\n\n    done()\n\n\n\n\nImplement a Transform stream to accumulate TODOs from a source file. Also\ncaches lines to be able to build context around each TODO item.\n\n\nclass Todos extends Transform\n\n  @context = 4\n\n  constructor: ->\n    super\n\n    @lines = []\n    @todos = []\n\n  _transform: (chunk, encoding, done) ->\n    @lines.push line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# ###### TODO/\n      @todos.push @lines.length - 1\n\n    done()\n\n  withContext: ->\n\n    for todo in @todos\n\n      start = Math.max 0, todo - Todos.context\n      end = Math.min @lines.length - 1, todo + Todos.context\n\n      index: todo\n      lines: @lines.slice start, end\n\n\n\n\nImplement a Transform stream to parse title and description for a file.\n\n\nclass TitleAndDescription extends Transform\n\n  constructor: ->\n    super\n\n    @hasFinishedParsing = false\n\n    @title = ''\n    @description = ''\n\n  _transform: (chunk, encoding, done) ->\n\n    return done() if @hasFinishedParsing\n\n    line = chunk.toString('utf8').trim()\n    return done() if line.length is 0\n\n    if 35 is line.charCodeAt(0)\n\n      if 35 is line.charCodeAt(2)\n        @title = line.substr 4\n\n      else if 42 is line.charCodeAt(2)\n        @description = line.substr 2\n\n      else if @description?\n        @description += ' ' + line.substr 2\n\n      if 42 is @description.charCodeAt @description.length - 1\n        @hasFinishedParsing = true\n\n    else\n\n      @hasFinishedParsing = true\n\n    return done()\n\n\n\n\nImplement a transform stream to convert a .coffee file to .litcoffee\n\n\nclass LitcoffeeConversion extends Transform\n\n  constructor: (@filename) ->\n    super\n\n    @highlight = if @filename.match /\\.(?:lit)?coffee$/\n      'coffeescript'\n    else if @filename.match /\\.js$/\n      'javascript'\n    else\n      'no-highlight'\n\n    @hanging = []\n    @hasWrittenCode = false\n    @commenting = false\n\n    @on 'finish', => @unshift \"```\\n\" if @hasWrittenCode and not @commenting\n\n  _transform: (chunk, encoding, done) ->\n\n    line = chunk.toString 'utf8'\n\n\n\n\nComment.\n\n\n    if '#'.charCodeAt(0) is line.trim().charCodeAt(0)\n\n      @push \"```\\n\\n\" if @hasWrittenCode and not @commenting\n\n      comment = line.trim().substr 2\n\n      matches = comment.match /^#### (I(?:nvoke|mplements)) hook `([^`]+)`/\n      if matches\n\n        parts = path.dirname(@filename).split('/')\n        parts.push '' if 'index.coffee' isnt path.basename @filename\n        backpath = parts.map(-> '..').join '/'\n\n        @push \"#### #{\n          matches[1]\n        } hook [`#{\n          matches[2]\n        }`](#{\n          backpath\n        }/hooks##{\n          matches[2].toLowerCase()\n        })\\n\"\n\n      else\n\n        @push \"#{comment}\\n\"\n\n      @commenting = true\n\n    else\n\n      @hanging = [] if @commenting\n      @push \"\\n```#{@highlight}\\n\" if @commenting or not @hasWrittenCode\n\n      if line.length is 0\n        @hanging.push '' unless @commenting\n      else\n        @push \"\\n\" for blank in @hanging\n        @hanging = []\n        @push \"#{line}\\n\"\n\n      @commenting = false\n      @hasWrittenCode = true\n\n    done()\n\n\n\n\nGather all source files.\n\n\n_allSourceFiles = ->\n  new Promise (resolve, reject) ->\n\n\n\n\nTODO: Hook belongs here.\n\n\n    glob(\n      '{{client,custom,packages,src}/**/*.{coffee,litcoffee},*.{coffee,litcoffee},config/default.settings.yml}'\n      (error, files) ->\n        return reject error if error?\n        resolve files\n    )\n\n\n\n\nGenerate an HTML ID from a string.\n\n\n_idFromString = (string) -> string.replace(\n  /[/'']/g, ''\n).replace(\n  /\\[(.*)\\]\\(.*\\)/g, '$1'\n).replace(\n  /[^0-9A-Za-z-]+/g, '-'\n).replace(\n  /\\-+/g, '-'\n).toLowerCase()\n\n\n\n\nGet the source path from a filename. This removes the extension and any\n/index portion from the end of the filename.\n\n\n_sourcePath = (filename) ->\n\n    dirname = path.dirname filename\n    if dirname is '.' then dirname = '' else dirname += '/'\n    extname = path.extname filename\n    filename = \"#{dirname}#{path.basename filename, extname}\"\n\n    parts = filename.split '/'\n    parts.pop() if parts[parts.length - 1] is 'index'\n    return parts.join '/'\n\n\n\n\nCollate a list of files by type (client or server).\n\n\n_collateFilesByType = (files) ->\n\n  client = []\n  server = []\n\n  for file in files\n    parts = file.split '/'\n\n    if parts[0] is 'client'\n      client.push file\n    else if parts[0] is 'custom' and parts[2] is 'client'\n      client.push file\n    else if parts[0] is 'packages' and parts[2] is 'client'\n      client.push file\n    else\n      server.push file\n\n  client: client, server: server\n\n\n\n\nAdd all the source files to a generated mkdocs.yml\n\n\ngeneratedFilesPromise = _allSourceFiles().then (files) ->\n\n  promises = for file in files\n    parts = file.split '/'\n\n    for i in [0...parts.length]\n      try\n        fs.mkdirSync \"docs/source/#{parts.slice(0, i).join '/'}\"\n      catch error\n\n    fstream = fs.createReadStream file\n    fstream.pipe lineStream = new LineStream keepEmptyLines: true\n\n\n\n\nConvert to litcoffee.\n\n\n    lineStream.pipe litcoffeeConversion = new LitcoffeeConversion file\n    writeStream = fs.createWriteStream \"docs/source/#{file}\"\n    litcoffeeConversion.pipe writeStream\n\n    new Promise (resolve) -> do (file) ->\n\n      writeStream.on 'close', -> resolve file\n\n  Promise.all promises\n\n\n\n\nGather statistics for all files.\n\n\nfileStatsListPromise = generatedFilesPromise.then (allFiles) ->\n\n  allFilesPromises = for type, files of _collateFilesByType allFiles\n\n    typePromises = for file in files\n\n      do (type, file) -> new Promise (resolve, reject) ->\n\n        fstream = fs.createReadStream file\n        fstream.pipe lineStream = new LineStream keepEmptyLines: true\n\n\n\n\nPass all files through the Transform list to parse out relevant\ninformation.\n\n\n        lineStream.pipe hookImplementations = new HookImplementations()\n        lineStream.pipe hookInvocations = new HookInvocations()\n        lineStream.pipe todos = new Todos()\n        lineStream.pipe titleAndDescription = new TitleAndDescription()\n\n        fstream.on 'error', reject\n\n        fstream.on 'end', ->\n\n\n\n\nInclude all information from Transform streams in the statistics.\n\n\n          resolve(\n            type: type\n            file: file\n            implementations: hookImplementations.list\n            invocations: hookInvocations.list\n            todos: todos.withContext()\n            title: titleAndDescription.title\n            description: titleAndDescription.description\n          )\n\n    Promise.all typePromises\n\n  Promise.all(allFilesPromises).then (fileStatsLists) ->\n    _.flatten fileStatsLists\n\n\n\n\nMassage the statistics to help rendering the hooks page.\n\n\nfileStatsListPromise.then((fileStatsList) ->\n\n  hooksIndex = {}\n\n  indexes = {}\n  keys = ['implementations', 'invocations']\n\n  for fileStats in fileStatsList\n\n    parts = fileStats.file.split '/'\n    for remove in ['client', 'packages']\n      if ~(index = parts.indexOf remove)\n        parts.splice index, 1\n    mergeFile = parts.join '/'\n\n    for key in keys\n      indexes[key] ?= {}\n\n      for hook in fileStats[key]\n        indexes[key][hook] ?= {}\n\n        indexes[key][hook][mergeFile] ?= fullName: fileStats.file\n        (indexes[key][hook][mergeFile].types ?= []).push fileStats.type\n\n        hooksIndex[hook] = true\n\n  for key in keys\n    for hook, stats of indexes[key]\n      for file of stats\n        stats[file].types = _.sortedUniq stats[file].types.sort() ? []\n\n  hooks = (hook for hook of hooksIndex).sort()\n\n  hookFiles = {}\n  for hook in hooks\n    hookFiles[hook] = try\n      fs.readFileSync \"docs/hook/#{hook}.md\", 'utf8'\n    catch error\n      console.error \"Missing hook template for #{hook}\"\n      ''\n\n  O =\n    hookFiles: hookFiles\n    hooks: hooks\n\n  O[key] = indexes[key] for key in keys\n\n  return O\n\n\n\n\nRender the hooks page.\n\n\n).then((O) ->\n\n  {hookFiles, hooks} = O\n\n  keys = ['implementation', 'invocation']\n\n  wordingFor =\n    implementation: 'implements'\n    invocation: 'invoke'\n\n  render = fs.readFileSync 'docs/hooks.template.md', 'utf8'\n\n  for hook in hooks\n\n    render += \"## #{hook}\\n\\n\"\n    render += hookFiles[hook] + '\\n\\n' if hookFiles[hook]\n\n    for key in keys\n      pluralKey = \"#{key}s\"\n\n      if O[pluralKey][hook]?\n\n        count = 0\n        for file, {types} of O[pluralKey][hook]\n          count += types.length\n\n        render += '<div class=\"admonition note\">'\n        render += \"<p class=\\\"admonition-title\\\">#{count} #{key}\"\n        render += 's' if count > 1\n        render += '</p>\\n'\n        render += '  <table>\\n'\n\n        stripe = 0\n        instances = for file, {fullName, types} of O[pluralKey][hook]\n\n\n\n\nRemove client path part, only added when necessary.\n\n\n          parts = fullName.split '/'\n          for remove in ['client']\n            if ~(index = parts.indexOf remove)\n              parts.splice index, 1\n          fullName = parts.join '/'\n\n          parts = file.split '/'\n          for remove in ['client']\n            if ~(index = parts.indexOf remove)\n              parts.splice index, 1\n          file = parts.join '/'\n\n          addClientToFullPath = (isClient, path) ->\n\n            return path unless isClient\n            parts = path.split '/'\n            return path if parts[0] isnt 'packages'\n            parts.splice 2, 0, 'client'\n            parts.join '/'\n\n          do (fullName) -> types = types.map (type) ->\n            \"    <tr class=\\\"#{\n              if stripe++ % 2 then 'odd' else 'even'\n            }\\\"><td><a href=\\\"../source/#{\n              addClientToFullPath type is 'client', _sourcePath fullName\n            }\\\">#{\n              _sourcePath file\n            } (#{\n              type\n            })</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{\n              addClientToFullPath type is 'client', _sourcePath fullName\n            }##{\n              wordingFor[key]\n            }-hook-#{\n              _idFromString hook\n            }\\\">#{\n              key\n            }</a></td></tr>\"\n          types.join ''\n\n        render += instances.join ''\n\n        render += '  </table>\\n'\n        render += '</div>'\n        render += '\\n\\n'\n\n  new Promise (resolve, reject) ->\n    fs.writeFile 'docs/hooks.md', render, (error) ->\n      return reject error if error?\n      resolve()\n\n).done()\n\n\n\n\nRender the TODOs page.\n\n\nfileStatsListPromise.then((fileStatsList) ->\n\n  render = fs.readFileSync 'docs/todos.template.md', 'utf8'\n\n  for fileStats in fileStatsList\n\n\n\n\nKeep track of used IDs, it will be necessary to link to the correct\nlocation hash in the case of multiple TODO items with the same wording.\n\n\n    idMap = {}\n\n    for todo in fileStats.todos\n\n      filename = _sourcePath fileStats.file\n\n      highlight = if fileStats.file.match /\\.(?:lit)?coffee$/\n         'coffeescript'\n      else if fileStats.file.match /\\.js$/\n        'javascript'\n      else\n        'no-highlight'\n\n      render += \"\\n---\\n\\n```#{highlight}\\n\"\n\n      id = ''\n      for line, index in todo.lines\n\n\n\n\nIf this is the line with the TODO, parse the ID from the TODO item\ntext, and render it as h2 (TODO are h6) to increase visibility.\n\n\n        if index is Todos.context\n          id = _idFromString(line).slice 1, -1\n\n          render += \"```\\n\\n#{line.trim().slice 6}\\n\\n```#{highlight}\"\n        else\n          render += line\n        render += '\\n'\n\n      render += '```\\n\\n'\n\n\n\n\nKeep track of ID usage and modify the location hash for subsequent\nuses.\n\n\n      if idMap[id]?\n        idMap[id] += 1\n        id += \"_#{idMap[id]}\"\n      else\n        idMap[id] = 0\n\n      render += \"[the above found in #{\n        fileStats.file\n      }:#{\n        todo.index\n      }](source/#{\n        filename\n      }##{\n        id\n      })\\n\\n\"\n\n  new Promise (resolve, reject) ->\n    fs.writeFile 'docs/todos.md', render, (error) ->\n      return reject error if error?\n      resolve()\n\n).done()\n\n_allSourceFiles().then (files) ->\n\n  yml = fs.readFileSync 'docs/mkdocs.template.yml', 'utf8'\n\n  renderHierarchy = (output, hierarchy) ->\n\n    renderHierarchyInternal = (output, hierarchy, indent) ->\n\n      if _.isString hierarchy\n\n        output[output.length - 1] += \" '#{hierarchy}'\"\n\n      else\n\n        for k, v of hierarchy\n\n          output.push \"#{indent}- #{k}:\"\n          renderHierarchyInternal output, v, \"#{indent}    \"\n\n    renderHierarchyInternal output, hierarchy, ''\n\n  hierarchy = Source: {}\n  for file in files\n    walk = hierarchy.Source\n    parts = file.split '/'\n    for part, i in parts\n      if i is parts.length - 1\n        walk[part] = \"source/#{file}\"\n      else\n        walk[part] ?= {}\n        walk = walk[part]\n\n  output = []\n  renderHierarchy output, hierarchy\n  fs.writeFileSync 'mkdocs.yml', yml + output.join \"\\n\"\n\n\n\n\nRender the packages page.\n\n\nfileStatsListPromise.then((fileStatsList) ->\n\n\n\n\nSort by package name first.\n\n\n  newList = []\n\n  for fileStats in fileStatsList\n\n    parts = fileStats.file.split '/'\n    continue unless ~['custom', 'packages'].indexOf parts[0]\n\n    sourcePath = _sourcePath fileStats.file\n\n    parts = sourcePath.split '/'\n    pkg = parts.join '/'\n    fileStats.pkg = pkg.split('/').slice(1).join '/'\n\n    newList.push fileStats\n\n  newList.sort (l, r) ->\n    return -1 if l.type is 'client' and r.type is 'server'\n    return 1 if l.type is 'server' and r.type is 'client'\n    if l.pkg < r.pkg then -1 else if l.pkg > r.pkg then 1 else 0\n\n).then((fileStatsList) ->\n\n  render = fs.readFileSync 'docs/packages.template.md', 'utf8'\n  render += '\\n'\n\n  type = null\n\n  for fileStats in fileStatsList\n\n    if fileStats.type isnt type\n      type = fileStats.type\n\n      render += if type is 'client'\n        '## Client-side'\n      else\n        '## Server-side'\n\n      render += '\\n\\n'\n\n    pkgParts = fileStats.pkg.split '/'\n    isSubpackage = pkgParts.length isnt 1 and pkgParts.pop() isnt 'client'\n\n\n\n\nLink to the package.\n\n\n    sourcePath = _sourcePath fileStats.file\n\n    if isSubpackage\n      render += '> '\n      parts = fileStats.pkg.split '/'\n      parentPkg = parts.shift()\n      subPkg = parts.join '/'\n      render += \"## [<small>#{parentPkg}/</small>#{subPkg}](source/#{sourcePath})\"\n    else\n      render += \"## [#{fileStats.pkg}](source/#{sourcePath})\"\n\n    if fileStats.title?\n      render += '\\n\\n'\n      render += '> ' if isSubpackage\n      render += \"<span class=\\\"package-title\\\">#{fileStats.title}</span>\"\n\n    render += '\\n\\n'\n\n    if fileStats.description?\n      render += '> ' if isSubpackage\n      render += \"#{fileStats.description}\\n\\n\"\n\n    if fileStats.implementations.length > 0\n      render += '> ' if isSubpackage\n      render += '<div class=\"admonition note\">'\n      render += '<p class=\"admonition-title\">Implements hooks</p>'\n      render += '  <table>\\n'\n      render += fileStats.implementations.map((hook, index) ->\n        \"    <tr class=\\\"#{if index % 2 then 'odd' else 'even'}\\\"><td><a href=\\\"../hooks/##{_idFromString hook}\\\">#{hook}</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{sourcePath}#implements-hook-#{hook.toLowerCase()}\\\">implementation</a></td></tr>\\n\"\n      ).join ''\n      render += '  </table>\\n'\n      render += '</div>'\n      render += '\\n\\n'\n\n\n\n\nif fileStats.invocations.length > 0\n  render += '> ' if isSubpackage\n  render += '<div class=\"admonition note\">'\n  render += '<p class=\"admonition-title\">Invokes hooks</p>'\n  render += '  <table>\\n'\n  render += fileStats.invocations.map((hook, index) ->\n    \"    <tr class=\\\"#{if index % 2 then 'odd' else 'even'}\\\"><td><a href=\\\"../hooks/##{_idFromString hook}\\\">#{hook}</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{sourcePath}#invoke-hook-#{hook.toLowerCase()}\\\">invocation</a></td></tr>\\n\"\n  ).join ''\n  render += '  </table>\\n'\n  render += '</div>'\n  render += '\\n\\n'\n\n\n\nfs.writeFileSync 'docs/packages.md', render\n\n\n)",
            "title": "dynamic.coffee"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/#grunt-build-process-dynamic-documentation",
            "text": "{exec} = require 'child_process'\nfs = require 'fs'\npath = require 'path'\n{Transform} = require 'stream'\n\n_ = require 'lodash'\n{LineStream} = require 'byline'\nglob = require 'glob'\nPromise = require 'bluebird'  Implement a Transform stream to accumulate hook invocations from a source\nfile.  class HookInvocations extends Transform\n\n  constructor: ->\n    super\n\n    @list = []\n\n  _transform: (chunk, encoding, done) ->\n    line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# #### Invoke hook `([^`]+)`/\n      @list.push matches[1]\n\n    done()  Implement a Transform stream to accumulate hook implementations from a\nsource file.  class HookImplementations extends Transform\n\n  constructor: ->\n    super\n\n    @list = []\n\n  _transform: (chunk, encoding, done) ->\n    line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# #### Implements hook `([^`]+)`/\n      @list.push matches[1]\n\n    done()  Implement a Transform stream to accumulate TODOs from a source file. Also\ncaches lines to be able to build context around each TODO item.  class Todos extends Transform\n\n  @context = 4\n\n  constructor: ->\n    super\n\n    @lines = []\n    @todos = []\n\n  _transform: (chunk, encoding, done) ->\n    @lines.push line = chunk.toString('utf8')\n    if matches = line.match /^\\s*# ###### TODO/\n      @todos.push @lines.length - 1\n\n    done()\n\n  withContext: ->\n\n    for todo in @todos\n\n      start = Math.max 0, todo - Todos.context\n      end = Math.min @lines.length - 1, todo + Todos.context\n\n      index: todo\n      lines: @lines.slice start, end  Implement a Transform stream to parse title and description for a file.  class TitleAndDescription extends Transform\n\n  constructor: ->\n    super\n\n    @hasFinishedParsing = false\n\n    @title = ''\n    @description = ''\n\n  _transform: (chunk, encoding, done) ->\n\n    return done() if @hasFinishedParsing\n\n    line = chunk.toString('utf8').trim()\n    return done() if line.length is 0\n\n    if 35 is line.charCodeAt(0)\n\n      if 35 is line.charCodeAt(2)\n        @title = line.substr 4\n\n      else if 42 is line.charCodeAt(2)\n        @description = line.substr 2\n\n      else if @description?\n        @description += ' ' + line.substr 2\n\n      if 42 is @description.charCodeAt @description.length - 1\n        @hasFinishedParsing = true\n\n    else\n\n      @hasFinishedParsing = true\n\n    return done()  Implement a transform stream to convert a .coffee file to .litcoffee  class LitcoffeeConversion extends Transform\n\n  constructor: (@filename) ->\n    super\n\n    @highlight = if @filename.match /\\.(?:lit)?coffee$/\n      'coffeescript'\n    else if @filename.match /\\.js$/\n      'javascript'\n    else\n      'no-highlight'\n\n    @hanging = []\n    @hasWrittenCode = false\n    @commenting = false\n\n    @on 'finish', => @unshift \"```\\n\" if @hasWrittenCode and not @commenting\n\n  _transform: (chunk, encoding, done) ->\n\n    line = chunk.toString 'utf8'  Comment.      if '#'.charCodeAt(0) is line.trim().charCodeAt(0)\n\n      @push \"```\\n\\n\" if @hasWrittenCode and not @commenting\n\n      comment = line.trim().substr 2\n\n      matches = comment.match /^#### (I(?:nvoke|mplements)) hook `([^`]+)`/\n      if matches\n\n        parts = path.dirname(@filename).split('/')\n        parts.push '' if 'index.coffee' isnt path.basename @filename\n        backpath = parts.map(-> '..').join '/'\n\n        @push \"#### #{\n          matches[1]\n        } hook [`#{\n          matches[2]\n        }`](#{\n          backpath\n        }/hooks##{\n          matches[2].toLowerCase()\n        })\\n\"\n\n      else\n\n        @push \"#{comment}\\n\"\n\n      @commenting = true\n\n    else\n\n      @hanging = [] if @commenting\n      @push \"\\n```#{@highlight}\\n\" if @commenting or not @hasWrittenCode\n\n      if line.length is 0\n        @hanging.push '' unless @commenting\n      else\n        @push \"\\n\" for blank in @hanging\n        @hanging = []\n        @push \"#{line}\\n\"\n\n      @commenting = false\n      @hasWrittenCode = true\n\n    done()  Gather all source files.  _allSourceFiles = ->\n  new Promise (resolve, reject) ->  TODO: Hook belongs here.      glob(\n      '{{client,custom,packages,src}/**/*.{coffee,litcoffee},*.{coffee,litcoffee},config/default.settings.yml}'\n      (error, files) ->\n        return reject error if error?\n        resolve files\n    )  Generate an HTML ID from a string.  _idFromString = (string) -> string.replace(\n  /[/'']/g, ''\n).replace(\n  /\\[(.*)\\]\\(.*\\)/g, '$1'\n).replace(\n  /[^0-9A-Za-z-]+/g, '-'\n).replace(\n  /\\-+/g, '-'\n).toLowerCase()  Get the source path from a filename. This removes the extension and any\n/index portion from the end of the filename.  _sourcePath = (filename) ->\n\n    dirname = path.dirname filename\n    if dirname is '.' then dirname = '' else dirname += '/'\n    extname = path.extname filename\n    filename = \"#{dirname}#{path.basename filename, extname}\"\n\n    parts = filename.split '/'\n    parts.pop() if parts[parts.length - 1] is 'index'\n    return parts.join '/'  Collate a list of files by type (client or server).  _collateFilesByType = (files) ->\n\n  client = []\n  server = []\n\n  for file in files\n    parts = file.split '/'\n\n    if parts[0] is 'client'\n      client.push file\n    else if parts[0] is 'custom' and parts[2] is 'client'\n      client.push file\n    else if parts[0] is 'packages' and parts[2] is 'client'\n      client.push file\n    else\n      server.push file\n\n  client: client, server: server  Add all the source files to a generated mkdocs.yml  generatedFilesPromise = _allSourceFiles().then (files) ->\n\n  promises = for file in files\n    parts = file.split '/'\n\n    for i in [0...parts.length]\n      try\n        fs.mkdirSync \"docs/source/#{parts.slice(0, i).join '/'}\"\n      catch error\n\n    fstream = fs.createReadStream file\n    fstream.pipe lineStream = new LineStream keepEmptyLines: true  Convert to litcoffee.      lineStream.pipe litcoffeeConversion = new LitcoffeeConversion file\n    writeStream = fs.createWriteStream \"docs/source/#{file}\"\n    litcoffeeConversion.pipe writeStream\n\n    new Promise (resolve) -> do (file) ->\n\n      writeStream.on 'close', -> resolve file\n\n  Promise.all promises  Gather statistics for all files.  fileStatsListPromise = generatedFilesPromise.then (allFiles) ->\n\n  allFilesPromises = for type, files of _collateFilesByType allFiles\n\n    typePromises = for file in files\n\n      do (type, file) -> new Promise (resolve, reject) ->\n\n        fstream = fs.createReadStream file\n        fstream.pipe lineStream = new LineStream keepEmptyLines: true  Pass all files through the Transform list to parse out relevant\ninformation.          lineStream.pipe hookImplementations = new HookImplementations()\n        lineStream.pipe hookInvocations = new HookInvocations()\n        lineStream.pipe todos = new Todos()\n        lineStream.pipe titleAndDescription = new TitleAndDescription()\n\n        fstream.on 'error', reject\n\n        fstream.on 'end', ->  Include all information from Transform streams in the statistics.            resolve(\n            type: type\n            file: file\n            implementations: hookImplementations.list\n            invocations: hookInvocations.list\n            todos: todos.withContext()\n            title: titleAndDescription.title\n            description: titleAndDescription.description\n          )\n\n    Promise.all typePromises\n\n  Promise.all(allFilesPromises).then (fileStatsLists) ->\n    _.flatten fileStatsLists  Massage the statistics to help rendering the hooks page.  fileStatsListPromise.then((fileStatsList) ->\n\n  hooksIndex = {}\n\n  indexes = {}\n  keys = ['implementations', 'invocations']\n\n  for fileStats in fileStatsList\n\n    parts = fileStats.file.split '/'\n    for remove in ['client', 'packages']\n      if ~(index = parts.indexOf remove)\n        parts.splice index, 1\n    mergeFile = parts.join '/'\n\n    for key in keys\n      indexes[key] ?= {}\n\n      for hook in fileStats[key]\n        indexes[key][hook] ?= {}\n\n        indexes[key][hook][mergeFile] ?= fullName: fileStats.file\n        (indexes[key][hook][mergeFile].types ?= []).push fileStats.type\n\n        hooksIndex[hook] = true\n\n  for key in keys\n    for hook, stats of indexes[key]\n      for file of stats\n        stats[file].types = _.sortedUniq stats[file].types.sort() ? []\n\n  hooks = (hook for hook of hooksIndex).sort()\n\n  hookFiles = {}\n  for hook in hooks\n    hookFiles[hook] = try\n      fs.readFileSync \"docs/hook/#{hook}.md\", 'utf8'\n    catch error\n      console.error \"Missing hook template for #{hook}\"\n      ''\n\n  O =\n    hookFiles: hookFiles\n    hooks: hooks\n\n  O[key] = indexes[key] for key in keys\n\n  return O  Render the hooks page.  ).then((O) ->\n\n  {hookFiles, hooks} = O\n\n  keys = ['implementation', 'invocation']\n\n  wordingFor =\n    implementation: 'implements'\n    invocation: 'invoke'\n\n  render = fs.readFileSync 'docs/hooks.template.md', 'utf8'\n\n  for hook in hooks\n\n    render += \"## #{hook}\\n\\n\"\n    render += hookFiles[hook] + '\\n\\n' if hookFiles[hook]\n\n    for key in keys\n      pluralKey = \"#{key}s\"\n\n      if O[pluralKey][hook]?\n\n        count = 0\n        for file, {types} of O[pluralKey][hook]\n          count += types.length\n\n        render += '<div class=\"admonition note\">'\n        render += \"<p class=\\\"admonition-title\\\">#{count} #{key}\"\n        render += 's' if count > 1\n        render += '</p>\\n'\n        render += '  <table>\\n'\n\n        stripe = 0\n        instances = for file, {fullName, types} of O[pluralKey][hook]  Remove client path part, only added when necessary.            parts = fullName.split '/'\n          for remove in ['client']\n            if ~(index = parts.indexOf remove)\n              parts.splice index, 1\n          fullName = parts.join '/'\n\n          parts = file.split '/'\n          for remove in ['client']\n            if ~(index = parts.indexOf remove)\n              parts.splice index, 1\n          file = parts.join '/'\n\n          addClientToFullPath = (isClient, path) ->\n\n            return path unless isClient\n            parts = path.split '/'\n            return path if parts[0] isnt 'packages'\n            parts.splice 2, 0, 'client'\n            parts.join '/'\n\n          do (fullName) -> types = types.map (type) ->\n            \"    <tr class=\\\"#{\n              if stripe++ % 2 then 'odd' else 'even'\n            }\\\"><td><a href=\\\"../source/#{\n              addClientToFullPath type is 'client', _sourcePath fullName\n            }\\\">#{\n              _sourcePath file\n            } (#{\n              type\n            })</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{\n              addClientToFullPath type is 'client', _sourcePath fullName\n            }##{\n              wordingFor[key]\n            }-hook-#{\n              _idFromString hook\n            }\\\">#{\n              key\n            }</a></td></tr>\"\n          types.join ''\n\n        render += instances.join ''\n\n        render += '  </table>\\n'\n        render += '</div>'\n        render += '\\n\\n'\n\n  new Promise (resolve, reject) ->\n    fs.writeFile 'docs/hooks.md', render, (error) ->\n      return reject error if error?\n      resolve()\n\n).done()  Render the TODOs page.  fileStatsListPromise.then((fileStatsList) ->\n\n  render = fs.readFileSync 'docs/todos.template.md', 'utf8'\n\n  for fileStats in fileStatsList  Keep track of used IDs, it will be necessary to link to the correct\nlocation hash in the case of multiple TODO items with the same wording.      idMap = {}\n\n    for todo in fileStats.todos\n\n      filename = _sourcePath fileStats.file\n\n      highlight = if fileStats.file.match /\\.(?:lit)?coffee$/\n         'coffeescript'\n      else if fileStats.file.match /\\.js$/\n        'javascript'\n      else\n        'no-highlight'\n\n      render += \"\\n---\\n\\n```#{highlight}\\n\"\n\n      id = ''\n      for line, index in todo.lines  If this is the line with the TODO, parse the ID from the TODO item\ntext, and render it as h2 (TODO are h6) to increase visibility.          if index is Todos.context\n          id = _idFromString(line).slice 1, -1\n\n          render += \"```\\n\\n#{line.trim().slice 6}\\n\\n```#{highlight}\"\n        else\n          render += line\n        render += '\\n'\n\n      render += '```\\n\\n'  Keep track of ID usage and modify the location hash for subsequent\nuses.        if idMap[id]?\n        idMap[id] += 1\n        id += \"_#{idMap[id]}\"\n      else\n        idMap[id] = 0\n\n      render += \"[the above found in #{\n        fileStats.file\n      }:#{\n        todo.index\n      }](source/#{\n        filename\n      }##{\n        id\n      })\\n\\n\"\n\n  new Promise (resolve, reject) ->\n    fs.writeFile 'docs/todos.md', render, (error) ->\n      return reject error if error?\n      resolve()\n\n).done()\n\n_allSourceFiles().then (files) ->\n\n  yml = fs.readFileSync 'docs/mkdocs.template.yml', 'utf8'\n\n  renderHierarchy = (output, hierarchy) ->\n\n    renderHierarchyInternal = (output, hierarchy, indent) ->\n\n      if _.isString hierarchy\n\n        output[output.length - 1] += \" '#{hierarchy}'\"\n\n      else\n\n        for k, v of hierarchy\n\n          output.push \"#{indent}- #{k}:\"\n          renderHierarchyInternal output, v, \"#{indent}    \"\n\n    renderHierarchyInternal output, hierarchy, ''\n\n  hierarchy = Source: {}\n  for file in files\n    walk = hierarchy.Source\n    parts = file.split '/'\n    for part, i in parts\n      if i is parts.length - 1\n        walk[part] = \"source/#{file}\"\n      else\n        walk[part] ?= {}\n        walk = walk[part]\n\n  output = []\n  renderHierarchy output, hierarchy\n  fs.writeFileSync 'mkdocs.yml', yml + output.join \"\\n\"  Render the packages page.  fileStatsListPromise.then((fileStatsList) ->  Sort by package name first.    newList = []\n\n  for fileStats in fileStatsList\n\n    parts = fileStats.file.split '/'\n    continue unless ~['custom', 'packages'].indexOf parts[0]\n\n    sourcePath = _sourcePath fileStats.file\n\n    parts = sourcePath.split '/'\n    pkg = parts.join '/'\n    fileStats.pkg = pkg.split('/').slice(1).join '/'\n\n    newList.push fileStats\n\n  newList.sort (l, r) ->\n    return -1 if l.type is 'client' and r.type is 'server'\n    return 1 if l.type is 'server' and r.type is 'client'\n    if l.pkg < r.pkg then -1 else if l.pkg > r.pkg then 1 else 0\n\n).then((fileStatsList) ->\n\n  render = fs.readFileSync 'docs/packages.template.md', 'utf8'\n  render += '\\n'\n\n  type = null\n\n  for fileStats in fileStatsList\n\n    if fileStats.type isnt type\n      type = fileStats.type\n\n      render += if type is 'client'\n        '## Client-side'\n      else\n        '## Server-side'\n\n      render += '\\n\\n'\n\n    pkgParts = fileStats.pkg.split '/'\n    isSubpackage = pkgParts.length isnt 1 and pkgParts.pop() isnt 'client'  Link to the package.      sourcePath = _sourcePath fileStats.file\n\n    if isSubpackage\n      render += '> '\n      parts = fileStats.pkg.split '/'\n      parentPkg = parts.shift()\n      subPkg = parts.join '/'\n      render += \"## [<small>#{parentPkg}/</small>#{subPkg}](source/#{sourcePath})\"\n    else\n      render += \"## [#{fileStats.pkg}](source/#{sourcePath})\"\n\n    if fileStats.title?\n      render += '\\n\\n'\n      render += '> ' if isSubpackage\n      render += \"<span class=\\\"package-title\\\">#{fileStats.title}</span>\"\n\n    render += '\\n\\n'\n\n    if fileStats.description?\n      render += '> ' if isSubpackage\n      render += \"#{fileStats.description}\\n\\n\"\n\n    if fileStats.implementations.length > 0\n      render += '> ' if isSubpackage\n      render += '<div class=\"admonition note\">'\n      render += '<p class=\"admonition-title\">Implements hooks</p>'\n      render += '  <table>\\n'\n      render += fileStats.implementations.map((hook, index) ->\n        \"    <tr class=\\\"#{if index % 2 then 'odd' else 'even'}\\\"><td><a href=\\\"../hooks/##{_idFromString hook}\\\">#{hook}</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{sourcePath}#implements-hook-#{hook.toLowerCase()}\\\">implementation</a></td></tr>\\n\"\n      ).join ''\n      render += '  </table>\\n'\n      render += '</div>'\n      render += '\\n\\n'  if fileStats.invocations.length > 0\n  render += '> ' if isSubpackage\n  render += '<div class=\"admonition note\">'\n  render += '<p class=\"admonition-title\">Invokes hooks</p>'\n  render += '  <table>\\n'\n  render += fileStats.invocations.map((hook, index) ->\n    \"    <tr class=\\\"#{if index % 2 then 'odd' else 'even'}\\\"><td><a href=\\\"../hooks/##{_idFromString hook}\\\">#{hook}</a></td><td align=\\\"right\\\"><a href=\\\"../source/#{sourcePath}#invoke-hook-#{hook.toLowerCase()}\\\">invocation</a></td></tr>\\n\"\n  ).join ''\n  render += '  </table>\\n'\n  render += '</div>'\n  render += '\\n\\n'  fs.writeFileSync 'docs/packages.md', render  )",
            "title": "Grunt build process - Dynamic documentation"
        },
        {
            "location": "/source/packages/truss-dox/",
            "text": "Grunt build process - Documentation\n\n\nBuild the documentation in \ngh-pages\n.\n\n\n{fork, spawn} = require 'child_process'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \ntrussGruntConfig\n\n\n  registrar.registerHook 'trussGruntConfig', (gruntConfig, grunt) ->\n\n    gruntConfig.configureTask 'clean', 'truss-dox', [\n      'mkdocs.yml'\n      'docs/source'\n      'docs/{hooks,packages,todos}.md'\n      'gh-pages/*'\n      '!gh-pages/.git'\n      '!gh-pages/.gitignore'\n    ]\n\n    gruntConfig.registerTask 'truss-dox:prepareDirectory', ->\n      grunt.file.mkdir 'gh-pages'\n\n    gruntConfig.registerTask 'truss-dox:dynamic', ->\n      done = @async()\n\n      fork(\"#{__dirname}/dynamic.coffee\").on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Dynamic documentation generation failed', code\n\n    gruntConfig.registerTask 'truss-dox:mkdocs', ->\n      done = @async()\n\n      spawn('mkdocs', ['build']).on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Running `mkdocs build` failed', code\n\n    gruntConfig.registerTask 'truss-dox', [\n       'truss-dox:prepareDirectory'\n       'truss-dox:dynamic'\n       'truss-dox:mkdocs'\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/truss-dox/#grunt-build-process-documentation",
            "text": "Build the documentation in  gh-pages .  {fork, spawn} = require 'child_process'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  trussGruntConfig    registrar.registerHook 'trussGruntConfig', (gruntConfig, grunt) ->\n\n    gruntConfig.configureTask 'clean', 'truss-dox', [\n      'mkdocs.yml'\n      'docs/source'\n      'docs/{hooks,packages,todos}.md'\n      'gh-pages/*'\n      '!gh-pages/.git'\n      '!gh-pages/.gitignore'\n    ]\n\n    gruntConfig.registerTask 'truss-dox:prepareDirectory', ->\n      grunt.file.mkdir 'gh-pages'\n\n    gruntConfig.registerTask 'truss-dox:dynamic', ->\n      done = @async()\n\n      fork(\"#{__dirname}/dynamic.coffee\").on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Dynamic documentation generation failed', code\n\n    gruntConfig.registerTask 'truss-dox:mkdocs', ->\n      done = @async()\n\n      spawn('mkdocs', ['build']).on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Running `mkdocs build` failed', code\n\n    gruntConfig.registerTask 'truss-dox', [\n       'truss-dox:prepareDirectory'\n       'truss-dox:dynamic'\n       'truss-dox:mkdocs'\n    ]",
            "title": "Grunt build process - Documentation"
        },
        {
            "location": "/source/packages/truss-repl/",
            "text": "REPL\n\n\nRuns a REPL and allows packages to add values to its context.\n\n\nCoffeeScript = require 'coffee-script'\nfs = require 'fs'\nnet = require 'net'\nreplServer = require 'repl'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'truss:repl'\n\n\n\n\nThe socket server.\n\n\nserver = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \ntrussConfigServer\n\n\n  registrar.registerHook 'trussConfigServer', ->\n\n\n\n\nThe prompt display for REPL clients.\n\n\n    prompt: 'truss> '\n\n\n\n\nThe location of the socket.\n\n\n    socket: \"#{__dirname}/socket\"\n\n\n\n\nUse a CoffeeScript REPL?\n\n\n    useCoffee: true\n\n\n\n\nImplements hook \ntrussProcessExit\n\n\n  registrar.registerHook 'trussProcessExit', -> server?.close()\n\n\n\n\nImplements hook \ntrussBootstrapMiddleware\n\n\n  registrar.registerHook 'trussBootstrapMiddleware', ->\n\n    label: 'REPL'\n    middleware: [\n\n      (next) ->\n\n        settings = config.get 'packageConfig:truss-repl'\n\n        server = net.createServer (socket) ->\n\n\n\n\nInvoke hook \ntrussReplContext\n\n\n          pkgman.invoke 'trussReplContext', context = {}\n\n\n\n\nREPL server options.\n\n\n          opts =\n            prompt: settings.prompt\n            input: socket\n            output: socket\n            ignoreUndefined: true\n\n\n\n\nCoffeeScript?\n\n\n          if settings.useCoffee\n\n            opts.prompt = \"(coffee) #{settings.prompt}\"\n\n\n\n\nDefine our own eval function, using CoffeeScript.\n\n\n            opts.eval = (cmd, context, filename, callback) ->\n\n\n\n\nHandle blank lines correctly.\n\n\n              return callback null, undefined if cmd is '(\\n)'\n\n\n\n\nForward the input to CoffeeScript for evalulation.\n\n\n              try\n\n                callback null, CoffeeScript.eval(\n                  cmd\n                  sandbox: context\n                  filename: filename\n                )\n\n              catch error\n\n                callback error\n\n\n\n\nSpin up the server, inject the values from \ntrussReplContext\n, and\nprepare for later cleanup.\n\n\n          repl = replServer.start opts\n          repl.context[key] = value for key, value of context\n          repl.on 'exit', -> socket.end()\n\n\n\n\nTry to be tidy about things.\n\n\n        fs.unlink settings.socket, (error) ->\n\n\n\n\nIgnore the error if it's just saying the socket didn't exist.\n\n\n          return next error if error.code isnt 'ENOENT' if error?\n\n\n\n\nBind the REPL server socket.\n\n\n          server.listen settings.socket, (error) ->\n            return next error if error?\n            debug \"REPL server listening at #{settings.socket}\"\n            next()\n\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/truss-repl/#repl",
            "text": "Runs a REPL and allows packages to add values to its context.  CoffeeScript = require 'coffee-script'\nfs = require 'fs'\nnet = require 'net'\nreplServer = require 'repl'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'truss:repl'  The socket server.  server = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  trussConfigServer    registrar.registerHook 'trussConfigServer', ->  The prompt display for REPL clients.      prompt: 'truss> '  The location of the socket.      socket: \"#{__dirname}/socket\"  Use a CoffeeScript REPL?      useCoffee: true  Implements hook  trussProcessExit    registrar.registerHook 'trussProcessExit', -> server?.close()  Implements hook  trussBootstrapMiddleware    registrar.registerHook 'trussBootstrapMiddleware', ->\n\n    label: 'REPL'\n    middleware: [\n\n      (next) ->\n\n        settings = config.get 'packageConfig:truss-repl'\n\n        server = net.createServer (socket) ->  Invoke hook  trussReplContext            pkgman.invoke 'trussReplContext', context = {}  REPL server options.            opts =\n            prompt: settings.prompt\n            input: socket\n            output: socket\n            ignoreUndefined: true  CoffeeScript?            if settings.useCoffee\n\n            opts.prompt = \"(coffee) #{settings.prompt}\"  Define our own eval function, using CoffeeScript.              opts.eval = (cmd, context, filename, callback) ->  Handle blank lines correctly.                return callback null, undefined if cmd is '(\\n)'  Forward the input to CoffeeScript for evalulation.                try\n\n                callback null, CoffeeScript.eval(\n                  cmd\n                  sandbox: context\n                  filename: filename\n                )\n\n              catch error\n\n                callback error  Spin up the server, inject the values from  trussReplContext , and\nprepare for later cleanup.            repl = replServer.start opts\n          repl.context[key] = value for key, value of context\n          repl.on 'exit', -> socket.end()  Try to be tidy about things.          fs.unlink settings.socket, (error) ->  Ignore the error if it's just saying the socket didn't exist.            return next error if error.code isnt 'ENOENT' if error?  Bind the REPL server socket.            server.listen settings.socket, (error) ->\n            return next error if error?\n            debug \"REPL server listening at #{settings.socket}\"\n            next()\n\n    ]",
            "title": "REPL"
        },
        {
            "location": "/source/server/",
            "text": "Native server application entry point.\n\n\n\n\n\nFork the app to ensure proper environment exists.\n\n\n{fork} = require \"#{__dirname}/src/bootstrap\"\nunless fork()\n\n  path = require 'path'\n  fs = require 'fs'\n\n  config = require 'config'\n  pkgman = require 'pkgman'\n  yaml = require 'js-yaml'\n\n\n\n\nSet up exit hooks.\n\n\nInvoke hook \ntrussProcessExit\n\n\n  process.on 'exit', -> pkgman.invoke 'trussProcessExit'\n\n  process.on 'SIGINT', -> process.exit()\n  process.on 'SIGTERM', -> process.exit()\n  process.on 'unhandledException', -> process.exit()\n\n\n\n\nSet environment variables into config.\n\n\n  config.set 'path', __dirname\n  config.set k, v for k, v of process.env\n\n\n\n\nRead configuration file.\n\n\n  settingsFilename = config.get 'path'\n  settingsFilename += '/config/settings.yml'\n\n  throw new Error '\n    Settings file not found!\n    You should copy config/default.settings.yml to config/settings.yml\n  ' unless fs.existsSync settingsFilename\n\n  settings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\n  config.set k, v for k, v of settings\n\n\n\n\nSpin up the server.\n\n\n  require('main').start (error) ->\n\n    console.error errors.stack error\n    process.exit 1",
            "title": "server.coffee"
        },
        {
            "location": "/source/server/#native-server-application-entry-point",
            "text": "Fork the app to ensure proper environment exists.  {fork} = require \"#{__dirname}/src/bootstrap\"\nunless fork()\n\n  path = require 'path'\n  fs = require 'fs'\n\n  config = require 'config'\n  pkgman = require 'pkgman'\n  yaml = require 'js-yaml'  Set up exit hooks.  Invoke hook  trussProcessExit    process.on 'exit', -> pkgman.invoke 'trussProcessExit'\n\n  process.on 'SIGINT', -> process.exit()\n  process.on 'SIGTERM', -> process.exit()\n  process.on 'unhandledException', -> process.exit()  Set environment variables into config.    config.set 'path', __dirname\n  config.set k, v for k, v of process.env  Read configuration file.    settingsFilename = config.get 'path'\n  settingsFilename += '/config/settings.yml'\n\n  throw new Error '\n    Settings file not found!\n    You should copy config/default.settings.yml to config/settings.yml\n  ' unless fs.existsSync settingsFilename\n\n  settings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\n  config.set k, v for k, v of settings  Spin up the server.    require('main').start (error) ->\n\n    console.error errors.stack error\n    process.exit 1",
            "title": "Native server application entry point."
        },
        {
            "location": "/source/src/bootstrap/",
            "text": "Process bootstrap\n\n\nBootstrap the server application by forking to ensure require paths are set\nby default.\n\n\n{fork} = require 'child_process'\n\n\n\n\nboostrap.fork\n\n\nFork the process in order to inject require paths if necessary.\n\n\nexports.fork = ->\n\n\n\n\nIf we've already forked, our work is done.\n\n\n  return null if process.env.TRUSS_FORKED?\n\n\n\n\nEnsure we have default require paths.\n\n\n  TRUSS_REQUIRE_PATH = if process.env.TRUSS_REQUIRE_PATH?\n    process.env.TRUSS_REQUIRE_PATH\n  else\n    'custom:packages:src'\n\n\n\n\nPass all arguments to the child process.\n\n\n  args = process.argv.slice 2\n\n\n\n\nPass the environment to the child process.\n\n\n  options = env: process.env\n\n\n\n\nIntegrate any NODE_PATH after the Truss require paths.\n\n\n  if process.env.NODE_PATH?\n    TRUSS_REQUIRE_PATH += \":#{process.env.NODE_PATH}\"\n\n\n\n\nInject Truss require paths as the new NODE_PATH, and signal that we've\nforked.\n\n\n  options.env.NODE_PATH = TRUSS_REQUIRE_PATH\n  options.env.TRUSS_FORKED = true\n\n\n\n\nFork it.\n\n\n  fork process.argv[1], args, options",
            "title": "bootstrap.coffee"
        },
        {
            "location": "/source/src/bootstrap/#process-bootstrap",
            "text": "Bootstrap the server application by forking to ensure require paths are set\nby default.  {fork} = require 'child_process'",
            "title": "Process bootstrap"
        },
        {
            "location": "/source/src/bootstrap/#boostrapfork",
            "text": "Fork the process in order to inject require paths if necessary.  exports.fork = ->  If we've already forked, our work is done.    return null if process.env.TRUSS_FORKED?  Ensure we have default require paths.    TRUSS_REQUIRE_PATH = if process.env.TRUSS_REQUIRE_PATH?\n    process.env.TRUSS_REQUIRE_PATH\n  else\n    'custom:packages:src'  Pass all arguments to the child process.    args = process.argv.slice 2  Pass the environment to the child process.    options = env: process.env  Integrate any NODE_PATH after the Truss require paths.    if process.env.NODE_PATH?\n    TRUSS_REQUIRE_PATH += \":#{process.env.NODE_PATH}\"  Inject Truss require paths as the new NODE_PATH, and signal that we've\nforked.    options.env.NODE_PATH = TRUSS_REQUIRE_PATH\n  options.env.TRUSS_FORKED = true  Fork it.    fork process.argv[1], args, options",
            "title": "boostrap.fork"
        },
        {
            "location": "/source/src/config/",
            "text": "Configuration system.\n\n\nHandle getting, setting, and checking configuration state.\n\n\nmodule.exports = new class Config\n\n\n\n\nThis class allows us to wrap and subsequently get, set, and check the\nexistence of values in a configuration tree. The configuration tree may be\ntraversed with colons, e.g. \nparent:child:grandchild\n. Supposing we have a\nconfiguration structure:\n\n\nconfiguration =\n  visible: true\n  child:\n    id: 200\n    tag: null\n\n\n\n\nWe may wrap and interact with it as follows:\n\n\nwrapped = new Config configuration\nwrapped.get 'visible'\n\n\n\n\nReturns: \ntrue\n\n\nwrapped.set 'child:name', 'Billy'\nwrapped.get 'child'\n\n\n\n\nReturns: \n{ id: 200, name: 'Billy' }\n\n\nwrapped.has 'child:id'\n\n\n\n\nReturns: \ntrue\n\n\nwrapped.has 'child:thing'\n\n\n\n\nReturns: \nfalse\n\n\nNOTE:\n \nhas\n works with null values:\n\n\nwrapped.has 'child:tag'\n\n\n\n\nReturns: \ntrue\n\n\nProvide the class externally.\n\n\n  Config: Config\n\n\n\n\nconstructor\n\n\n\n\n(object) \nconfig\n - The configuration tree.\n\n\n\n\nCreate a configuration wrapper.\n\n\n  constructor: (config = {}) -> @from config\n\n\n\n\nConfig#from\n\n\n\n\n(object) \nconfig\n - The configuration object.\n\n\n\n\nSet configuration from an object.\n\n\n  from: (@config) ->\n\n\n\n\nConfig#get\n\n\n\n\n(string) \npath\n - The path to look up, e.g. parent:child:grandchild\n\n\n\n\nGet a value by path.\n\n\n  get: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      current = current?[part]\n    current\n\n\n\n\nConfig#has\n\n\n\n\n(string) \npath\n - The path to look up, e.g. \n'parent:child:grandchild'\n\n\n\n\nCheck whether a path exists.\n\n\n  has: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      return false unless 'object' is typeof current\n      return false unless part of current\n      current = current[part]\n\n    return true\n\n\n\n\nConfig#set\n\n\n\n\n\n\n(string) \npath\n - The path to look up, e.g. parent:child:grandchild\n\n\n\n\n\n\n(any) \nvalue\n - The value to store at the path location.\n\n\n\n\n\n\nSet a value by path.\n\n\n  set: (path, value) ->\n\n    [parts..., last] = path.split ':'\n    current = @config\n    for part in parts\n      current = (current[part] ?= {})\n\n    current[last] = value\n\n\n\n\nConfig#setDefault\n\n\n\n\n\n\n(string) \npath\n - The path to look up, e.g. parent:child:grandchild\n\n\n\n\n\n\n(any) \nvalue\n - The value to store at the path location.\n\n\n\n\n\n\nSet a value by path if one doesn't already exist.\n\n\n  setDefault: (path, value) -> @set path, value unless @has path, value\n\n\n\n\nConfig#setDefaults\n\n\n\n\n(object) \ndefaults\n - A Config object containing default paths/values.\n\n\n\n\nSet values by path if they doesn't already exist.\n\n\n  setDefaults: (defaults) ->\n    self = this\n\n    recur = (object, path) ->\n\n      if self.has pathString = path.join ':'\n        if object? and 'object' is typeof object\n\n          recur object[k], path.concat k for k of object\n\n      else\n\n        self.set pathString, object\n\n    recur defaults[k], [k] for k of defaults\n\n    return\n\n\n\n\nConfig#toJSON\n\n\nReturn config object for serialization.\n\n\n  toJSON: -> @config",
            "title": "config.coffee"
        },
        {
            "location": "/source/src/config/#configuration-system",
            "text": "Handle getting, setting, and checking configuration state.  module.exports = new class Config  This class allows us to wrap and subsequently get, set, and check the\nexistence of values in a configuration tree. The configuration tree may be\ntraversed with colons, e.g.  parent:child:grandchild . Supposing we have a\nconfiguration structure:  configuration =\n  visible: true\n  child:\n    id: 200\n    tag: null  We may wrap and interact with it as follows:  wrapped = new Config configuration\nwrapped.get 'visible'  Returns:  true  wrapped.set 'child:name', 'Billy'\nwrapped.get 'child'  Returns:  { id: 200, name: 'Billy' }  wrapped.has 'child:id'  Returns:  true  wrapped.has 'child:thing'  Returns:  false  NOTE:   has  works with null values:  wrapped.has 'child:tag'  Returns:  true",
            "title": "Configuration system."
        },
        {
            "location": "/source/src/config/#provide-the-class-externally",
            "text": "Config: Config",
            "title": "Provide the class externally."
        },
        {
            "location": "/source/src/config/#constructor",
            "text": "(object)  config  - The configuration tree.   Create a configuration wrapper.    constructor: (config = {}) -> @from config",
            "title": "constructor"
        },
        {
            "location": "/source/src/config/#configfrom",
            "text": "(object)  config  - The configuration object.   Set configuration from an object.    from: (@config) ->",
            "title": "Config#from"
        },
        {
            "location": "/source/src/config/#configget",
            "text": "(string)  path  - The path to look up, e.g. parent:child:grandchild   Get a value by path.    get: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      current = current?[part]\n    current",
            "title": "Config#get"
        },
        {
            "location": "/source/src/config/#confighas",
            "text": "(string)  path  - The path to look up, e.g.  'parent:child:grandchild'   Check whether a path exists.    has: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      return false unless 'object' is typeof current\n      return false unless part of current\n      current = current[part]\n\n    return true",
            "title": "Config#has"
        },
        {
            "location": "/source/src/config/#configset",
            "text": "(string)  path  - The path to look up, e.g. parent:child:grandchild    (any)  value  - The value to store at the path location.    Set a value by path.    set: (path, value) ->\n\n    [parts..., last] = path.split ':'\n    current = @config\n    for part in parts\n      current = (current[part] ?= {})\n\n    current[last] = value",
            "title": "Config#set"
        },
        {
            "location": "/source/src/config/#configsetdefault",
            "text": "(string)  path  - The path to look up, e.g. parent:child:grandchild    (any)  value  - The value to store at the path location.    Set a value by path if one doesn't already exist.    setDefault: (path, value) -> @set path, value unless @has path, value",
            "title": "Config#setDefault"
        },
        {
            "location": "/source/src/config/#configsetdefaults",
            "text": "(object)  defaults  - A Config object containing default paths/values.   Set values by path if they doesn't already exist.    setDefaults: (defaults) ->\n    self = this\n\n    recur = (object, path) ->\n\n      if self.has pathString = path.join ':'\n        if object? and 'object' is typeof object\n\n          recur object[k], path.concat k for k of object\n\n      else\n\n        self.set pathString, object\n\n    recur defaults[k], [k] for k of defaults\n\n    return",
            "title": "Config#setDefaults"
        },
        {
            "location": "/source/src/config/#configtojson",
            "text": "Return config object for serialization.    toJSON: -> @config",
            "title": "Config#toJSON"
        },
        {
            "location": "/source/src/errors/",
            "text": "Error handling\n\n\npkgman = require 'pkgman'\n\n\n\n\nTransmittableError\n\n\nExtend this class if you'd like to implement an error.\n\n\nexports.TransmittableError = class TransmittableError extends Error\n\n\n\n\nTransmittableError#constructor\n\n\nSee:\n\nhttps://github.com/jashkenas/coffee-script/issues/2359\n\n\n  constructor: (@message) ->\n\n\n\n\nTransmittableError#errorType\n\n\nA unique key for this error.\n\n\n  errorType: 'unknown'\n\n\n\n\nTransmittableError#template\n\n\nThe template used to format the error output.\n\n\n  template: 'Unknown error: :message'\n\n\n\n\nTransmittableError#toJSON\n\n\nImplement this if you need to transmit more than just the error type and\nthe message. Truss uses the result from this function to serialize the\nerror over the wire.\n\n\n  toJSON: -> [@errorType, @message]\n\n\n\n\nerrors.instantiate\n\n\n\n\n\n\n(string) \nerrorType\n - The error type.\n\n\n\n\n\n\n(any) \nargs...\n - Additional arguments to pass to the error type's\n\n\n\n\n\n\nconstructor. \nInstantiate an error based on error type, passing along args\nto the error's constructor.\n\n\nexports.instantiate = (errorType, args...) ->\n\n\n\n\nLook up the error type and use it. If it's not registered, fall back to\nthe TransmittableError superclass.\n\n\n  Types = exports.transmittableErrors()\n  Type = if Types[errorType]? then Types[errorType] else TransmittableError\n\n\n\n\nTrickery to be able to essentially call \nnew\n with \nFunction::apply\n.\n\n\n  IType = do (Type) ->\n    F = (args) -> Type.apply this, args\n    F.prototype = Type.prototype\n    (args) -> new F args\n\n  error = IType args\n\n\n\n\nThrow so we have a (possibly) meaningful stack.\n\n\n  try\n    throw new Error()\n  catch stackError\n    stackError.message = exports.message error\n    error.stack = stackError.stack\n\n  error\n\n\n\n\nerrors.message\n\n\n\n\n(Error) \nerror\n - The error object.\n\n\n\n\nExtract an error message from an error.\n\n\nexports.message = (error) ->\n\n\n\n\nOne of us! One of us!\n\n\n  output = if error instanceof TransmittableError\n    error.template\n\n\n\n\nAbstract Error.\n\n\n  else if error instanceof Error\n    TransmittableError::template.replace ':message', error.message\n\n\n\n\nNot an instance of \nError\n. This probably shouldn't happen, but we deal\nwith it anyway.\n\n\n  else\n    TransmittableError::template.replace ':message', error.toString()\n\n\n\n\nReplace placeholders in the template.\n\n\n  output = output.replace \":#{key}\", value for key, value of error\n  output\n\n\n\n\nerrors.serialize\n\n\n\n\n(Error) \nerror\n - The error object.\n\n\n\n\nSerialize an error to send over the wire.\n\n\nexports.serialize = (error) ->\n\n\n\n\nOne of us! One of us!\n\n\n  if error instanceof TransmittableError\n    error.toJSON()\n\n\n\n\nAbstract Error.\n\n\n  else if error instanceof Error\n    [undefined, error.message]\n\n\n\n\nNot an instance of \nError\n. This probably shouldn't happen, but we deal\nwith it anyway.\n\n\n  else\n    [undefined, error]\n\n\n\n\nerrors.stack\n\n\n\n\n(Error) \nerror\n - The error object.\n\n\n\n\nExtract the stack trace from an error.\n\n\nexports.stack = (error) ->\n\n\n\n\nDoes the stack trace exist?\n\n\n  formatStack = if (formatStack = error.stack)?\n\n\n\n\nIf so, shift off the first line (the message).\n\n\n    formatStack = formatStack.split '\\n'\n    formatStack.shift()\n    '\\n' + formatStack.join '\\n'\n\n\n\n\nOtherwise, we don't have much to work with...\n\n\n  else\n    ''\n\n\n\n\nPrepend our pretty formatted message before the stack trace.\n\n\n  \"#{@message error}#{formatStack}\"\n\n\n\n\nerrors.transmittableErrors\n\n\nCollect the error types implemented by packages.\n\n\nexports.transmittableErrors = ->\n\n  _ = require 'lodash'\n\n\n\n\nInvoke hook \ntrussTransmittableErrors\n\n\nAllows packages to specify transmittable errors. Implementations should\nreturn a subclass of \nTransmittableError\n.\n\n\n  Types = {}\n\n  Types[Type::errorType] = Type for Type in [TransmittableError].concat(\n    _.flatten pkgman.invokeFlat 'trussTransmittableErrors'\n  )\n\n  Types\n\n\n\n\nerrors.unserialize\n\n\nUnserialize an error from over the wire.\n\n\nexports.unserialize = (data) -> exports.instantiate.apply null, data",
            "title": "errors.coffee"
        },
        {
            "location": "/source/src/errors/#error-handling",
            "text": "pkgman = require 'pkgman'",
            "title": "Error handling"
        },
        {
            "location": "/source/src/errors/#transmittableerror",
            "text": "Extend this class if you'd like to implement an error.  exports.TransmittableError = class TransmittableError extends Error",
            "title": "TransmittableError"
        },
        {
            "location": "/source/src/errors/#transmittableerrorconstructor",
            "text": "See: https://github.com/jashkenas/coffee-script/issues/2359    constructor: (@message) ->",
            "title": "TransmittableError#constructor"
        },
        {
            "location": "/source/src/errors/#transmittableerrorerrortype",
            "text": "A unique key for this error.    errorType: 'unknown'",
            "title": "TransmittableError#errorType"
        },
        {
            "location": "/source/src/errors/#transmittableerrortemplate",
            "text": "The template used to format the error output.    template: 'Unknown error: :message'",
            "title": "TransmittableError#template"
        },
        {
            "location": "/source/src/errors/#transmittableerrortojson",
            "text": "Implement this if you need to transmit more than just the error type and\nthe message. Truss uses the result from this function to serialize the\nerror over the wire.    toJSON: -> [@errorType, @message]",
            "title": "TransmittableError#toJSON"
        },
        {
            "location": "/source/src/errors/#errorsinstantiate",
            "text": "(string)  errorType  - The error type.    (any)  args...  - Additional arguments to pass to the error type's    constructor.  Instantiate an error based on error type, passing along args\nto the error's constructor.  exports.instantiate = (errorType, args...) ->  Look up the error type and use it. If it's not registered, fall back to\nthe TransmittableError superclass.    Types = exports.transmittableErrors()\n  Type = if Types[errorType]? then Types[errorType] else TransmittableError  Trickery to be able to essentially call  new  with  Function::apply .    IType = do (Type) ->\n    F = (args) -> Type.apply this, args\n    F.prototype = Type.prototype\n    (args) -> new F args\n\n  error = IType args  Throw so we have a (possibly) meaningful stack.    try\n    throw new Error()\n  catch stackError\n    stackError.message = exports.message error\n    error.stack = stackError.stack\n\n  error",
            "title": "errors.instantiate"
        },
        {
            "location": "/source/src/errors/#errorsmessage",
            "text": "(Error)  error  - The error object.   Extract an error message from an error.  exports.message = (error) ->  One of us! One of us!    output = if error instanceof TransmittableError\n    error.template  Abstract Error.    else if error instanceof Error\n    TransmittableError::template.replace ':message', error.message  Not an instance of  Error . This probably shouldn't happen, but we deal\nwith it anyway.    else\n    TransmittableError::template.replace ':message', error.toString()  Replace placeholders in the template.    output = output.replace \":#{key}\", value for key, value of error\n  output",
            "title": "errors.message"
        },
        {
            "location": "/source/src/errors/#errorsserialize",
            "text": "(Error)  error  - The error object.   Serialize an error to send over the wire.  exports.serialize = (error) ->  One of us! One of us!    if error instanceof TransmittableError\n    error.toJSON()  Abstract Error.    else if error instanceof Error\n    [undefined, error.message]  Not an instance of  Error . This probably shouldn't happen, but we deal\nwith it anyway.    else\n    [undefined, error]",
            "title": "errors.serialize"
        },
        {
            "location": "/source/src/errors/#errorsstack",
            "text": "(Error)  error  - The error object.   Extract the stack trace from an error.  exports.stack = (error) ->  Does the stack trace exist?    formatStack = if (formatStack = error.stack)?  If so, shift off the first line (the message).      formatStack = formatStack.split '\\n'\n    formatStack.shift()\n    '\\n' + formatStack.join '\\n'  Otherwise, we don't have much to work with...    else\n    ''  Prepend our pretty formatted message before the stack trace.    \"#{@message error}#{formatStack}\"",
            "title": "errors.stack"
        },
        {
            "location": "/source/src/errors/#errorstransmittableerrors",
            "text": "Collect the error types implemented by packages.  exports.transmittableErrors = ->\n\n  _ = require 'lodash'  Invoke hook  trussTransmittableErrors  Allows packages to specify transmittable errors. Implementations should\nreturn a subclass of  TransmittableError .    Types = {}\n\n  Types[Type::errorType] = Type for Type in [TransmittableError].concat(\n    _.flatten pkgman.invokeFlat 'trussTransmittableErrors'\n  )\n\n  Types",
            "title": "errors.transmittableErrors"
        },
        {
            "location": "/source/src/errors/#errorsunserialize",
            "text": "Unserialize an error from over the wire.  exports.unserialize = (data) -> exports.instantiate.apply null, data",
            "title": "errors.unserialize"
        },
        {
            "location": "/source/src/main/",
            "text": "Server application entry point\n\n\nLoad the configuration, invoke the bootstrap hooks, and listen for signals\nand process exit.\n The core bootstrap phase injects environment into a\nforked copy of the application including require paths to allow core and\ncustom packages to be included without qualification.\n\n\nconfig = require 'config'\ndebug = require('debug') 'truss:main'\nmiddleware = require 'middleware'\npkgman = require 'pkgman'\n\nexports.start = (errorHandler) ->\n\n\n\n\nRegister the configured packages.\n\n\n  pkgman.registerPackageList config.get 'packageList'\n\n\n\n\nLoad the packages' configuration settings and set into the default config.\n\n\nInvoke hook \ntrussConfigServer\n\n\n  packageConfig = new config.Config()\n  for path, value of pkgman.invoke 'trussConfigServer'\n    packageConfig.set path.replace(/\\//g, ':'), value\n\n  config.setDefaults packageConfig: packageConfig.toJSON()\n\n\n\n\nRun the pre-bootstrap phase.\n\n\nInvoke hook \ntrussPreBootstrap\n\n\n  debug 'Pre bootstrap started...'\n  pkgman.invoke 'trussPreBootstrap'\n  debug 'Pre bootstrap complete.'\n\n\n\n\nLoad the bootstrap middleware.\n\n\nInvoke hook \ntrussBootstrapMiddleware\n\n\n  debug 'Bootstrap started...'\n  bootstrapMiddleware = middleware.fromHook(\n    'trussBootstrapMiddleware'\n    config.get 'bootstrapMiddleware'\n  )\n\n\n\n\nDispatch the bootstrap middleware and log if everything is okay.\n\n\n  bootstrapMiddleware.dispatch (error) ->\n    return debug 'Bootstrap complete.' unless error?\n\n\n\n\nLog any error and exit.\n\n\n    errorHandler error",
            "title": "main.coffee"
        },
        {
            "location": "/source/src/main/#server-application-entry-point",
            "text": "Load the configuration, invoke the bootstrap hooks, and listen for signals\nand process exit.  The core bootstrap phase injects environment into a\nforked copy of the application including require paths to allow core and\ncustom packages to be included without qualification.  config = require 'config'\ndebug = require('debug') 'truss:main'\nmiddleware = require 'middleware'\npkgman = require 'pkgman'\n\nexports.start = (errorHandler) ->  Register the configured packages.    pkgman.registerPackageList config.get 'packageList'  Load the packages' configuration settings and set into the default config.  Invoke hook  trussConfigServer    packageConfig = new config.Config()\n  for path, value of pkgman.invoke 'trussConfigServer'\n    packageConfig.set path.replace(/\\//g, ':'), value\n\n  config.setDefaults packageConfig: packageConfig.toJSON()  Run the pre-bootstrap phase.  Invoke hook  trussPreBootstrap    debug 'Pre bootstrap started...'\n  pkgman.invoke 'trussPreBootstrap'\n  debug 'Pre bootstrap complete.'  Load the bootstrap middleware.  Invoke hook  trussBootstrapMiddleware    debug 'Bootstrap started...'\n  bootstrapMiddleware = middleware.fromHook(\n    'trussBootstrapMiddleware'\n    config.get 'bootstrapMiddleware'\n  )  Dispatch the bootstrap middleware and log if everything is okay.    bootstrapMiddleware.dispatch (error) ->\n    return debug 'Bootstrap complete.' unless error?  Log any error and exit.      errorHandler error",
            "title": "Server application entry point"
        },
        {
            "location": "/source/src/middleware/",
            "text": "Abstract middleware stacks\n\n\n{EventEmitter} = require 'events'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\n\n\n\nImplements a middleware stack. Middleware functions can be added to the\nstack with \nuse\n. Calling \ndispatch\n invokes the middleware functions\nserially.\n\n\nDefining middleware\n\n\nEach middleware accepts an arbitrary parameters and finally a \nnext\n\nfunction. When a middleware finishes, it must call the \nnext\n function.\nIf there was an error, it must be thrown or passed as the first argument to\n\nnext\n. If no error occurred, \nnext\n must be invoked without arguments.\nError-handling middleware can also be defined. These middleware take an\nadditional parameter at the beginning of the function signature: \nerror\n.\nError-handling middleware are only called if a previous middleware threw\nor passed an error. Conversely, non-error-handling middleware are skipped\nif a previous error occurred.\n\n\nexports.Middleware = class Middleware extends EventEmitter\n\n\n\n\nconstructor\n\n\nCreate a middleware stack.\n\n\n  constructor: -> @_middleware = []\n\n\n\n\nMiddlware#use\n\n\n\n\n(function) \nfn\n - A middleware function.\n\n\n\n\nAdd a middleware function to the stack.\n\n\n  use: (fn) -> @_middleware.push fn\n\n\n\n\nMiddleware#dispatch\n\n\n\n\n\n\n(mixed) \n...\n - Zero or more values to pass to the middleware.\n\n\n\n\n\n\n(function) \nfn\n - A function invoked when the middleware stack has\nfinished. If an error occurred, it will be passed as the first argument.\n\n\n\n\n\n\nInvoke the middleware functions serially.\n\n\n  dispatch: (args..., fn) ->\n    self = this\n\n    index = 0\n\n    invoke = (error) ->\n\n      self.emit 'invoked', self._middleware[index - 1] if index > 0\n\n\n\n\nCall \nfn\n with any error if we're done.\n\n\n      if index is self._middleware.length\n\n\n\n\nIgnore any final error, as we don't want it to cascade back up the\nrecursive invocation path.\n\n\n        try\n          return fn error\n        catch error\n\n      current = self._middleware[index++]\n\n\n\n\nError-handling middleware.\n\n\n      if current.length is args.length + 2\n\n\n\n\nAn error occurred previously.\n\n\n        if error?\n\n\n\n\nTry to invoke the middleware, if it throws, just catch the error\nand pass it along.\n\n\n          try\n            localArgs = args.concat()\n            localArgs.unshift error\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error\n\n\n\n\nNo previous error; skip this middleware.\n\n\n        else\n\n          invoke error\n\n\n\n\nNon-error-handling middleware.\n\n\n      else\n\n\n\n\nAn error occurred previously, skip this middleware.\n\n\n        if error?\n\n          invoke error\n\n\n\n\nNo previous error.\n\n\n        else\n\n\n\n\nTry to invoke the middleware, if it throws, just catch the error\nand pass it along.\n\n\n          try\n            localArgs = args.concat()\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error\n\n\n\n\nKick things off.\n\n\n    invoke()\n\n\n\n\nmiddleware.fromHook\n\n\nCreate a middleware stack from the results of a hook and path\nconfiguration.\n\n\nexports.fromHook = (hook, paths, args...) ->\n\n  debugSilly = require('debug') 'truss-silly:middleware'\n\n  middleware = new Middleware()\n\n\n\n\nInvoke the hook and \nuse\n the middleware in the paths configuration order.\n\n\n  args.unshift hook\n  hookResults = pkgman.invoke args...\n  for path in paths ? []\n    continue unless (spec = hookResults[path])?\n\n    debugSilly \"- - #{spec.label}\"\n\n    middleware.use fn for fn in spec.middleware ? []\n\n  middleware\n\n\n\n\nmiddleware.fromConfig\n\n\nCreate a middleware stack from a configuration path.\n\n\nexports.fromConfig = (path, args...) ->\n\n  exports.fromHook(\n    pkgman.normalizePath path\n    config.get \"packageConfig:#{path}\"\n  )",
            "title": "middleware.coffee"
        },
        {
            "location": "/source/src/middleware/#abstract-middleware-stacks",
            "text": "{EventEmitter} = require 'events'\n\nconfig = require 'config'\npkgman = require 'pkgman'  Implements a middleware stack. Middleware functions can be added to the\nstack with  use . Calling  dispatch  invokes the middleware functions\nserially.",
            "title": "Abstract middleware stacks"
        },
        {
            "location": "/source/src/middleware/#defining-middleware",
            "text": "Each middleware accepts an arbitrary parameters and finally a  next \nfunction. When a middleware finishes, it must call the  next  function.\nIf there was an error, it must be thrown or passed as the first argument to next . If no error occurred,  next  must be invoked without arguments.\nError-handling middleware can also be defined. These middleware take an\nadditional parameter at the beginning of the function signature:  error .\nError-handling middleware are only called if a previous middleware threw\nor passed an error. Conversely, non-error-handling middleware are skipped\nif a previous error occurred.  exports.Middleware = class Middleware extends EventEmitter",
            "title": "Defining middleware"
        },
        {
            "location": "/source/src/middleware/#constructor",
            "text": "Create a middleware stack.    constructor: -> @_middleware = []",
            "title": "constructor"
        },
        {
            "location": "/source/src/middleware/#middlwareuse",
            "text": "(function)  fn  - A middleware function.   Add a middleware function to the stack.    use: (fn) -> @_middleware.push fn",
            "title": "Middlware#use"
        },
        {
            "location": "/source/src/middleware/#middlewaredispatch",
            "text": "(mixed)  ...  - Zero or more values to pass to the middleware.    (function)  fn  - A function invoked when the middleware stack has\nfinished. If an error occurred, it will be passed as the first argument.    Invoke the middleware functions serially.    dispatch: (args..., fn) ->\n    self = this\n\n    index = 0\n\n    invoke = (error) ->\n\n      self.emit 'invoked', self._middleware[index - 1] if index > 0  Call  fn  with any error if we're done.        if index is self._middleware.length  Ignore any final error, as we don't want it to cascade back up the\nrecursive invocation path.          try\n          return fn error\n        catch error\n\n      current = self._middleware[index++]  Error-handling middleware.        if current.length is args.length + 2  An error occurred previously.          if error?  Try to invoke the middleware, if it throws, just catch the error\nand pass it along.            try\n            localArgs = args.concat()\n            localArgs.unshift error\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error  No previous error; skip this middleware.          else\n\n          invoke error  Non-error-handling middleware.        else  An error occurred previously, skip this middleware.          if error?\n\n          invoke error  No previous error.          else  Try to invoke the middleware, if it throws, just catch the error\nand pass it along.            try\n            localArgs = args.concat()\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error  Kick things off.      invoke()",
            "title": "Middleware#dispatch"
        },
        {
            "location": "/source/src/middleware/#middlewarefromhook",
            "text": "Create a middleware stack from the results of a hook and path\nconfiguration.  exports.fromHook = (hook, paths, args...) ->\n\n  debugSilly = require('debug') 'truss-silly:middleware'\n\n  middleware = new Middleware()  Invoke the hook and  use  the middleware in the paths configuration order.    args.unshift hook\n  hookResults = pkgman.invoke args...\n  for path in paths ? []\n    continue unless (spec = hookResults[path])?\n\n    debugSilly \"- - #{spec.label}\"\n\n    middleware.use fn for fn in spec.middleware ? []\n\n  middleware",
            "title": "middleware.fromHook"
        },
        {
            "location": "/source/src/middleware/#middlewarefromconfig",
            "text": "Create a middleware stack from a configuration path.  exports.fromConfig = (path, args...) ->\n\n  exports.fromHook(\n    pkgman.normalizePath path\n    config.get \"packageConfig:#{path}\"\n  )",
            "title": "middleware.fromConfig"
        },
        {
            "location": "/source/src/pkgman/",
            "text": "Package manager\n\n\nRegisters packages and handles hook registration and invocation as well as\nintrospection.\n\n\ndebug = require('debug') 'truss:pkgman'\ndebugSilly = require('debug') 'truss-silly:pkgman'\n\n\n\n\nIndex by hook and path for faster invocation and introspection.\n\n\nhookIndex = {}\npathIndex = {}\n\n\n\n\nA list of registered packages.\n\n\n_packages = []\n\n\n\n\nRegistrar object passed to packages to allow them to register hooks and/or\nrecur into their own subpackages to allow them to.\n\n\nclass PkgmanRegistrar\n\n\n\n\nconstructor\n\n\nInstantiate the registrar with the current (sub)package path.\n\n\n  constructor: (@_path) ->\n\n\n\n\nPkgmanRegistrar#path\n\n\nGet the current (sub) package path.\n\n\n  path: -> @_path\n\n\n\n\nPkgmanRegistrar#recur\n\n\n\n\n(string array) \npaths\n - The list of submodule paths to register.\n\n\n\n\nRecur into subpackages to register them and allow them to register hooks\nand/or recur further.\n\n\n  recur: (paths) ->\n\n    for path in paths\n\n      subpath = \"#{@_path}/#{path}\"\n\n      debugSilly \"Requiring #{subpath}\"\n      submodule = require subpath\n      debugSilly \"Required #{subpath}\"\n\n      debugSilly \"Registering hooks for #{subpath}\"\n      submodule.pkgmanRegister? new PkgmanRegistrar subpath\n      debugSilly \"Registered hooks for #{subpath}\"\n\n    return\n\n\n\n\nPkgmanRegistrar#registerHook\n\n\n\n\n\n\n(optional string) \nsubmodule\n - Register this hook under a submodule.\nThis is a convenience for when you might need to register more than one\nimplementation of a hook, bur prefer to keep both implementations in the\nsame physical file.\n\n\n\n\n\n\n(string) \nhook\n - The name of the hook to register.\n\n\n\n\n\n\n(function) \nimpl\n - The hook implementation function. This is invoked\nwhen the hook is invoked. The signature of the implementation function may\nvary, consult the documentation for the specific hook to learn more.\n\n\n\n\n\n\nRegister a hook implementation.\n\n\n  registerHook: (submodule, hook, impl) ->\n\n\n\n\nIf \nsubmodule\n was passed in, modify the path this hook is registered\nagainst.\n\n\n    if impl?\n\n      path = \"#{@_path}/#{submodule}\"\n\n\n\n\nOtherwise, fix up the args.\n\n\n    else\n\n      path = @_path\n      impl = hook\n      hook = submodule\n\n\n\n\nPopulate the indexes with the registered hook.\n\n\n    debugSilly \"Registering hook #{hook}\"\n\n    (hookIndex[hook] ?= []).push path\n    (pathIndex[path] ?= {})[hook] = impl\n\n    debugSilly \"Registered hook #{hook}\"\n\n\n\n\npkgman.rebuildPackageCache\n\n\nRebuild the package cache.\n\n\nDo not invoke this unless you are absolutely sure you know what you're\ndoing.\n\n\nexports.rebuildPackageCache = ->\n  modules = {}\n  hookIndex = {}\n  pathIndex = {}\n\n  for name in _packages\n\n\n\n\nTry to require the package module.\n\n\n    try\n\n      debugSilly \"Requiring package #{name}\"\n\n      module_ = require name\n\n    catch error\n\n\n\n\nSuppress missing package errors.\n\n\n      if error.toString() is \"Error: Cannot find module '#{name}'\"\n        debug \"Missing package #{name}.\"\n        continue\n\n      throw error\n\n    debugSilly \"Required package #{name}\"\n\n    modules[name] = module_\n\n\n\n\nRegister hooks.\n\n\n  for path, module_ of modules\n\n    debugSilly \"Registering hooks for #{path}\"\n    module_.pkgmanRegister? new PkgmanRegistrar path\n    debugSilly \"Registered hooks for #{path}\"\n\n  return\n\n\n\n\npkgman.registerPackageList\n\n\n\n\n(string array) \npackages\n - The list of packages to register.\n\n\n\n\nRegister a list of packages.\n\n\nexports.registerPackageList = (packages) ->\n  _packages.push.apply _packages, packages\n  exports.rebuildPackageCache()\n\n\n\n\npkgman.invoke\n\n\n\n\n\n\n(string) \nhook\n - The name of the hook to invoke.\n\n\n\n\n\n\n(args...) \nargs\n - Arguments to pass along to implementations of the hook.\n\n\n\n\n\n\nInvoke a hook with arguments. Return the result as an object, keyed by\npackage path.\n\n\nexports.invoke = (hook, args...) ->\n\n  results = {}\n\n  for path in exports.packagesImplementing hook\n    results[path] = exports.invokePackage path, hook, args...\n\n  return results\n\n\n\n\npkgman.invokeFlat\n\n\n\n\n\n\n(string) \nhook\n - The name of the hook to invoke.\n\n\n\n\n\n\n(args...) \nargs\n - Arguments to pass along to implementations of the hook.\n\n\n\n\n\n\nInvoke a hook with arguments. Return the result as an array.\n\n\nexports.invokeFlat = (hook, args...) ->\n\n  for path in exports.packagesImplementing hook\n    exports.invokePackage path, hook, args...\n\n\n\n\npkgman.invokePackage\n\n\n\n\n\n\n(string) \npath\n - The path of the package whose implementation we're\ninvoking.\n\n\n\n\n\n\n(string) \nhook\n - The name of the hook to invoke.\n\n\n\n\n\n\n(args...) \nargs\n - Arguments to pass along to the hook implementation.\n\n\n\n\n\n\nInvoke a package's implementation of a hook with arguments. Return the\nresult.\n\n\nexports.invokePackage = (path, hook, args...) ->\n  pathIndex?[path]?[hook]? args...\n\n\n\n\npkgman.packageExists\n\n\n\n\n(string) \nname\n - The name of the package to check.\n\n\n\n\nCheck whether a package exists.\n\n\nexports.packageExists = (name) -> -1 isnt _packages.indexOf name\n\n\n\n\npkgman.packagesImplementing\n\n\n\n\n(string) \nhook\n - The hook to check.\n\n\n\n\nReturn a list of packages implementing the hook.\n\n\nexports.packagesImplementing = (hook) -> hookIndex?[hook] ? []\n\n\n\n\npkgman.normalizePath\n\n\n\n\n\n\n(string) \npath\n - The path to normalize.\n\n\n\n\n\n\n(Boolean) \ncapitalize\n - Whether to capitalize the first letter.\n\n\n\n\n\n\nConverts a package path (e.g. \ntruss-dox/dynamic\n) to a normalized path\n(e.g. \ntrussDoxDynamic\n).\n\n\nexports.normalizePath = (path, capitalize = false) ->\n\n  i8n = require 'inflection'\n\n  parts = for part, i in path.split '/'\n    i8n.camelize i8n.underscore(\n      part.replace /[^\\w]/g, '_'\n      0 is i\n    )\n\n  i8n.camelize (i8n.underscore parts.join ''), not capitalize",
            "title": "pkgman.coffee"
        },
        {
            "location": "/source/src/pkgman/#package-manager",
            "text": "Registers packages and handles hook registration and invocation as well as\nintrospection.  debug = require('debug') 'truss:pkgman'\ndebugSilly = require('debug') 'truss-silly:pkgman'  Index by hook and path for faster invocation and introspection.  hookIndex = {}\npathIndex = {}  A list of registered packages.  _packages = []  Registrar object passed to packages to allow them to register hooks and/or\nrecur into their own subpackages to allow them to.  class PkgmanRegistrar",
            "title": "Package manager"
        },
        {
            "location": "/source/src/pkgman/#constructor",
            "text": "Instantiate the registrar with the current (sub)package path.    constructor: (@_path) ->",
            "title": "constructor"
        },
        {
            "location": "/source/src/pkgman/#pkgmanregistrarpath",
            "text": "Get the current (sub) package path.    path: -> @_path",
            "title": "PkgmanRegistrar#path"
        },
        {
            "location": "/source/src/pkgman/#pkgmanregistrarrecur",
            "text": "(string array)  paths  - The list of submodule paths to register.   Recur into subpackages to register them and allow them to register hooks\nand/or recur further.    recur: (paths) ->\n\n    for path in paths\n\n      subpath = \"#{@_path}/#{path}\"\n\n      debugSilly \"Requiring #{subpath}\"\n      submodule = require subpath\n      debugSilly \"Required #{subpath}\"\n\n      debugSilly \"Registering hooks for #{subpath}\"\n      submodule.pkgmanRegister? new PkgmanRegistrar subpath\n      debugSilly \"Registered hooks for #{subpath}\"\n\n    return",
            "title": "PkgmanRegistrar#recur"
        },
        {
            "location": "/source/src/pkgman/#pkgmanregistrarregisterhook",
            "text": "(optional string)  submodule  - Register this hook under a submodule.\nThis is a convenience for when you might need to register more than one\nimplementation of a hook, bur prefer to keep both implementations in the\nsame physical file.    (string)  hook  - The name of the hook to register.    (function)  impl  - The hook implementation function. This is invoked\nwhen the hook is invoked. The signature of the implementation function may\nvary, consult the documentation for the specific hook to learn more.    Register a hook implementation.    registerHook: (submodule, hook, impl) ->  If  submodule  was passed in, modify the path this hook is registered\nagainst.      if impl?\n\n      path = \"#{@_path}/#{submodule}\"  Otherwise, fix up the args.      else\n\n      path = @_path\n      impl = hook\n      hook = submodule  Populate the indexes with the registered hook.      debugSilly \"Registering hook #{hook}\"\n\n    (hookIndex[hook] ?= []).push path\n    (pathIndex[path] ?= {})[hook] = impl\n\n    debugSilly \"Registered hook #{hook}\"",
            "title": "PkgmanRegistrar#registerHook"
        },
        {
            "location": "/source/src/pkgman/#pkgmanrebuildpackagecache",
            "text": "Rebuild the package cache.  Do not invoke this unless you are absolutely sure you know what you're\ndoing.  exports.rebuildPackageCache = ->\n  modules = {}\n  hookIndex = {}\n  pathIndex = {}\n\n  for name in _packages  Try to require the package module.      try\n\n      debugSilly \"Requiring package #{name}\"\n\n      module_ = require name\n\n    catch error  Suppress missing package errors.        if error.toString() is \"Error: Cannot find module '#{name}'\"\n        debug \"Missing package #{name}.\"\n        continue\n\n      throw error\n\n    debugSilly \"Required package #{name}\"\n\n    modules[name] = module_  Register hooks.    for path, module_ of modules\n\n    debugSilly \"Registering hooks for #{path}\"\n    module_.pkgmanRegister? new PkgmanRegistrar path\n    debugSilly \"Registered hooks for #{path}\"\n\n  return",
            "title": "pkgman.rebuildPackageCache"
        },
        {
            "location": "/source/src/pkgman/#pkgmanregisterpackagelist",
            "text": "(string array)  packages  - The list of packages to register.   Register a list of packages.  exports.registerPackageList = (packages) ->\n  _packages.push.apply _packages, packages\n  exports.rebuildPackageCache()",
            "title": "pkgman.registerPackageList"
        },
        {
            "location": "/source/src/pkgman/#pkgmaninvoke",
            "text": "(string)  hook  - The name of the hook to invoke.    (args...)  args  - Arguments to pass along to implementations of the hook.    Invoke a hook with arguments. Return the result as an object, keyed by\npackage path.  exports.invoke = (hook, args...) ->\n\n  results = {}\n\n  for path in exports.packagesImplementing hook\n    results[path] = exports.invokePackage path, hook, args...\n\n  return results",
            "title": "pkgman.invoke"
        },
        {
            "location": "/source/src/pkgman/#pkgmaninvokeflat",
            "text": "(string)  hook  - The name of the hook to invoke.    (args...)  args  - Arguments to pass along to implementations of the hook.    Invoke a hook with arguments. Return the result as an array.  exports.invokeFlat = (hook, args...) ->\n\n  for path in exports.packagesImplementing hook\n    exports.invokePackage path, hook, args...",
            "title": "pkgman.invokeFlat"
        },
        {
            "location": "/source/src/pkgman/#pkgmaninvokepackage",
            "text": "(string)  path  - The path of the package whose implementation we're\ninvoking.    (string)  hook  - The name of the hook to invoke.    (args...)  args  - Arguments to pass along to the hook implementation.    Invoke a package's implementation of a hook with arguments. Return the\nresult.  exports.invokePackage = (path, hook, args...) ->\n  pathIndex?[path]?[hook]? args...",
            "title": "pkgman.invokePackage"
        },
        {
            "location": "/source/src/pkgman/#pkgmanpackageexists",
            "text": "(string)  name  - The name of the package to check.   Check whether a package exists.  exports.packageExists = (name) -> -1 isnt _packages.indexOf name",
            "title": "pkgman.packageExists"
        },
        {
            "location": "/source/src/pkgman/#pkgmanpackagesimplementing",
            "text": "(string)  hook  - The hook to check.   Return a list of packages implementing the hook.  exports.packagesImplementing = (hook) -> hookIndex?[hook] ? []",
            "title": "pkgman.packagesImplementing"
        },
        {
            "location": "/source/src/pkgman/#pkgmannormalizepath",
            "text": "(string)  path  - The path to normalize.    (Boolean)  capitalize  - Whether to capitalize the first letter.    Converts a package path (e.g.  truss-dox/dynamic ) to a normalized path\n(e.g.  trussDoxDynamic ).  exports.normalizePath = (path, capitalize = false) ->\n\n  i8n = require 'inflection'\n\n  parts = for part, i in path.split '/'\n    i8n.camelize i8n.underscore(\n      part.replace /[^\\w]/g, '_'\n      0 is i\n    )\n\n  i8n.camelize (i8n.underscore parts.join ''), not capitalize",
            "title": "pkgman.normalizePath"
        }
    ]
}