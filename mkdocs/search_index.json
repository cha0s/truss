{
    "docs": [
        {
            "location": "/",
            "text": "Truss\n\n\nHi, what are you?\n\n\nTruss is an opinionated JavaScript application framework. It is\norganized into \npackages\n which implement\n\nhooks\n, as a means of communicating between each other and\ninfluencing the way the application behaves.\n\n\nHi, why are you?\n\n\nThe intention of Truss is to lay the foundation allowing you to build rich,\npowerful applications in an elegant and structured way; without needing to\nhack on or change the core codebase. Everything you need should be doable by\ncreating a new package. If you find the opposite to be true, feel free to\n\nopen an issue\n!\n\n\nHi, how dare you?\n\n\n[[Insert deepest condolences for lack of/incomprehensible/otherwise wanting\ndocumentation with vague reassurance that it will someday not be the\ncase \nHERE\n]]\n\n\nTODO\n\n\nSee the \nTODO list\n.",
            "title": "README"
        },
        {
            "location": "/#truss",
            "text": "Hi, what are you?  Truss is an opinionated JavaScript application framework. It is\norganized into  packages  which implement hooks , as a means of communicating between each other and\ninfluencing the way the application behaves.  Hi, why are you?  The intention of Truss is to lay the foundation allowing you to build rich,\npowerful applications in an elegant and structured way; without needing to\nhack on or change the core codebase. Everything you need should be doable by\ncreating a new package. If you find the opposite to be true, feel free to open an issue !  Hi, how dare you?  [[Insert deepest condolences for lack of/incomprehensible/otherwise wanting\ndocumentation with vague reassurance that it will someday not be the\ncase  HERE ]]  TODO  See the  TODO list .",
            "title": "Truss"
        },
        {
            "location": "/guide/errors/",
            "text": "Error handling\n\n\n\nTruss provides a mechanism to define errors that can be transmitted over the\nwire.\n\n\nThis is accomplished by subclassing\n\nTransmittableError\n.\nLet's look at an example.\n\n\nDefine an error\n\n\nSay we'd like to implement an error saying that one user can't add another\nuser as a friend. We might implement that like so:\n\n\nvar TransmittableError = require('errors').TransmittableError;\n\nfunction FriendRequestError(message, addingUserName, addedUserName) {\n  TransmittableError.apply(this, arguments);\n\n  this.addingUserName = addingUserName;\n  this.addedUserName = addedUserName;\n}\n\nFriendRequestError.prototype = new TransmittableError();\nFriendRequestError.prototype.key = 'friendRequest';\nFriendRequestError.prototype.template = ':message :addingUserName cannot add :addedUserName as a friend!';\nFriendRequestError.prototype.toJSON = function() {\n  return {\n    key: this.key,\n    message: this.message,\n    addingUserName: this.addingUserName,\n    addedUserName: this.addedUserName\n  };\n};\n\n\n\n\nWe now have our friend request error! You'll want to return it (in an array)\nfrom your package's implementation of\n\ntrussTransmittableErrors\n.\n\n\nInstantiate an error\n\n\nYou can instantiate one of these errors:\n\n\nvar errors = require('errors');\nvar error = errors.instantiate('friendRequest', 'Friend request error!', 'Alice', 'Bob');\n\n\n\n\nNotice the arguments to \nerrors.instantiate\n are first the key, followed by\nthe arguments defined by your subclass constructor.\n\n\nRender a formatted error\n\n\nTo see the error output you could do something like:\n\n\nvar errors = require('errors');\nconsole.error(errors.message(error));\n\n\n\n\nwhich would output:\n\n\nFriend request error! Alice cannot add Bob as a friend!\n\n\n\n\nYou might be wondering, why is the 'message' formatting function on \nerrors\n\ninstead of on \nTransmittableError::prototype\n? The reason is because\n\nerrors.message\n is designed to work not only if you pass it an instance of\n\nTransmittableError\n, but also instances of \nError\n, as well as primitive\ntypes.\n\n\nRender an error stack\n\n\nYou can view the stack of any error in a similar way:\n\n\nvar errors = require('errors');\nconsole.error(errors.stack(error));",
            "title": "Error handling"
        },
        {
            "location": "/guide/errors/#define-an-error",
            "text": "Say we'd like to implement an error saying that one user can't add another\nuser as a friend. We might implement that like so:  var TransmittableError = require('errors').TransmittableError;\n\nfunction FriendRequestError(message, addingUserName, addedUserName) {\n  TransmittableError.apply(this, arguments);\n\n  this.addingUserName = addingUserName;\n  this.addedUserName = addedUserName;\n}\n\nFriendRequestError.prototype = new TransmittableError();\nFriendRequestError.prototype.key = 'friendRequest';\nFriendRequestError.prototype.template = ':message :addingUserName cannot add :addedUserName as a friend!';\nFriendRequestError.prototype.toJSON = function() {\n  return {\n    key: this.key,\n    message: this.message,\n    addingUserName: this.addingUserName,\n    addedUserName: this.addedUserName\n  };\n};  We now have our friend request error! You'll want to return it (in an array)\nfrom your package's implementation of trussTransmittableErrors .",
            "title": "Define an error"
        },
        {
            "location": "/guide/errors/#instantiate-an-error",
            "text": "You can instantiate one of these errors:  var errors = require('errors');\nvar error = errors.instantiate('friendRequest', 'Friend request error!', 'Alice', 'Bob');  Notice the arguments to  errors.instantiate  are first the key, followed by\nthe arguments defined by your subclass constructor.",
            "title": "Instantiate an error"
        },
        {
            "location": "/guide/errors/#render-a-formatted-error",
            "text": "To see the error output you could do something like:  var errors = require('errors');\nconsole.error(errors.message(error));  which would output:  Friend request error! Alice cannot add Bob as a friend!  You might be wondering, why is the 'message' formatting function on  errors \ninstead of on  TransmittableError::prototype ? The reason is because errors.message  is designed to work not only if you pass it an instance of TransmittableError , but also instances of  Error , as well as primitive\ntypes.",
            "title": "Render a formatted error"
        },
        {
            "location": "/guide/errors/#render-an-error-stack",
            "text": "You can view the stack of any error in a similar way:  var errors = require('errors');\nconsole.error(errors.stack(error));",
            "title": "Render an error stack"
        },
        {
            "location": "/guide/packages/",
            "text": "Package system\n\n\n\nTruss is organized into packages which implement hooks.\n\n\nA package is essentially a node.js module. Exporting a \npkgmanRegister\n\nfunction allows Truss to register your package in its package manager. This is\nhow you can implement hooks, allowing you to augment, modify, and even define\nyour application's behavior.\n\n\nThe simplest example of a package would be something like:\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('trussServerPreBootstrap', function() {\n    console.log('I hooked into Truss!');\n  });\n};\n\n\n\n\nThis package simply hooks into the\n\ntrussServerPreBootstrap\n hook and logs\na message to the console when that hook is invoked. Obviously this particular\npackage isn't super useful!\n\n\nHooks are how Truss allows packages to implement (or invoke) dynamic behavior.\nHooks can also serve as a form of message passing between packages.\n\n\nTo implement a hook, export a \npkgmanRegister\n method which takes a \nregistrar\n\nargument, and use the registrar to register your hook:\n\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('someHook', function() {\n    doStuff();\n  });\n\n  registrar.registerHook('someOtherHook', function(arg) {\n    doOtherStuffWith(arg);\n  });\n};\n\n\n\n\nTo invoke a hook, require \npkgman\n and use the \ninvoke\n method:\n\n\nvar pkgman = require('pkgman');\n\nvar results = pkgman.invoke('someOtherHook', arg);\n\n\n\n\nAny arguments following the hook name will be passed along to the\nimplementations. Hooks are invoked synchronously. For more information about\n\npkgman\n, see \nthe pkgman documentation\n.",
            "title": "Package system"
        },
        {
            "location": "/guide/concepts/",
            "text": "This page explains various concepts and conventions used in Truss.\n\n\nMiddleware hook specification\n\n\nTruss invokes various hooks\n(\ntrussServerBootstrapMiddleware\n,\nand more...) which allow packages to define middleware to be dispatched during\nvarious processes.\n\n\nMiddleware hooks return a specification that looks like:\n\n\n{\n  label: 'What the middleware functions do',\n  middleware: [\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    },\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    }\n  ]\n}\n\n\n\n\nThe \nlabel\n exists only to provide debugging information so you can see if any\nof your middleware are having problems by checking the debug console logs.\n\n\nThe \nmiddleware\n are applied serially, meaning the first function in the array\nis dispatched first, followed by the second, etc.\n\n\nSee the\n\nmiddleware module\n\nfor even more information about defining middleware.",
            "title": "Concepts and conventions"
        },
        {
            "location": "/guide/concepts/#middleware-hook-specification",
            "text": "Truss invokes various hooks\n( trussServerBootstrapMiddleware ,\nand more...) which allow packages to define middleware to be dispatched during\nvarious processes.  Middleware hooks return a specification that looks like:  {\n  label: 'What the middleware functions do',\n  middleware: [\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    },\n\n    function(args..., next) {\n\n      // Do stuff with args...\n      next();\n    }\n  ]\n}  The  label  exists only to provide debugging information so you can see if any\nof your middleware are having problems by checking the debug console logs.  The  middleware  are applied serially, meaning the first function in the array\nis dispatched first, followed by the second, etc.  See the middleware module \nfor even more information about defining middleware.",
            "title": "Middleware hook specification"
        },
        {
            "location": "/hooks/",
            "text": "Hook reference\n\n\n\ntrussServerPackageConfig\n\n\nDefine server-side configuration settings.\n\n\nPackages may use this hook to define default configuration for server-side\nfunctionality. These settings can be overridden in the settings file.\n\n\nImplementations must return\n\n\n\nA recursive object which will be folded into the server configuration under\nthe package name key. For instance, say we have a package \nmy-package\n which\ndefines the hook like:\n\n\nregistrar.registerHook('trussConfigServer', function() {\n  return {\n    one: 68,\n    two: {\n      three: 419\n    }\n  };\n});\n\n\n\n\nYou would then find those values in the configuration at:\n\n\nconfig.get('packageSettings:my-package:one');\nconfig.get('packageSettings:my-package:two:three');\n\n\n\n\nSee \nthe default configuration file\n for\nan example of how settings may be overridden. This should always be preferred\nto actually changing the code in a given package's hook.\n\n\n\n  \n3 implementations\n\n  \n\n    \n\n      \n\n        \npackages/truss-frontend/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \npackages/truss-http/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \npackages/truss-repl/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \n2 invocations\n\n  \n\n    \n\n      \n\n        \nGruntfile.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n    \n\n      \n\n        \nsrc/main.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussServerGruntConfig\n\n\nHook into the Grunt build process.\n\n\nThis hook allows packages to define Grunt tasks, configure existing tasks, and\nload NPM tasks. This is achieved through the first implementation parameter\nwhich is an instance of the class\n\nGruntConfiguration\n. The\n\ngrunt\n object is passed in through the second parameter in case it's needed.\n\n\nOne of the most common uses of this hook is to copy any asset files your\npackage may include to the \napp\n directory, where they can be served to\nclients.\n\n\n\n  \n2 implementations\n\n  \n\n    \n\n      \n\n        \npackages/truss-dox/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \npackages/truss-frontend/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \nGruntfile.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussServerGruntConfigAlter\n\n\nAlter the Grunt build process.\n\n\nThis hook allows packages to alter Grunt configuration specified through\n\ntrussServerGruntConfig\n.\n\n\nThe first implementation parameter is an instance of the class\n\nGruntConfiguration\n. The \ngrunt\n\nobject is passed in through the second parameter in case it's needed.\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \nGruntfile.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussDoxSources\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \npackages/truss-dox/dynamic/index.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussDoxSourceMarkdownTransform\n\n\n\n  \n1 implementation\n\n  \n\n    \n\n      \n\n        \npackages/truss-dox/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \npackages/truss-dox/dynamic/processor/sources-to-markdown.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussFrontendAssetsMiddleware\n\n\n\n  \n1 implementation\n\n  \n\n    \n\n      \n\n        \npackages/truss-frontend/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \npackages/truss-frontend/index.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussHttpServerRequestMiddleware\n\n\nDefine middleware to run for every HTTP request.\n\n\nThe \nreq\n parameter to the middleware is an instance of\n\nhttp.IncomingMessage\n\nfrom the HTTP request.\n\n\nThe \nres\n parameter to the middleware is an instance of\n\nhttp.ServerResponse\n\nfrom the HTTP request.\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(req, res, next) {\n  ...\n}\n\n\n\n\n\n  \n3 implementations\n\n  \n\n    \n\n      \n\n        \npackages/truss-frontend/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \npackages/truss-http/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \npackages/truss-http/stub/router.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \npackages/truss-http/abstract.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussHttpServerRoutes\n\n\nDefine HTTP routes.\n\n\nPackages use this hook to define HTTP routes.\n\n\nImplementations must return\n\n\n\nAn array of objects structured like:\n\n\n\n\n(String) \npath\n - The HTTP path of the route. Include the leading slash.\n\n\n(String) \nverb\n - The HTTP verb to associate with this route. Defaults to\n  \n'get'\n.\n\n\n(Function) \nreceiver\n - The function invoked when the route is hit. Takes\n  three parameters:\n\n\n(http.IncomingMessage) \nreq\n - The request object.\n\n\n(http.ServerResponse) \nres\n - The response object.\n\n\n(Function) \nfn\n - A nodeback called when the route is complete.\n\n\n\n\n\n\n\n\n\n  \n1 implementation\n\n  \n\n    \n\n      \n\n        \npackages/truss-frontend/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \npackages/truss-http/index.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussReplServerContext\n\n\nAdd to the REPL context.\n\n\nPackages may use this hook to provide access to parts of their state to the\nREPL context.\n\n\nImplementations accept the following arguments:\n\n\n\n\n(Object) \ncontext\n - The context object.\n\n\n\n\nTo set context variables, simply set them on the context object.\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \npackages/truss-repl/index.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussServerProcessExit\n\n\nFinal cleanups as the process is exiting.\n\n\nThe application tries its hardest to always invoke this hook, even in the\nevent of a raised signal or unhandled exception.\n\n\nYou should not schedule asynchronous events, as they are not guaranteed to be\ndispatched. See\n\nthe Node.js documentation\n\nfor more information.\n\n\n\n  \n1 implementation\n\n  \n\n    \n\n      \n\n        \npackages/truss-repl/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \nserver.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussTransmittableErrors\n\n\nDefine errors that can be transmitted easily over the wire.\n\n\nSee \nthe documentation on errors\n for more information.\n\n\nImplementations must return\n\n\n\nAn array of subclasses of\n\nTransmittableError\n.\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \nsrc/errors.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussServerPreBootstrap\n\n\nInvoked before the application bootstrap phase.\n\n\nMitigate slow build times\n\n\n\nIf your package \nrequire\ns heavy modules, you should require them in an\nimplementation of hook \ntrussServerPreBootstrap\n. For instance, say you have a\npackage like:\n\n\nvar someHeavyModule = require('some-heavy-module');\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};\n\n\n\n\nThis will slow the build process down, since \nsome-heavy-module\n must be\nloaded when loading your package. Use this pattern instead:\n\n\nvar someHeavyModule = null;\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('trussServerPreBootstrap', function() {\n    someHeavyModule = require('some-heavy-module');\n  });\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};\n\n\n\n\nSo that the heavy module will not be \nrequire\nd until hook\n\ntrussServerPreBootstrap\n is invoked.\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \nsrc/main.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussServerBootstrapMiddleware\n\n\nDefine middleware to run when the server application is bootstrapping.\n\n\nThis hook is where most of the major initialization work happens on the\nserver. You use this to spin up HTTP/sockets/database/whatever.\n\n\nImplementations must return\n\n\n\nA\n\nmiddleware hook specification\n.\nThe middleware have the following signature:\n\n\nfunction(next) {\n  ...\n}\n\n\n\n\n\n  \n2 implementations\n\n  \n\n    \n\n      \n\n        \npackages/truss-http/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \npackages/truss-repl/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \n1 invocation\n\n  \n\n    \n\n      \n\n        \nsrc/main.coffee\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussDoxSourceList\n\n\n\n  \n1 implementation\n\n  \n\n    \n\n      \n\n        \npackages/truss-dox/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussFrontendPackageTasks\n\n\n\n  \n1 implementation\n\n  \n\n    \n\n      \n\n        \npackages/truss-frontend/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussFrontendPackageConfig\n\n\n\n  \n1 implementation\n\n  \n\n    \n\n      \n\n        \npackages/truss-frontend/index.coffee\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\ntrussFrontendPackageList\n\n\n\n  \n1 implementation\n\n  \n\n    \n\n      \n\n        \npackages/truss-frontend/index.coffee\n\n      \n\n      \n\n        \nimplementation",
            "title": "Hooks"
        },
        {
            "location": "/hooks/#trussserverpackageconfig",
            "text": "Define server-side configuration settings.  Packages may use this hook to define default configuration for server-side\nfunctionality. These settings can be overridden in the settings file.  Implementations must return  A recursive object which will be folded into the server configuration under\nthe package name key. For instance, say we have a package  my-package  which\ndefines the hook like:  registrar.registerHook('trussConfigServer', function() {\n  return {\n    one: 68,\n    two: {\n      three: 419\n    }\n  };\n});  You would then find those values in the configuration at:  config.get('packageSettings:my-package:one');\nconfig.get('packageSettings:my-package:two:three');  See  the default configuration file  for\nan example of how settings may be overridden. This should always be preferred\nto actually changing the code in a given package's hook.  \n   3 implementations \n   \n     \n       \n         packages/truss-frontend/index.coffee \n       \n       \n         implementation \n       \n     \n     \n       \n         packages/truss-http/index.coffee \n       \n       \n         implementation \n       \n     \n     \n       \n         packages/truss-repl/index.coffee \n       \n       \n         implementation \n       \n     \n     \n   2 invocations \n   \n     \n       \n         Gruntfile.coffee \n       \n       \n         invocation \n       \n     \n     \n       \n         src/main.coffee \n       \n       \n         invocation",
            "title": "trussServerPackageConfig"
        },
        {
            "location": "/hooks/#trussservergruntconfig",
            "text": "Hook into the Grunt build process.  This hook allows packages to define Grunt tasks, configure existing tasks, and\nload NPM tasks. This is achieved through the first implementation parameter\nwhich is an instance of the class GruntConfiguration . The grunt  object is passed in through the second parameter in case it's needed.  One of the most common uses of this hook is to copy any asset files your\npackage may include to the  app  directory, where they can be served to\nclients.  \n   2 implementations \n   \n     \n       \n         packages/truss-dox/index.coffee \n       \n       \n         implementation \n       \n     \n     \n       \n         packages/truss-frontend/index.coffee \n       \n       \n         implementation \n       \n     \n     \n   1 invocation \n   \n     \n       \n         Gruntfile.coffee \n       \n       \n         invocation",
            "title": "trussServerGruntConfig"
        },
        {
            "location": "/hooks/#trussservergruntconfigalter",
            "text": "Alter the Grunt build process.  This hook allows packages to alter Grunt configuration specified through trussServerGruntConfig .  The first implementation parameter is an instance of the class GruntConfiguration . The  grunt \nobject is passed in through the second parameter in case it's needed.  \n   1 invocation \n   \n     \n       \n         Gruntfile.coffee \n       \n       \n         invocation",
            "title": "trussServerGruntConfigAlter"
        },
        {
            "location": "/hooks/#trussdoxsources",
            "text": "1 invocation \n   \n     \n       \n         packages/truss-dox/dynamic/index.coffee \n       \n       \n         invocation",
            "title": "trussDoxSources"
        },
        {
            "location": "/hooks/#trussdoxsourcemarkdowntransform",
            "text": "1 implementation \n   \n     \n       \n         packages/truss-dox/index.coffee \n       \n       \n         implementation \n       \n     \n     \n   1 invocation \n   \n     \n       \n         packages/truss-dox/dynamic/processor/sources-to-markdown.coffee \n       \n       \n         invocation",
            "title": "trussDoxSourceMarkdownTransform"
        },
        {
            "location": "/hooks/#trussfrontendassetsmiddleware",
            "text": "1 implementation \n   \n     \n       \n         packages/truss-frontend/index.coffee \n       \n       \n         implementation \n       \n     \n     \n   1 invocation \n   \n     \n       \n         packages/truss-frontend/index.coffee \n       \n       \n         invocation",
            "title": "trussFrontendAssetsMiddleware"
        },
        {
            "location": "/hooks/#trusshttpserverrequestmiddleware",
            "text": "Define middleware to run for every HTTP request.  The  req  parameter to the middleware is an instance of http.IncomingMessage \nfrom the HTTP request.  The  res  parameter to the middleware is an instance of http.ServerResponse \nfrom the HTTP request.  Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(req, res, next) {\n  ...\n}  \n   3 implementations \n   \n     \n       \n         packages/truss-frontend/index.coffee \n       \n       \n         implementation \n       \n     \n     \n       \n         packages/truss-http/index.coffee \n       \n       \n         implementation \n       \n     \n     \n       \n         packages/truss-http/stub/router.coffee \n       \n       \n         implementation \n       \n     \n     \n   1 invocation \n   \n     \n       \n         packages/truss-http/abstract.coffee \n       \n       \n         invocation",
            "title": "trussHttpServerRequestMiddleware"
        },
        {
            "location": "/hooks/#trusshttpserverroutes",
            "text": "Define HTTP routes.  Packages use this hook to define HTTP routes.  Implementations must return  An array of objects structured like:   (String)  path  - The HTTP path of the route. Include the leading slash.  (String)  verb  - The HTTP verb to associate with this route. Defaults to\n   'get' .  (Function)  receiver  - The function invoked when the route is hit. Takes\n  three parameters:  (http.IncomingMessage)  req  - The request object.  (http.ServerResponse)  res  - The response object.  (Function)  fn  - A nodeback called when the route is complete.     \n   1 implementation \n   \n     \n       \n         packages/truss-frontend/index.coffee \n       \n       \n         implementation \n       \n     \n     \n   1 invocation \n   \n     \n       \n         packages/truss-http/index.coffee \n       \n       \n         invocation",
            "title": "trussHttpServerRoutes"
        },
        {
            "location": "/hooks/#trussreplservercontext",
            "text": "Add to the REPL context.  Packages may use this hook to provide access to parts of their state to the\nREPL context.  Implementations accept the following arguments:   (Object)  context  - The context object.   To set context variables, simply set them on the context object.  \n   1 invocation \n   \n     \n       \n         packages/truss-repl/index.coffee \n       \n       \n         invocation",
            "title": "trussReplServerContext"
        },
        {
            "location": "/hooks/#trussserverprocessexit",
            "text": "Final cleanups as the process is exiting.  The application tries its hardest to always invoke this hook, even in the\nevent of a raised signal or unhandled exception.  You should not schedule asynchronous events, as they are not guaranteed to be\ndispatched. See the Node.js documentation \nfor more information.  \n   1 implementation \n   \n     \n       \n         packages/truss-repl/index.coffee \n       \n       \n         implementation \n       \n     \n     \n   1 invocation \n   \n     \n       \n         server.coffee \n       \n       \n         invocation",
            "title": "trussServerProcessExit"
        },
        {
            "location": "/hooks/#trusstransmittableerrors",
            "text": "Define errors that can be transmitted easily over the wire.  See  the documentation on errors  for more information.  Implementations must return  An array of subclasses of TransmittableError .  \n   1 invocation \n   \n     \n       \n         src/errors.coffee \n       \n       \n         invocation",
            "title": "trussTransmittableErrors"
        },
        {
            "location": "/hooks/#trussserverprebootstrap",
            "text": "Invoked before the application bootstrap phase.  Mitigate slow build times  If your package  require s heavy modules, you should require them in an\nimplementation of hook  trussServerPreBootstrap . For instance, say you have a\npackage like:  var someHeavyModule = require('some-heavy-module');\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};  This will slow the build process down, since  some-heavy-module  must be\nloaded when loading your package. Use this pattern instead:  var someHeavyModule = null;\n\nexports.pkgmanRegister = function(registrar) {\n\n  registrar.registerHook('trussServerPreBootstrap', function() {\n    someHeavyModule = require('some-heavy-module');\n  });\n\n  registrar.registerHook('someHook', function() {\n    someHeavyModule.doSomething();\n  });\n};  So that the heavy module will not be  require d until hook trussServerPreBootstrap  is invoked.  \n   1 invocation \n   \n     \n       \n         src/main.coffee \n       \n       \n         invocation",
            "title": "trussServerPreBootstrap"
        },
        {
            "location": "/hooks/#trussserverbootstrapmiddleware",
            "text": "Define middleware to run when the server application is bootstrapping.  This hook is where most of the major initialization work happens on the\nserver. You use this to spin up HTTP/sockets/database/whatever.  Implementations must return  A middleware hook specification .\nThe middleware have the following signature:  function(next) {\n  ...\n}  \n   2 implementations \n   \n     \n       \n         packages/truss-http/index.coffee \n       \n       \n         implementation \n       \n     \n     \n       \n         packages/truss-repl/index.coffee \n       \n       \n         implementation \n       \n     \n     \n   1 invocation \n   \n     \n       \n         src/main.coffee \n       \n       \n         invocation",
            "title": "trussServerBootstrapMiddleware"
        },
        {
            "location": "/hooks/#trussdoxsourcelist",
            "text": "1 implementation \n   \n     \n       \n         packages/truss-dox/index.coffee \n       \n       \n         implementation",
            "title": "trussDoxSourceList"
        },
        {
            "location": "/hooks/#trussfrontendpackagetasks",
            "text": "1 implementation \n   \n     \n       \n         packages/truss-frontend/index.coffee \n       \n       \n         implementation",
            "title": "trussFrontendPackageTasks"
        },
        {
            "location": "/hooks/#trussfrontendpackageconfig",
            "text": "1 implementation \n   \n     \n       \n         packages/truss-frontend/index.coffee \n       \n       \n         implementation",
            "title": "trussFrontendPackageConfig"
        },
        {
            "location": "/hooks/#trussfrontendpackagelist",
            "text": "1 implementation \n   \n     \n       \n         packages/truss-frontend/index.coffee \n       \n       \n         implementation",
            "title": "trussFrontendPackageList"
        },
        {
            "location": "/packages/",
            "text": "Package reference\n\n\n\nPackages are how Truss organizes functionality.\n\n\nThis page provides a listing of packages in this project, along with a short\ndescription of the functionality they provide.\n\n\ntruss-dox\n \u2022 Documentation\n\n\nBuild the documentation in \ngh-pages\n.\n\n\n\n\n\n\n\n\nFilename\n\n\nTitle\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nindex.coffee\n\n\nDocumentation\n\n\nBuild the documentation in \ngh-pages\n.\n\n\n\n\n\n\ndynamic/index.coffee\n\n\nDynamic documentation\n\n\nGenerate all of the dynamic aspects of the project documentation.\n\n\n\n\n\n\ndynamic/processor/dox-page-hooks.coffee\n\n\nHooks page\n\n\nGenerate the hooks page.\n\n\n\n\n\n\ndynamic/processor/dox-page-mkdocs.coffee\n\n\nmkdocs \"page\"\n\n\nGenerate the mkdocs.yml. Not technically a page, but fits well enough within the abstraction...\n\n\n\n\n\n\ndynamic/processor/dox-page-packages.coffee\n\n\nPackages page\n\n\nGenerate the packages page.\n\n\n\n\n\n\ndynamic/processor/dox-page-todos.coffee\n\n\nTODOs page\n\n\nGenerate the TODOs page.\n\n\n\n\n\n\ndynamic/processor/dox-page.coffee\n\n\nAbstract documentation page\n\n\nAbstract class to process a documentation page, using a template and generated information.\n\n\n\n\n\n\ndynamic/processor/sources-processor.coffee\n\n\nAbstract sources processor\n\n\nAbstract class to process the project sources, usually by transforming them to a new form.\n\n\n\n\n\n\ndynamic/processor/sources-to-markdown.coffee\n\n\nMarkdown source pages\n\n\nImplementation of SourcesProcessor to convert source to markdown for easy reading.\n\n\n\n\n\n\n\n\n\n  \nHook invocations\n\n  \n\n    \n\n      \n\n        \ntrussDoxSourceMarkdownTransform\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussDoxSources\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \nHook implementations\n\n  \n\n    \n\n      \n\n        \ntrussDoxSourceList\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussDoxSourceMarkdownTransform\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussServerGruntConfig\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\ntruss-frontend\n \u2022 Front-end system\n\n\nFront-end abstraction: respond to client, render response, etc.\n\n\n\n\n\n\n\n\nFilename\n\n\nTitle\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nindex.coffee\n\n\nFront-end system\n\n\nFront-end abstraction: respond to client, render response, etc.\n\n\n\n\n\n\nclient/require.coffee\n\n\nRequire system for browser.\n\n\nImplement require in the spirit of NodeJS.\n\n\n\n\n\n\n\n\n\n  \nHook invocations\n\n  \n\n    \n\n      \n\n        \ntrussFrontendAssetsMiddleware\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \nHook implementations\n\n  \n\n    \n\n      \n\n        \ntrussFrontendAssetsMiddleware\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussFrontendPackageConfig\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussFrontendPackageList\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussFrontendPackageTasks\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussHttpServerRequestMiddleware\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussHttpServerRoutes\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussServerGruntConfig\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussServerPackageConfig\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\ntruss-http\n \u2022 HTTP server\n\n\nManage HTTP connections.\n\n\n\n\n\n\n\n\nFilename\n\n\nTitle\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nabstract.coffee\n\n\nAbstract HTTP server\n\n\nAn abstract HTTP server interface.\n\n\n\n\n\n\nindex.coffee\n\n\nHTTP server\n\n\nManage HTTP connections.\n\n\n\n\n\n\nstub/index.coffee\n\n\n\n\n\n\n\n\n\n\nstub/instance.coffee\n\n\nHTTP server stub implementation\n\n\nA barebones HT TP server implementation.\n\n\n\n\n\n\nstub/router.coffee\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \nHook invocations\n\n  \n\n    \n\n      \n\n        \ntrussHttpServerRequestMiddleware\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussHttpServerRoutes\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \nHook implementations\n\n  \n\n    \n\n      \n\n        \ntrussHttpServerRequestMiddleware\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussHttpServerRequestMiddleware\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussServerBootstrapMiddleware\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussServerPackageConfig\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n  \n\n\n\n\n\ntruss-repl\n \u2022 REPL\n\n\nRuns a REPL and allows packages to add values to its context.\n\n\n\n\n\n\n\n\nFilename\n\n\nTitle\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nindex.coffee\n\n\nREPL\n\n\nRuns a REPL and allows packages to add values to its context.\n\n\n\n\n\n\n\n\n\n  \nHook invocations\n\n  \n\n    \n\n      \n\n        \ntrussReplServerContext\n\n      \n\n      \n\n        \ninvocation\n\n      \n\n    \n\n  \n\n\n\n\n\n\n  \nHook implementations\n\n  \n\n    \n\n      \n\n        \ntrussServerBootstrapMiddleware\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussServerPackageConfig\n\n      \n\n      \n\n        \nimplementation\n\n      \n\n    \n\n    \n\n      \n\n        \ntrussServerProcessExit\n\n      \n\n      \n\n        \nimplementation",
            "title": "Packages"
        },
        {
            "location": "/packages/#truss-dox-documentation",
            "text": "Build the documentation in  gh-pages .     Filename  Title  Description      index.coffee  Documentation  Build the documentation in  gh-pages .    dynamic/index.coffee  Dynamic documentation  Generate all of the dynamic aspects of the project documentation.    dynamic/processor/dox-page-hooks.coffee  Hooks page  Generate the hooks page.    dynamic/processor/dox-page-mkdocs.coffee  mkdocs \"page\"  Generate the mkdocs.yml. Not technically a page, but fits well enough within the abstraction...    dynamic/processor/dox-page-packages.coffee  Packages page  Generate the packages page.    dynamic/processor/dox-page-todos.coffee  TODOs page  Generate the TODOs page.    dynamic/processor/dox-page.coffee  Abstract documentation page  Abstract class to process a documentation page, using a template and generated information.    dynamic/processor/sources-processor.coffee  Abstract sources processor  Abstract class to process the project sources, usually by transforming them to a new form.    dynamic/processor/sources-to-markdown.coffee  Markdown source pages  Implementation of SourcesProcessor to convert source to markdown for easy reading.     \n   Hook invocations \n   \n     \n       \n         trussDoxSourceMarkdownTransform \n       \n       \n         invocation \n       \n     \n     \n       \n         trussDoxSources \n       \n       \n         invocation \n       \n     \n     \n   Hook implementations \n   \n     \n       \n         trussDoxSourceList \n       \n       \n         implementation \n       \n     \n     \n       \n         trussDoxSourceMarkdownTransform \n       \n       \n         implementation \n       \n     \n     \n       \n         trussServerGruntConfig \n       \n       \n         implementation",
            "title": "truss-dox \u2022 Documentation"
        },
        {
            "location": "/packages/#truss-frontend-front-end-system",
            "text": "Front-end abstraction: respond to client, render response, etc.     Filename  Title  Description      index.coffee  Front-end system  Front-end abstraction: respond to client, render response, etc.    client/require.coffee  Require system for browser.  Implement require in the spirit of NodeJS.     \n   Hook invocations \n   \n     \n       \n         trussFrontendAssetsMiddleware \n       \n       \n         invocation \n       \n     \n     \n   Hook implementations \n   \n     \n       \n         trussFrontendAssetsMiddleware \n       \n       \n         implementation \n       \n     \n     \n       \n         trussFrontendPackageConfig \n       \n       \n         implementation \n       \n     \n     \n       \n         trussFrontendPackageList \n       \n       \n         implementation \n       \n     \n     \n       \n         trussFrontendPackageTasks \n       \n       \n         implementation \n       \n     \n     \n       \n         trussHttpServerRequestMiddleware \n       \n       \n         implementation \n       \n     \n     \n       \n         trussHttpServerRoutes \n       \n       \n         implementation \n       \n     \n     \n       \n         trussServerGruntConfig \n       \n       \n         implementation \n       \n     \n     \n       \n         trussServerPackageConfig \n       \n       \n         implementation",
            "title": "truss-frontend \u2022 Front-end system"
        },
        {
            "location": "/packages/#truss-http-http-server",
            "text": "Manage HTTP connections.     Filename  Title  Description      abstract.coffee  Abstract HTTP server  An abstract HTTP server interface.    index.coffee  HTTP server  Manage HTTP connections.    stub/index.coffee      stub/instance.coffee  HTTP server stub implementation  A barebones HT TP server implementation.    stub/router.coffee       \n   Hook invocations \n   \n     \n       \n         trussHttpServerRequestMiddleware \n       \n       \n         invocation \n       \n     \n     \n       \n         trussHttpServerRoutes \n       \n       \n         invocation \n       \n     \n     \n   Hook implementations \n   \n     \n       \n         trussHttpServerRequestMiddleware \n       \n       \n         implementation \n       \n     \n     \n       \n         trussHttpServerRequestMiddleware \n       \n       \n         implementation \n       \n     \n     \n       \n         trussServerBootstrapMiddleware \n       \n       \n         implementation \n       \n     \n     \n       \n         trussServerPackageConfig \n       \n       \n         implementation",
            "title": "truss-http \u2022 HTTP server"
        },
        {
            "location": "/packages/#truss-repl-repl",
            "text": "Runs a REPL and allows packages to add values to its context.     Filename  Title  Description      index.coffee  REPL  Runs a REPL and allows packages to add values to its context.     \n   Hook invocations \n   \n     \n       \n         trussReplServerContext \n       \n       \n         invocation \n       \n     \n     \n   Hook implementations \n   \n     \n       \n         trussServerBootstrapMiddleware \n       \n       \n         implementation \n       \n     \n     \n       \n         trussServerPackageConfig \n       \n       \n         implementation \n       \n     \n     \n       \n         trussServerProcessExit \n       \n       \n         implementation",
            "title": "truss-repl \u2022 REPL"
        },
        {
            "location": "/todos/",
            "text": "TODO list\n\n\n\nTruss \u2014 like any project \u2014 always presents a path for improvement.\nThis is a dynamically generated list of TODO items, each with context.\n\n\n\n\n    lineStream\n\nprocessorsPromise = sourceStreamsPromise.then (streams) ->\n\n\n\n\n\nTODO: This should be dynamic/hook-based\n\n\n  SourcesToMarkdown = require './processor/sources-to-markdown'\n\n  DoxPageTodos = require './processor/dox-page-todos'\n\n\n\n\nthe above found in packages/truss-dox/dynamic/index.coffee:41\n\n\n\n\n\n    promises = for hook in hooks\n      do (hook) -> new Promise (resolve, reject) ->\n\n\n\n\n\nTODO: Dynamic hook locations.\n\n\n        fs.readFile \"docs/hook/#{hook}.md\", (error, output) ->\n          return reject error if error? and error.code isnt 'ENOENT'\n          templates[hook] = output\n\n\n\n\nthe above found in packages/truss-dox/dynamic/processor/dox-page-hooks.coffee:34\n\n\n\n\n_ = require 'lodash'\n\nDoxPage = require './dox-page'\n\n\n\n\n\nTODO: I think this should be done centrally, using an interface on each processor\n\n\nmodule.exports = class DoxPageMkdocs extends DoxPage\n\n  # Build the source hierarchy.\n\n\n\n\nthe above found in packages/truss-dox/dynamic/processor/dox-page-mkdocs.coffee:11\n\n\n\n\n    output: ->\n\n      outputs = for todo in @todos()\n\n\n\n\n\nTODO: Dynamic...\n\n\n        highlight = if @stream.file.match /\\.(?:lit)?coffee$/\n           'coffeescript'\n        else if @stream.file.match /\\.js$/\n\n\n\n\nthe above found in packages/truss-dox/dynamic/processor/dox-page-todos.coffee:46",
            "title": "TODO list"
        },
        {
            "location": "/todos/#todo-this-should-be-dynamichook-based",
            "text": "SourcesToMarkdown = require './processor/sources-to-markdown'\n\n  DoxPageTodos = require './processor/dox-page-todos'  the above found in packages/truss-dox/dynamic/index.coffee:41   \n    promises = for hook in hooks\n      do (hook) -> new Promise (resolve, reject) ->",
            "title": "TODO: This should be dynamic/hook-based"
        },
        {
            "location": "/todos/#todo-dynamic-hook-locations",
            "text": "fs.readFile \"docs/hook/#{hook}.md\", (error, output) ->\n          return reject error if error? and error.code isnt 'ENOENT'\n          templates[hook] = output  the above found in packages/truss-dox/dynamic/processor/dox-page-hooks.coffee:34   _ = require 'lodash'\n\nDoxPage = require './dox-page'",
            "title": "TODO: Dynamic hook locations."
        },
        {
            "location": "/todos/#todo-i-think-this-should-be-done-centrally-using-an-interface-on-each-processor",
            "text": "module.exports = class DoxPageMkdocs extends DoxPage\n\n  # Build the source hierarchy.  the above found in packages/truss-dox/dynamic/processor/dox-page-mkdocs.coffee:11       output: ->\n\n      outputs = for todo in @todos()",
            "title": "TODO: I think this should be done centrally, using an interface on each processor"
        },
        {
            "location": "/todos/#todo-dynamic",
            "text": "highlight = if @stream.file.match /\\.(?:lit)?coffee$/\n           'coffeescript'\n        else if @stream.file.match /\\.js$/  the above found in packages/truss-dox/dynamic/processor/dox-page-todos.coffee:46",
            "title": "TODO: Dynamic..."
        },
        {
            "location": "/source/config/default.settings/",
            "text": "Default application configuration.\n\n\n\n\nPackage list\n\n\nThe list of packages active for this application.\n\n\npackageList:\n\n\n\n\nDevelopment\n\n\nProject documentation. Safe to disable on production.\n\n\n  - 'truss-dox'\n\n\n\n\nProduction\n\n\nREPL to control the application.\n\n\n  - 'truss-repl'\n\n\n\n\nPackage configuration\n\n\nValues for packages which correspond with the values provided by packages'\nimplementations of hook\n\ntrussServerPackageConfig\n.\n\n\npackageConfig: {\n}\n\n\n\n\nBootstrap middleware\n\n\nThe list of middleware that run in the bootstrap phase. This is where you\nspin up your HTTP/socket server, or whatever else. The list contains the\nnames of packages which have an implementation of hook\n\ntrussServerBootstrapMiddleware\n.\n\n\nserverBootstrapMiddleware:\n\n\n\n\nSpin up the REPL.\n\n\n  - 'truss-repl'",
            "title": "default.settings.yml"
        },
        {
            "location": "/source/config/default.settings/#default-application-configuration",
            "text": "",
            "title": "Default application configuration."
        },
        {
            "location": "/source/config/default.settings/#package-list",
            "text": "The list of packages active for this application.  packageList:  Development  Project documentation. Safe to disable on production.    - 'truss-dox'  Production  REPL to control the application.    - 'truss-repl'",
            "title": "Package list"
        },
        {
            "location": "/source/config/default.settings/#package-configuration",
            "text": "Values for packages which correspond with the values provided by packages'\nimplementations of hook trussServerPackageConfig .  packageConfig: {\n}",
            "title": "Package configuration"
        },
        {
            "location": "/source/config/default.settings/#bootstrap-middleware",
            "text": "The list of middleware that run in the bootstrap phase. This is where you\nspin up your HTTP/socket server, or whatever else. The list contains the\nnames of packages which have an implementation of hook trussServerBootstrapMiddleware .  serverBootstrapMiddleware:  Spin up the REPL.    - 'truss-repl'",
            "title": "Bootstrap middleware"
        },
        {
            "location": "/source/Gruntfile/",
            "text": "Gruntfile\n\n\nEntry point for the Grunt build process.\n\n\n{fork} = require \"#{__dirname}/src/bootstrap\"\n\nmodule.exports = (grunt) ->\n\n\n\n\nBootstrap a Truss environment.\n\n\n  require(\"#{__dirname}/src/bootstrap\").bootstrap()\n\n\n\n\nLoad configuration.\n\n\n  fs = require 'fs'\n\n  yaml = require 'js-yaml'\n\n  config = require 'config'\n\n\n\n\nSet environment variables into config.\n\n\n  config.set 'path', __dirname\n  config.set k, v for k, v of process.env\n\n\n\n\nRead configuration file.\n\n\n  settingsFilename = config.get 'path'\n  settingsFilename += '/config/settings.yml'\n\n  grunt.fail.fatal new Error '\n    Settings file not found!\n    You should copy config/default.settings.yml to config/settings.yml\n  ' unless fs.existsSync settingsFilename\n\n  settings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\n  config.set k, v for k, v of settings\n\n\n\n\nRegister the configured packages.\n\n\n  pkgman = require 'pkgman'\n  pkgman.registerPackages config.get 'packageList'\n\n\n\n\nLoad the packages' configuration settings and set into the default config.\n\n\nInvoke hook \ntrussServerPackageConfig\n\n\n  packageConfig = new config.Config()\n  for path, value of pkgman.invoke 'trussServerPackageConfig'\n    packageConfig.set path.replace(/\\//g, ':'), value\n  config.setDefaults packageConfig: packageConfig.toJSON()\n\n\n\n\nGruntConfiguration\n\n\n  gruntConfig = new class GruntConfiguration\n\n\n\n\nGruntConfiguration#constructor\n\n\n    constructor: ->\n\n      @_npmTasks = []\n      @_taskConfig = {}\n      @_tasks = {}\n\n      @pkg = grunt.file.readJSON 'package.json'\n\n\n\n\nGruntConfiguration#configureTask\n\n\n\n\n\n\n(String) \ntask\n - The name of the task to configure.\n\n\n\n\n\n\n(String) \nkey\n - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.\n\n\n\n\n\n\n(Object) \nconfig_\n - The configuration to set. See the documentation\nfor the particular grunt task being configured to learn how to configure\nit.\n\n\n\n\n\n\nConfigure a Grunt task.\n\n\n    configureTask: (task, key, config_) ->\n\n      (@_taskConfig[task] ?= {})[key] = config_\n\n      return\n\n\n\n\nGruntConfiguration#taskConfiguration\n\n\n\n\n\n\n(String) \ntask\n - The name of the task to configure.\n\n\n\n\n\n\n(String) \nkey\n - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.\n\n\n\n\n\n\nGet the configuration for a Grunt task.\n\n\n    taskConfiguration: (task, key) -> @_taskConfig[task]?[key]\n\n\n\n\nGruntConfiguration#loadNpmTasks\n\n\n\n\n(String Array) \ntasks\n - The list of NPM tasks to load.\n\n\n\n\nLoad NPM tasks.\n\n\n    loadNpmTasks: (tasks) ->\n\n      @_npmTasks.push task for task in tasks\n\n      return\n\n\n\n\nGruntConfiguration#registerTask\n\n\n\n\n\n\n(String) \ntask\n - The name of the task to configure.\n\n\n\n\n\n\n(String or String Array or Function) \nsubtasks\n - Either a string or an\narray of strings which define the dependencies for the task, or a\nfunction which will be executed for the task.\n\n\n\n\n\n\nRegister a Grunt task.\n\n\n    registerTask: (task, subtasks) ->\n\n      if 'function' is typeof subtasks\n        @_tasks[task] = subtasks\n      else\n        subtasks = [subtasks] unless Array.isArray subtasks\n        (@_tasks[task] ?= []).push subtasks...\n\n      return\n\n\n\n\nGruntConfiguration#copyAppFiles\n\n\n\n\n\n\n(String) \npath\n - The path of the files to copy.\n\n\n\n\n\n\n(String) \nkey\n - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.\n\n\n\n\n\n\n(String) \ndest\n - The destination where the files will be copied.\nDefaults to \n'app'\n.\n\n\n\n\n\n\nCopy package files to \napp\n.\n\n\n    copyAppFiles: (path, key, dest = 'app') ->\n      dest ?= 'app'\n\n      gruntConfig.configureTask 'copy', key, files: [\n        src: '**/*'\n        dest: dest\n        expand: true\n        cwd: path\n      ]\n\n      gruntConfig.configureTask(\n        'watch', key\n\n        files: [\n          \"#{path}/**/*\"\n        ]\n        tasks: [\"build:#{key}\"]\n      )\n\n\n\n\nDefault tasks.\n\n\n  gruntConfig.registerTask 'build', []\n  gruntConfig.registerTask 'production', ['buildOnce']\n  gruntConfig.registerTask 'default', ['buildOnce']\n\n  gruntConfig.registerTask 'buildOnce', do ->\n    built = false\n\n    ->\n      return if built\n      built = true\n\n      grunt.task.run 'build'\n\n\n\n\nInvoke hook \ntrussServerGruntConfig\n\n\n  try\n    pkgman.invoke 'trussServerGruntConfig', gruntConfig, grunt\n  catch error\n    grunt.fail.fatal error\n\n\n\n\nInvoke hook \ntrussServerGruntConfigAlter\n\n\n  try\n    pkgman.invoke 'trussServerGruntConfigAlter', gruntConfig, grunt\n  catch error\n    grunt.fail.fatal error\n\n\n\n\nInitialize configuration.\n\n\n  grunt.initConfig gruntConfig._taskConfig\n\n\n\n\nLoad NPM tasks.\n\n\n  npmTasksLoaded = {}\n  for task in gruntConfig._npmTasks\n    continue if npmTasksLoaded[task]?\n    npmTasksLoaded[task] = true\n    grunt.loadNpmTasks task\n\n\n\n\nRegister custom tasks.\n\n\n  grunt.registerTask task, actions for task, actions of gruntConfig._tasks",
            "title": "Gruntfile.coffee"
        },
        {
            "location": "/source/Gruntfile/#gruntfile",
            "text": "Entry point for the Grunt build process.  {fork} = require \"#{__dirname}/src/bootstrap\"\n\nmodule.exports = (grunt) ->  Bootstrap a Truss environment.    require(\"#{__dirname}/src/bootstrap\").bootstrap()  Load configuration.    fs = require 'fs'\n\n  yaml = require 'js-yaml'\n\n  config = require 'config'  Set environment variables into config.    config.set 'path', __dirname\n  config.set k, v for k, v of process.env  Read configuration file.    settingsFilename = config.get 'path'\n  settingsFilename += '/config/settings.yml'\n\n  grunt.fail.fatal new Error '\n    Settings file not found!\n    You should copy config/default.settings.yml to config/settings.yml\n  ' unless fs.existsSync settingsFilename\n\n  settings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\n  config.set k, v for k, v of settings  Register the configured packages.    pkgman = require 'pkgman'\n  pkgman.registerPackages config.get 'packageList'  Load the packages' configuration settings and set into the default config.  Invoke hook  trussServerPackageConfig    packageConfig = new config.Config()\n  for path, value of pkgman.invoke 'trussServerPackageConfig'\n    packageConfig.set path.replace(/\\//g, ':'), value\n  config.setDefaults packageConfig: packageConfig.toJSON()",
            "title": "Gruntfile"
        },
        {
            "location": "/source/Gruntfile/#gruntconfiguration",
            "text": "gruntConfig = new class GruntConfiguration",
            "title": "GruntConfiguration"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationconstructor",
            "text": "constructor: ->\n\n      @_npmTasks = []\n      @_taskConfig = {}\n      @_tasks = {}\n\n      @pkg = grunt.file.readJSON 'package.json'",
            "title": "GruntConfiguration#constructor"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationconfiguretask",
            "text": "(String)  task  - The name of the task to configure.    (String)  key  - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.    (Object)  config_  - The configuration to set. See the documentation\nfor the particular grunt task being configured to learn how to configure\nit.    Configure a Grunt task.      configureTask: (task, key, config_) ->\n\n      (@_taskConfig[task] ?= {})[key] = config_\n\n      return",
            "title": "GruntConfiguration#configureTask"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationtaskconfiguration",
            "text": "(String)  task  - The name of the task to configure.    (String)  key  - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.    Get the configuration for a Grunt task.      taskConfiguration: (task, key) -> @_taskConfig[task]?[key]",
            "title": "GruntConfiguration#taskConfiguration"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationloadnpmtasks",
            "text": "(String Array)  tasks  - The list of NPM tasks to load.   Load NPM tasks.      loadNpmTasks: (tasks) ->\n\n      @_npmTasks.push task for task in tasks\n\n      return",
            "title": "GruntConfiguration#loadNpmTasks"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationregistertask",
            "text": "(String)  task  - The name of the task to configure.    (String or String Array or Function)  subtasks  - Either a string or an\narray of strings which define the dependencies for the task, or a\nfunction which will be executed for the task.    Register a Grunt task.      registerTask: (task, subtasks) ->\n\n      if 'function' is typeof subtasks\n        @_tasks[task] = subtasks\n      else\n        subtasks = [subtasks] unless Array.isArray subtasks\n        (@_tasks[task] ?= []).push subtasks...\n\n      return",
            "title": "GruntConfiguration#registerTask"
        },
        {
            "location": "/source/Gruntfile/#gruntconfigurationcopyappfiles",
            "text": "(String)  path  - The path of the files to copy.    (String)  key  - The name of the key in the task configuration to set.\nThis is generally the name of the package, but can be anything.    (String)  dest  - The destination where the files will be copied.\nDefaults to  'app' .    Copy package files to  app .      copyAppFiles: (path, key, dest = 'app') ->\n      dest ?= 'app'\n\n      gruntConfig.configureTask 'copy', key, files: [\n        src: '**/*'\n        dest: dest\n        expand: true\n        cwd: path\n      ]\n\n      gruntConfig.configureTask(\n        'watch', key\n\n        files: [\n          \"#{path}/**/*\"\n        ]\n        tasks: [\"build:#{key}\"]\n      )  Default tasks.    gruntConfig.registerTask 'build', []\n  gruntConfig.registerTask 'production', ['buildOnce']\n  gruntConfig.registerTask 'default', ['buildOnce']\n\n  gruntConfig.registerTask 'buildOnce', do ->\n    built = false\n\n    ->\n      return if built\n      built = true\n\n      grunt.task.run 'build'  Invoke hook  trussServerGruntConfig    try\n    pkgman.invoke 'trussServerGruntConfig', gruntConfig, grunt\n  catch error\n    grunt.fail.fatal error  Invoke hook  trussServerGruntConfigAlter    try\n    pkgman.invoke 'trussServerGruntConfigAlter', gruntConfig, grunt\n  catch error\n    grunt.fail.fatal error  Initialize configuration.    grunt.initConfig gruntConfig._taskConfig  Load NPM tasks.    npmTasksLoaded = {}\n  for task in gruntConfig._npmTasks\n    continue if npmTasksLoaded[task]?\n    npmTasksLoaded[task] = true\n    grunt.loadNpmTasks task  Register custom tasks.    grunt.registerTask task, actions for task, actions of gruntConfig._tasks",
            "title": "GruntConfiguration#copyAppFiles"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/",
            "text": "Dynamic documentation\n\n\nGenerate all of the dynamic aspects of the project documentation.\n\n\nfs = require 'fs'\n\n_ = require 'lodash'\nglob = require 'glob'\nPromise = require 'bluebird'\n\n{LineStream} = require 'byline'\n\npkgman = require 'pkgman'\n\npromiseForStream = (stream) ->\n  new Promise (resolve, reject) ->\n    stream.on 'error', reject\n    stream.on 'close', resolve\n\n\n\n\nGather all source files.\n\n\nsourceFilesPromise = new Promise (resolve, reject) ->\n\n\n\n\nInvoke hook \ntrussDoxSources\n\n\n  sourceFiles = _.flatten pkgman.invokeFlat 'trussDoxSourceList'\n  glob \"{#{sourceFiles.join ','}}\", (error, files) ->\n    return reject error if error?\n    resolve files\n\n\n\n\nMap source files to streams.\n\n\nsourceStreamsPromise = sourceFilesPromise.then (files) ->\n  for file in files\n    lineStream = new LineStream keepEmptyLines: true\n    lineStream.file = file\n\n    lineStream.promise = promiseForStream fstream = fs.createReadStream file\n    fstream.pipe lineStream\n\n    lineStream\n\nprocessorsPromise = sourceStreamsPromise.then (streams) ->\n\n\n\n\nTODO: This should be dynamic/hook-based\n\n\n  SourcesToMarkdown = require './processor/sources-to-markdown'\n\n  DoxPageTodos = require './processor/dox-page-todos'\n  DoxPageHooks = require './processor/dox-page-hooks'\n  DoxPagePackages = require './processor/dox-page-packages'\n  DoxPageMkdocs = require './processor/dox-page-mkdocs'\n\n  processors = [\n    new SourcesToMarkdown streams\n    new DoxPageTodos streams, 'docs/todos.template.md', 'docs/todos.md'\n    new DoxPageHooks streams, 'docs/hooks.template.md', 'docs/hooks.md'\n    new DoxPagePackages streams, 'docs/packages.template.md', 'docs/packages.md'\n    new DoxPageMkdocs streams, 'docs/mkdocs.template.yml', 'mkdocs.yml'\n  ]\n\n  Promise.all(processor.process() for processor in processors)\n\nexports.promise = processorsPromise",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/#dynamic-documentation",
            "text": "Generate all of the dynamic aspects of the project documentation.  fs = require 'fs'\n\n_ = require 'lodash'\nglob = require 'glob'\nPromise = require 'bluebird'\n\n{LineStream} = require 'byline'\n\npkgman = require 'pkgman'\n\npromiseForStream = (stream) ->\n  new Promise (resolve, reject) ->\n    stream.on 'error', reject\n    stream.on 'close', resolve  Gather all source files.  sourceFilesPromise = new Promise (resolve, reject) ->  Invoke hook  trussDoxSources    sourceFiles = _.flatten pkgman.invokeFlat 'trussDoxSourceList'\n  glob \"{#{sourceFiles.join ','}}\", (error, files) ->\n    return reject error if error?\n    resolve files  Map source files to streams.  sourceStreamsPromise = sourceFilesPromise.then (files) ->\n  for file in files\n    lineStream = new LineStream keepEmptyLines: true\n    lineStream.file = file\n\n    lineStream.promise = promiseForStream fstream = fs.createReadStream file\n    fstream.pipe lineStream\n\n    lineStream\n\nprocessorsPromise = sourceStreamsPromise.then (streams) ->  TODO: This should be dynamic/hook-based    SourcesToMarkdown = require './processor/sources-to-markdown'\n\n  DoxPageTodos = require './processor/dox-page-todos'\n  DoxPageHooks = require './processor/dox-page-hooks'\n  DoxPagePackages = require './processor/dox-page-packages'\n  DoxPageMkdocs = require './processor/dox-page-mkdocs'\n\n  processors = [\n    new SourcesToMarkdown streams\n    new DoxPageTodos streams, 'docs/todos.template.md', 'docs/todos.md'\n    new DoxPageHooks streams, 'docs/hooks.template.md', 'docs/hooks.md'\n    new DoxPagePackages streams, 'docs/packages.template.md', 'docs/packages.md'\n    new DoxPageMkdocs streams, 'docs/mkdocs.template.yml', 'mkdocs.yml'\n  ]\n\n  Promise.all(processor.process() for processor in processors)\n\nexports.promise = processorsPromise",
            "title": "Dynamic documentation"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page-hooks/",
            "text": "Hooks page\n\n\nGenerate the hooks page.\n\n\nfs = require 'fs'\n\n{Transform} = require 'stream'\n\nPromise = require 'bluebird'\n\nDoxPage = require './dox-page'\n\nmodule.exports = class DoxPageHooks extends DoxPage\n\n\n\n\nMap hooks to source files.\n\n\n  buildHookMap: (transforms) ->\n\n    hookMap = {}\n\n    for key in ['invocations', 'implementations']\n      for transform in transforms\n        for item in transform[key]\n          ((hookMap[item] ?= {})[key] ?= []).push transform.stream.file\n\n    return hookMap\n\n\n\n\nLoad hook templates.\n\n\n  hookTemplates: (hooks) ->\n\n    templates = {}\n\n    promises = for hook in hooks\n      do (hook) -> new Promise (resolve, reject) ->\n\n\n\n\nTODO: Dynamic hook locations.\n\n\n        fs.readFile \"docs/hook/#{hook}.md\", (error, output) ->\n          return reject error if error? and error.code isnt 'ENOENT'\n          templates[hook] = output\n          resolve()\n\n    Promise.all(promises).then -> templates\n\n  transformsOutput: (transforms) ->\n    self = this\n\n    wordingFor =\n      implementation: 'implements'\n      invocation: 'invoke'\n\n    hookMap = @buildHookMap transforms\n    @hookTemplates(hooks = Object.keys hookMap).then (templates) ->\n\n      render = ''\n\n      for hook in hooks\n\n\n\n\nHook name.\n\n\n        render += \"## #{hook}\\n\\n\"\n\n\n\n\nHook template description.\n\n\n        render += templates[hook] + '\\n\\n' if templates[hook]\n\n\n\n\nOutput the i(mplement|nvoc)ations.\n\n\n        for key in ['implementation', 'invocation']\n          continue unless hookMap[hook][pluralKey = \"#{key}s\"]?\n\n          render += '<div class=\"admonition note\">\\n'\n\n          count = hookMap[hook][pluralKey].length\n          render += \"  <p class=\\\"admonition-title\\\">#{count} #{key}\"\n          render += 's' if count > 1\n\n          render += '</p>\\n'\n          render += '  <table>\\n'\n\n\n\n\nOutput each i(mplement|nvoc)ation.\n\n\n          instances = for file, index in hookMap[hook][pluralKey]\n\n            sourceLink = self.linkToSource file\n\n            \"\"\"\n<tr class=\"#{if index % 2 then 'odd' else 'even'}\\\">\n  <td>\n    <a href=\"../source/#{sourceLink}\">#{file}</a>\n  </td>\n  <td align=\"right\">\n    <a href=\"../source/#{sourceLink}##{wordingFor[key]}-hook-#{self.uniqueId sourceLink, hook}\">#{key}</a>\n  </td>\n</tr>\n\"\"\".split('\\n').map((e) -> \"    #{e}\").join('\\n')\n\n          render += instances.join '\\n'\n\n          render += '\\n  </table>\\n'\n          render += '</div>'\n          render += '\\n\\n'\n\n      return render\n\n  transformForStream: (stream) -> class HookTransform extends Transform\n\n    constructor: (@processor, @stream) ->\n      super null\n\n      @implementations = []\n      @invocations = []\n\n    _transform: (chunk, encoding, done) ->\n      line = chunk.toString 'utf8'\n\n      if matches = line.match /^\\s*# #### Implements hook `([^`]+)`/\n        @implementations.push matches[1]\n\n      if matches = line.match /^\\s*# #### Invoke hook `([^`]+)`/\n        @invocations.push matches[1]\n\n      done()",
            "title": "dox-page-hooks.coffee"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page-hooks/#hooks-page",
            "text": "Generate the hooks page.  fs = require 'fs'\n\n{Transform} = require 'stream'\n\nPromise = require 'bluebird'\n\nDoxPage = require './dox-page'\n\nmodule.exports = class DoxPageHooks extends DoxPage  Map hooks to source files.    buildHookMap: (transforms) ->\n\n    hookMap = {}\n\n    for key in ['invocations', 'implementations']\n      for transform in transforms\n        for item in transform[key]\n          ((hookMap[item] ?= {})[key] ?= []).push transform.stream.file\n\n    return hookMap  Load hook templates.    hookTemplates: (hooks) ->\n\n    templates = {}\n\n    promises = for hook in hooks\n      do (hook) -> new Promise (resolve, reject) ->  TODO: Dynamic hook locations.          fs.readFile \"docs/hook/#{hook}.md\", (error, output) ->\n          return reject error if error? and error.code isnt 'ENOENT'\n          templates[hook] = output\n          resolve()\n\n    Promise.all(promises).then -> templates\n\n  transformsOutput: (transforms) ->\n    self = this\n\n    wordingFor =\n      implementation: 'implements'\n      invocation: 'invoke'\n\n    hookMap = @buildHookMap transforms\n    @hookTemplates(hooks = Object.keys hookMap).then (templates) ->\n\n      render = ''\n\n      for hook in hooks  Hook name.          render += \"## #{hook}\\n\\n\"  Hook template description.          render += templates[hook] + '\\n\\n' if templates[hook]  Output the i(mplement|nvoc)ations.          for key in ['implementation', 'invocation']\n          continue unless hookMap[hook][pluralKey = \"#{key}s\"]?\n\n          render += '<div class=\"admonition note\">\\n'\n\n          count = hookMap[hook][pluralKey].length\n          render += \"  <p class=\\\"admonition-title\\\">#{count} #{key}\"\n          render += 's' if count > 1\n\n          render += '</p>\\n'\n          render += '  <table>\\n'  Output each i(mplement|nvoc)ation.            instances = for file, index in hookMap[hook][pluralKey]\n\n            sourceLink = self.linkToSource file\n\n            \"\"\"\n<tr class=\"#{if index % 2 then 'odd' else 'even'}\\\">\n  <td>\n    <a href=\"../source/#{sourceLink}\">#{file}</a>\n  </td>\n  <td align=\"right\">\n    <a href=\"../source/#{sourceLink}##{wordingFor[key]}-hook-#{self.uniqueId sourceLink, hook}\">#{key}</a>\n  </td>\n</tr>\n\"\"\".split('\\n').map((e) -> \"    #{e}\").join('\\n')\n\n          render += instances.join '\\n'\n\n          render += '\\n  </table>\\n'\n          render += '</div>'\n          render += '\\n\\n'\n\n      return render\n\n  transformForStream: (stream) -> class HookTransform extends Transform\n\n    constructor: (@processor, @stream) ->\n      super null\n\n      @implementations = []\n      @invocations = []\n\n    _transform: (chunk, encoding, done) ->\n      line = chunk.toString 'utf8'\n\n      if matches = line.match /^\\s*# #### Implements hook `([^`]+)`/\n        @implementations.push matches[1]\n\n      if matches = line.match /^\\s*# #### Invoke hook `([^`]+)`/\n        @invocations.push matches[1]\n\n      done()",
            "title": "Hooks page"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page-mkdocs/",
            "text": "mkdocs \"page\"\n\n\nGenerate the mkdocs.yml. Not technically a page, but fits well enough\nwithin the abstraction...\n\n\n{Transform} = require 'stream'\n\n_ = require 'lodash'\n\nDoxPage = require './dox-page'\n\n\n\n\nTODO: I think this should be done centrally, using an interface on each processor\n\n\nmodule.exports = class DoxPageMkdocs extends DoxPage\n\n\n\n\nBuild the source hierarchy.\n\n\n  buildHierarchy: (transforms) ->\n\n    hierarchy = Source: {}\n\n    for {stream: file: file} in transforms\n      walk = hierarchy.Source\n      parts = file.split '/'\n      for part, i in parts\n        if i is parts.length - 1\n          walk[part] = \"source/#{file}\"\n        else\n          walk[part] ?= {}\n          walk = walk[part]\n\n    return hierarchy\n\n\n\n\nRender the source hierarchy.\n\n\n  renderHierarchy: (hierarchy) ->\n\n    output = []\n\n    renderHierarchyInternal = (output, hierarchy, indent) ->\n      if _.isString hierarchy\n        output[output.length - 1] += \" '#{hierarchy}'\"\n      else\n        for k, v of hierarchy\n          output.push \"#{indent}- #{k}:\"\n          renderHierarchyInternal output, v, \"#{indent}    \"\n\n    renderHierarchyInternal output, hierarchy, ''\n\n    return output\n\n  transformsOutput: (transforms) ->\n    return @renderHierarchy(@buildHierarchy transforms).join '\\n'\n\n  transformForStream: (stream) -> class Passthrough extends Transform\n\n    constructor: (@processor, @stream) ->\n      super null\n\n    _transform: (chunk, encoding, done) ->\n      @push chunk\n      done()",
            "title": "dox-page-mkdocs.coffee"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page-mkdocs/#mkdocs-page",
            "text": "Generate the mkdocs.yml. Not technically a page, but fits well enough\nwithin the abstraction...  {Transform} = require 'stream'\n\n_ = require 'lodash'\n\nDoxPage = require './dox-page'  TODO: I think this should be done centrally, using an interface on each processor  module.exports = class DoxPageMkdocs extends DoxPage  Build the source hierarchy.    buildHierarchy: (transforms) ->\n\n    hierarchy = Source: {}\n\n    for {stream: file: file} in transforms\n      walk = hierarchy.Source\n      parts = file.split '/'\n      for part, i in parts\n        if i is parts.length - 1\n          walk[part] = \"source/#{file}\"\n        else\n          walk[part] ?= {}\n          walk = walk[part]\n\n    return hierarchy  Render the source hierarchy.    renderHierarchy: (hierarchy) ->\n\n    output = []\n\n    renderHierarchyInternal = (output, hierarchy, indent) ->\n      if _.isString hierarchy\n        output[output.length - 1] += \" '#{hierarchy}'\"\n      else\n        for k, v of hierarchy\n          output.push \"#{indent}- #{k}:\"\n          renderHierarchyInternal output, v, \"#{indent}    \"\n\n    renderHierarchyInternal output, hierarchy, ''\n\n    return output\n\n  transformsOutput: (transforms) ->\n    return @renderHierarchy(@buildHierarchy transforms).join '\\n'\n\n  transformForStream: (stream) -> class Passthrough extends Transform\n\n    constructor: (@processor, @stream) ->\n      super null\n\n    _transform: (chunk, encoding, done) ->\n      @push chunk\n      done()",
            "title": "mkdocs \"page\""
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page-packages/",
            "text": "Packages page\n\n\nGenerate the packages page.\n\n\npath = require 'path'\n\n{Transform} = require 'stream'\n\nDoxPage = require './dox-page'\n\nmodule.exports = class DoxPagePackages extends DoxPage\n\n\n\n\nSort files by package.\n\n\n  sortFilesByPackage: (transforms) ->\n\n    packages = {}\n\n    for transform in transforms\n      parts = transform.stream.file.split '/'\n      continue if parts[0] isnt 'packages'\n      (packages[parts[1]] ?= []).push transform.stream.file\n\n    return packages\n\n\n\n\nCreate a map to lookup transforms by filename.\n\n\n  transformsFileMap: (transforms) ->\n    fileMap = {}\n    fileMap[transform.stream.file] = transform for transform in transforms\n    return fileMap\n\n\n\n\nLookup index file for a package.\n\n\n  packageIndex: (package_, files) ->\n\n    packageIndex = ''\n\n    for file in files\n      dirname = path.dirname file\n      basename = path.basename file, path.extname file\n      parts = \"#{dirname}/#{basename}\".split('/').slice 1\n\n      if parts.length is 2 and package_ is parts[0] and 'index' is parts[1]\n        packageIndex = file\n        break\n\n    return packageIndex\n\n\n\n\nRender a table of package files.\n\n\n  outputPackageFiles: (files, fileMap) ->\n\n    output  = 'Filename | Title | Description\\n'\n    output += '-------- | ----- | -----------\\n'\n\n    files = files.sort (l, r) ->\n      lp = l.split('/').length\n      rp = r.split('/').length\n\n\n\n\nFirst sort hierarchically.\n\n\n      return -1 if lp < rp\n      return 1 if lp > rp\n\n\n\n\nThen, alphabetically.\n\n\n      return -1 if l < r\n      return 1 if l > r\n      return 0\n\n    for file in files\n      transform = fileMap[file]\n      output += \"[#{\n        file.split('/').slice(2).join '/'\n      }](source/#{\n        @linkToSource file\n      }) | #{\n        transform.title\n      } | #{\n        transform.description\n      }\\n\"\n\n    return output\n\n\n\n\nRender a table of hooks for a package.\n\n\n  outputPackageHooks: (files, fileMap) ->\n\n    output = ''\n\n    wordingFor =\n      implementation: 'implements'\n      invocation: 'invoke'\n\n    for key in ['invocation', 'implementation']\n      pluralKey = \"#{key}s\"\n\n\n\n\nSort the hooks list.\n\n\n      hooksList = []\n      for file, index in files\n        transform = fileMap[file]\n        for hook in transform[pluralKey]\n          hooksList.push hook: hook, file: file\n      hooksList = hooksList.sort (l, r) -> if l.hook < r.hook then -1 else 1\n\n\n\n\nOutput the hooks in the package.\n\n\n      hookOutput = ''\n      for {hook, file} in hooksList\n\n        sourceLink = @linkToSource file\n\n        hookOutput += \"\"\"\n<tr class=\"#{if index % 2 then 'odd' else 'even'}\\\">\n  <td>\n    <a href=\"../hooks##{@uniqueId 'hooks', hook}\">#{hook}</a>\n  </td>\n  <td align=\"right\">\n    <a href=\"../source/#{sourceLink}##{wordingFor[key]}-hook-#{@uniqueId sourceLink, hook}\">#{key}</a>\n  </td>\n</tr>\n\"\"\".split('\\n').map((e) -> \"    #{e}\").join('\\n') + '\\n'\n      continue unless hookOutput\n\n\n\n\nOutput the whole hooks table.\n\n\n      output += '<div class=\"admonition note\">\\n'\n      output += \"  <p class=\\\"admonition-title\\\">Hook #{pluralKey}\"\n      output += '</p>\\n'\n      output += '  <table>\\n'\n\n      output += hookOutput\n\n      output += '  </table>\\n'\n      output += '</div>'\n      output += '\\n'\n\n    return output\n\n\n\n\nRender packages.\n\n\n  transformsOutput: (transforms) ->\n    self = this\n\n    packages = @sortFilesByPackage transforms\n\n    fileMap = @transformsFileMap transforms\n\n    output = '\\n'\n\n    for package_, files of packages\n\n      packageIndex = @packageIndex package_, files\n\n\n\n\nPackage name[, Title]\n\n\n      output += \"## `#{package_}`\"\n      output += \" \u2022 #{\n        fileMap[packageIndex].title\n      }\" if fileMap[packageIndex].title\n      output += '\\n\\n'\n\n\n\n\n[Description]\n\n\n      output += \"#{\n        fileMap[packageIndex].description\n      }\\n\\n\" if fileMap[packageIndex].description\n\n      output += @outputPackageFiles files, fileMap\n      output += '\\n'\n\n      output += @outputPackageHooks files, fileMap\n      output += '\\n'\n\n    return output\n\n  transformForStream: (stream) -> class PackagesTransform extends Transform\n\n    constructor: (@processor, @stream) ->\n      super null\n\n      @title = ''\n      @description = ''\n      @hasGottenTitleAndDescription = false\n\n      @implementations = []\n      @invocations = []\n\n    _transform: (chunk, encoding, done) ->\n      line = chunk.toString 'utf8'\n\n      unless @hasGottenTitleAndDescription\n\n        line = chunk.toString('utf8').trim()\n        return done() if line.length is 0\n\n        if '#'.charCodeAt(0) is line.charCodeAt(0)\n\n          if '#'.charCodeAt(0) is line.charCodeAt(2)\n            @title = line.substr 4\n\n          else if '*'.charCodeAt(0) is line.charCodeAt(2)\n            @description = line.substr 2\n\n          else if @description?\n            @description += ' ' + line.substr 2\n\n          if '*'.charCodeAt(0) is @description.charCodeAt @description.length - 1\n            @hasGottenTitleAndDescription = true\n\n        else\n\n          @hasGottenTitleAndDescription = true\n\n      if matches = line.match /^\\s*# #### Implements hook `([^`]+)`/\n        @implementations.push matches[1]\n\n      if matches = line.match /^\\s*# #### Invoke hook `([^`]+)`/\n        @invocations.push matches[1]\n\n      done()",
            "title": "dox-page-packages.coffee"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page-packages/#packages-page",
            "text": "Generate the packages page.  path = require 'path'\n\n{Transform} = require 'stream'\n\nDoxPage = require './dox-page'\n\nmodule.exports = class DoxPagePackages extends DoxPage  Sort files by package.    sortFilesByPackage: (transforms) ->\n\n    packages = {}\n\n    for transform in transforms\n      parts = transform.stream.file.split '/'\n      continue if parts[0] isnt 'packages'\n      (packages[parts[1]] ?= []).push transform.stream.file\n\n    return packages  Create a map to lookup transforms by filename.    transformsFileMap: (transforms) ->\n    fileMap = {}\n    fileMap[transform.stream.file] = transform for transform in transforms\n    return fileMap  Lookup index file for a package.    packageIndex: (package_, files) ->\n\n    packageIndex = ''\n\n    for file in files\n      dirname = path.dirname file\n      basename = path.basename file, path.extname file\n      parts = \"#{dirname}/#{basename}\".split('/').slice 1\n\n      if parts.length is 2 and package_ is parts[0] and 'index' is parts[1]\n        packageIndex = file\n        break\n\n    return packageIndex  Render a table of package files.    outputPackageFiles: (files, fileMap) ->\n\n    output  = 'Filename | Title | Description\\n'\n    output += '-------- | ----- | -----------\\n'\n\n    files = files.sort (l, r) ->\n      lp = l.split('/').length\n      rp = r.split('/').length  First sort hierarchically.        return -1 if lp < rp\n      return 1 if lp > rp  Then, alphabetically.        return -1 if l < r\n      return 1 if l > r\n      return 0\n\n    for file in files\n      transform = fileMap[file]\n      output += \"[#{\n        file.split('/').slice(2).join '/'\n      }](source/#{\n        @linkToSource file\n      }) | #{\n        transform.title\n      } | #{\n        transform.description\n      }\\n\"\n\n    return output  Render a table of hooks for a package.    outputPackageHooks: (files, fileMap) ->\n\n    output = ''\n\n    wordingFor =\n      implementation: 'implements'\n      invocation: 'invoke'\n\n    for key in ['invocation', 'implementation']\n      pluralKey = \"#{key}s\"  Sort the hooks list.        hooksList = []\n      for file, index in files\n        transform = fileMap[file]\n        for hook in transform[pluralKey]\n          hooksList.push hook: hook, file: file\n      hooksList = hooksList.sort (l, r) -> if l.hook < r.hook then -1 else 1  Output the hooks in the package.        hookOutput = ''\n      for {hook, file} in hooksList\n\n        sourceLink = @linkToSource file\n\n        hookOutput += \"\"\"\n<tr class=\"#{if index % 2 then 'odd' else 'even'}\\\">\n  <td>\n    <a href=\"../hooks##{@uniqueId 'hooks', hook}\">#{hook}</a>\n  </td>\n  <td align=\"right\">\n    <a href=\"../source/#{sourceLink}##{wordingFor[key]}-hook-#{@uniqueId sourceLink, hook}\">#{key}</a>\n  </td>\n</tr>\n\"\"\".split('\\n').map((e) -> \"    #{e}\").join('\\n') + '\\n'\n      continue unless hookOutput  Output the whole hooks table.        output += '<div class=\"admonition note\">\\n'\n      output += \"  <p class=\\\"admonition-title\\\">Hook #{pluralKey}\"\n      output += '</p>\\n'\n      output += '  <table>\\n'\n\n      output += hookOutput\n\n      output += '  </table>\\n'\n      output += '</div>'\n      output += '\\n'\n\n    return output  Render packages.    transformsOutput: (transforms) ->\n    self = this\n\n    packages = @sortFilesByPackage transforms\n\n    fileMap = @transformsFileMap transforms\n\n    output = '\\n'\n\n    for package_, files of packages\n\n      packageIndex = @packageIndex package_, files  Package name[, Title]        output += \"## `#{package_}`\"\n      output += \" \u2022 #{\n        fileMap[packageIndex].title\n      }\" if fileMap[packageIndex].title\n      output += '\\n\\n'  [Description]        output += \"#{\n        fileMap[packageIndex].description\n      }\\n\\n\" if fileMap[packageIndex].description\n\n      output += @outputPackageFiles files, fileMap\n      output += '\\n'\n\n      output += @outputPackageHooks files, fileMap\n      output += '\\n'\n\n    return output\n\n  transformForStream: (stream) -> class PackagesTransform extends Transform\n\n    constructor: (@processor, @stream) ->\n      super null\n\n      @title = ''\n      @description = ''\n      @hasGottenTitleAndDescription = false\n\n      @implementations = []\n      @invocations = []\n\n    _transform: (chunk, encoding, done) ->\n      line = chunk.toString 'utf8'\n\n      unless @hasGottenTitleAndDescription\n\n        line = chunk.toString('utf8').trim()\n        return done() if line.length is 0\n\n        if '#'.charCodeAt(0) is line.charCodeAt(0)\n\n          if '#'.charCodeAt(0) is line.charCodeAt(2)\n            @title = line.substr 4\n\n          else if '*'.charCodeAt(0) is line.charCodeAt(2)\n            @description = line.substr 2\n\n          else if @description?\n            @description += ' ' + line.substr 2\n\n          if '*'.charCodeAt(0) is @description.charCodeAt @description.length - 1\n            @hasGottenTitleAndDescription = true\n\n        else\n\n          @hasGottenTitleAndDescription = true\n\n      if matches = line.match /^\\s*# #### Implements hook `([^`]+)`/\n        @implementations.push matches[1]\n\n      if matches = line.match /^\\s*# #### Invoke hook `([^`]+)`/\n        @invocations.push matches[1]\n\n      done()",
            "title": "Packages page"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page-todos/",
            "text": "TODOs page\n\n\nGenerate the TODOs page.\n\n\n{Transform} = require 'stream'\n\nDoxPage = require './dox-page'\n\nmodule.exports = class DoxPageTodos extends DoxPage\n\n\n\n\nImplement a Transform stream to accumulate TODOs from a source file. Also\ncaches lines to be able to build context around each TODO item.\n\n\n  transformForStream: (stream) -> class TodoTransform extends Transform\n\n    @CONTEXT = 4\n\n    constructor: (@processor, @stream) ->\n      super null\n\n      @context = []\n      @lines = []\n\n    _transform: (chunk, encoding, done) ->\n\n\n\n\nTrack all lines, for later context.\n\n\n      @context.push line = chunk.toString 'utf8'\n\n\n\n\nTrack all TODOs.\n\n\n      @lines.push @context.length - 1 if line.match /^\\s*# ###### TODO/\n\n      done()\n\n    todos: ->\n\n\n\n\nChop out context for each TODO, and include it with the line number.\n\n\n      for line in @lines\n        start = Math.max 0, line - TodoTransform.CONTEXT\n        end = Math.min @context.length - 1, line + TodoTransform.CONTEXT\n\n        line: line\n        context: @context.slice start, end\n\n    output: ->\n\n      outputs = for todo in @todos()\n\n\n\n\nTODO: Dynamic...\n\n\n        highlight = if @stream.file.match /\\.(?:lit)?coffee$/\n           'coffeescript'\n        else if @stream.file.match /\\.js$/\n          'javascript'\n        else\n          'no-highlight'\n\n        output = \"\\n---\\n\\n```#{highlight}\\n\"\n\n        for line, index in todo.context\n\n\n\n\nIf this is the line with the TODO, parse the ID from the TODO\nitem text, and render it as h2 (TODO are h6) to increase\nvisibility.\n\n\n          if index is TodoTransform.CONTEXT\n            output += \"```\\n\\n#{line.trim().slice 6}\\n\\n```#{highlight}\"\n          else\n            output += line\n          output += '\\n'\n\n        output += '```\\n\\n'\n\n        sourceLink = @processor.linkToSource @stream.file\n\n\n\n\nThe link to the TODO in the source file.\n\n\n        output += \"[the above found in #{\n          @stream.file\n        }:#{\n          todo.line\n        }](source/#{\n          sourceLink\n        }##{\n          @processor.uniqueId(\n            sourceLink, todo.context[TodoTransform.CONTEXT]\n          )\n        })\"\n\n      outputs.join '\\n'",
            "title": "dox-page-todos.coffee"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page-todos/#todos-page",
            "text": "Generate the TODOs page.  {Transform} = require 'stream'\n\nDoxPage = require './dox-page'\n\nmodule.exports = class DoxPageTodos extends DoxPage  Implement a Transform stream to accumulate TODOs from a source file. Also\ncaches lines to be able to build context around each TODO item.    transformForStream: (stream) -> class TodoTransform extends Transform\n\n    @CONTEXT = 4\n\n    constructor: (@processor, @stream) ->\n      super null\n\n      @context = []\n      @lines = []\n\n    _transform: (chunk, encoding, done) ->  Track all lines, for later context.        @context.push line = chunk.toString 'utf8'  Track all TODOs.        @lines.push @context.length - 1 if line.match /^\\s*# ###### TODO/\n\n      done()\n\n    todos: ->  Chop out context for each TODO, and include it with the line number.        for line in @lines\n        start = Math.max 0, line - TodoTransform.CONTEXT\n        end = Math.min @context.length - 1, line + TodoTransform.CONTEXT\n\n        line: line\n        context: @context.slice start, end\n\n    output: ->\n\n      outputs = for todo in @todos()  TODO: Dynamic...          highlight = if @stream.file.match /\\.(?:lit)?coffee$/\n           'coffeescript'\n        else if @stream.file.match /\\.js$/\n          'javascript'\n        else\n          'no-highlight'\n\n        output = \"\\n---\\n\\n```#{highlight}\\n\"\n\n        for line, index in todo.context  If this is the line with the TODO, parse the ID from the TODO\nitem text, and render it as h2 (TODO are h6) to increase\nvisibility.            if index is TodoTransform.CONTEXT\n            output += \"```\\n\\n#{line.trim().slice 6}\\n\\n```#{highlight}\"\n          else\n            output += line\n          output += '\\n'\n\n        output += '```\\n\\n'\n\n        sourceLink = @processor.linkToSource @stream.file  The link to the TODO in the source file.          output += \"[the above found in #{\n          @stream.file\n        }:#{\n          todo.line\n        }](source/#{\n          sourceLink\n        }##{\n          @processor.uniqueId(\n            sourceLink, todo.context[TodoTransform.CONTEXT]\n          )\n        })\"\n\n      outputs.join '\\n'",
            "title": "TODOs page"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page/",
            "text": "Abstract documentation page\n\n\nAbstract class to process a documentation page, using a template and\ngenerated information.\n\n\npath = require 'path'\nfs = require 'fs'\n\nPromise = require 'bluebird'\n\nSourcesProcessor = require './sources-processor'\n\nmodule.exports = class DoxPage extends SourcesProcessor\n\n  constructor: (@streams, @template, @destination) ->\n    super\n\n    @idMap = {}\n\n  process: ->\n    self = this\n\n\n\n\nApply the transforms.\n\n\n    transforms = self.streamsToTransforms()\n\n\n\n\nLoad the template and wait until streaming is done.\n\n\n    new Promise (resolve, reject) =>\n      fs.readFile @template, 'utf8',  (error, output) ->\n        return reject error if error?\n\n\n\n\nAppend all of the transformed content.\n\n\n        Promise.cast(self.transformsOutput transforms).then (tOutput) ->\n          output += tOutput\n\n\n\n\nWrite it as the final page.\n\n\n          fs.writeFile self.destination, output, (error) ->\n            return reject error if error?\n            resolve()\n\n  transformsOutput: (transforms) ->\n    output = (transform.output() for transform in transforms).join '\\n'\n    output += '\\n'\n\n  linkToSource: (file) ->\n\n    link = path.dirname file\n    basename = path.basename file, path.extname file\n    link += \"/#{basename}\" if basename isnt 'index'\n\n    return link\n\n  uniqueId: (page, string) ->\n    @idMap[page] ?= {}\n\n\n\n\nSanitize it.\n\n\n    id = string.replace(\n      /[/'']/g, ''\n    ).replace(\n      /\\[(.*)\\]\\(.*\\)/g, '$1'\n    ).replace(\n      /[^0-9A-Za-z-]+/g, '-'\n    ).replace(\n      /\\-+/g, '-'\n    ).replace(\n      /^\\-+|\\-+$/g, ''\n    ).toLowerCase()\n\n\n\n\nKeep track of ID usage and modify the location hash for\nsubsequent uses.\n\n\n    if @idMap[page][id]?\n      @idMap[page][id] += 1\n      id += \"_#{@idMap[page][id]}\"\n    else\n      @idMap[page][id] = 0\n\n    return id",
            "title": "dox-page.coffee"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/dox-page/#abstract-documentation-page",
            "text": "Abstract class to process a documentation page, using a template and\ngenerated information.  path = require 'path'\nfs = require 'fs'\n\nPromise = require 'bluebird'\n\nSourcesProcessor = require './sources-processor'\n\nmodule.exports = class DoxPage extends SourcesProcessor\n\n  constructor: (@streams, @template, @destination) ->\n    super\n\n    @idMap = {}\n\n  process: ->\n    self = this  Apply the transforms.      transforms = self.streamsToTransforms()  Load the template and wait until streaming is done.      new Promise (resolve, reject) =>\n      fs.readFile @template, 'utf8',  (error, output) ->\n        return reject error if error?  Append all of the transformed content.          Promise.cast(self.transformsOutput transforms).then (tOutput) ->\n          output += tOutput  Write it as the final page.            fs.writeFile self.destination, output, (error) ->\n            return reject error if error?\n            resolve()\n\n  transformsOutput: (transforms) ->\n    output = (transform.output() for transform in transforms).join '\\n'\n    output += '\\n'\n\n  linkToSource: (file) ->\n\n    link = path.dirname file\n    basename = path.basename file, path.extname file\n    link += \"/#{basename}\" if basename isnt 'index'\n\n    return link\n\n  uniqueId: (page, string) ->\n    @idMap[page] ?= {}  Sanitize it.      id = string.replace(\n      /[/'']/g, ''\n    ).replace(\n      /\\[(.*)\\]\\(.*\\)/g, '$1'\n    ).replace(\n      /[^0-9A-Za-z-]+/g, '-'\n    ).replace(\n      /\\-+/g, '-'\n    ).replace(\n      /^\\-+|\\-+$/g, ''\n    ).toLowerCase()  Keep track of ID usage and modify the location hash for\nsubsequent uses.      if @idMap[page][id]?\n      @idMap[page][id] += 1\n      id += \"_#{@idMap[page][id]}\"\n    else\n      @idMap[page][id] = 0\n\n    return id",
            "title": "Abstract documentation page"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/sources-processor/",
            "text": "Abstract sources processor\n\n\nAbstract class to process the project sources, usually by transforming them\nto a new form.\n\n\nPromise = require 'bluebird'\n\nmodule.exports = class SourcesProcessor\n\n  constructor: (@streams) ->\n\n  process: -> throw new Error(\n    \"SourcesProcessor::process is a pure virtual method\"\n  )\n\n  streamsToTransforms: ->\n    for stream in @streams\n      Transform_ = @transformForStream stream\n      stream.pipe transformStream = new Transform_ this, stream\n      transformStream\n\n  transformForStream: -> class NoTransform\n    constructor: -> throw new Error(\n      \"SourceProcessor::Transform is a pure virtual class\"\n    )",
            "title": "sources-processor.coffee"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/sources-processor/#abstract-sources-processor",
            "text": "Abstract class to process the project sources, usually by transforming them\nto a new form.  Promise = require 'bluebird'\n\nmodule.exports = class SourcesProcessor\n\n  constructor: (@streams) ->\n\n  process: -> throw new Error(\n    \"SourcesProcessor::process is a pure virtual method\"\n  )\n\n  streamsToTransforms: ->\n    for stream in @streams\n      Transform_ = @transformForStream stream\n      stream.pipe transformStream = new Transform_ this, stream\n      transformStream\n\n  transformForStream: -> class NoTransform\n    constructor: -> throw new Error(\n      \"SourceProcessor::Transform is a pure virtual class\"\n    )",
            "title": "Abstract sources processor"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/sources-to-markdown/",
            "text": "Markdown source pages\n\n\nImplementation of SourcesProcessor to convert source to markdown for easy\nreading.\n\n\nfs = require 'fs'\npath = require 'path'\n\nPromise = require 'bluebird'\n\n{Transform} = require 'stream'\n\npkgman = require 'pkgman'\n\nSourcesProcessor = require './sources-processor'\n\npromiseForStream = (stream) ->\n  new Promise (resolve, reject) ->\n    stream.on 'error', reject\n    stream.on 'close', resolve\n\nmodule.exports = class SourcesToMarkdown extends SourcesProcessor\n\n  constructor: ->\n    super\n\n    @extensionMap = {}\n\n  buildDirectoryStructure: ->\n\n\n\n\nBuild the directory tree.\n\n\n    pathMap = {}\n    for {file} in @streams\n      parts = file.split '/'\n      for i in [0...parts.length]\n        pathMap[\"docs/source/#{parts.slice(0, i).join '/'}\"] = true\n\n\n\n\nThis could be made async...\n\n\n    for path_ of pathMap\n      try\n        fs.mkdirSync path_\n      catch error\n        throw error if 'EEXIST' isnt error.code\n\n  buildExtensionMap: ->\n\n\n\n\nInvoke hook \ntrussDoxSourceMarkdownTransform\n\n\n    @extensionMap = {}\n    for transform in pkgman.invokeFlat 'trussDoxSourceMarkdownTransform'\n      for extension in transform.extensions\n        @extensionMap[extension] = transform.TransformClass\n\n  processMarkdown: ->\n\n\n\n\nConvert to markdown.\n\n\n    transforms = @streamsToTransforms @streams\n    promises = for stream, i in @streams\n      destination = fs.createWriteStream \"docs/source/#{stream.file}\"\n      transforms[i].pipe destination\n      promiseForStream destination\n\n    Promise.all promises\n\n  process: ->\n\n    @buildDirectoryStructure()\n    @buildExtensionMap()\n    @processMarkdown()\n\n  transformForStream: (stream) ->\n\n\n\n\nHandler for this extension?\n\n\n    extension = path.extname(stream.file).substr 1\n    TransformClass = if @extensionMap[extension]?\n      @extensionMap[extension]\n\n    else\n\n\n\n\nOtherwise pass the source through as markdown: one big fenced code\nblock.\n\n\n      class PassthroughToMarkdown extends Transform\n\n        constructor: ->\n          super null\n\n          @push \"```\\n\"\n          @on 'finish', => @unshift \"```no-highlight\\n\"\n\n        _transform: (chunk, encoding, done) ->\n          @push \"#{chunk.toString 'utf8'}\\n\"\n          done()",
            "title": "sources-to-markdown.coffee"
        },
        {
            "location": "/source/packages/truss-dox/dynamic/processor/sources-to-markdown/#markdown-source-pages",
            "text": "Implementation of SourcesProcessor to convert source to markdown for easy\nreading.  fs = require 'fs'\npath = require 'path'\n\nPromise = require 'bluebird'\n\n{Transform} = require 'stream'\n\npkgman = require 'pkgman'\n\nSourcesProcessor = require './sources-processor'\n\npromiseForStream = (stream) ->\n  new Promise (resolve, reject) ->\n    stream.on 'error', reject\n    stream.on 'close', resolve\n\nmodule.exports = class SourcesToMarkdown extends SourcesProcessor\n\n  constructor: ->\n    super\n\n    @extensionMap = {}\n\n  buildDirectoryStructure: ->  Build the directory tree.      pathMap = {}\n    for {file} in @streams\n      parts = file.split '/'\n      for i in [0...parts.length]\n        pathMap[\"docs/source/#{parts.slice(0, i).join '/'}\"] = true  This could be made async...      for path_ of pathMap\n      try\n        fs.mkdirSync path_\n      catch error\n        throw error if 'EEXIST' isnt error.code\n\n  buildExtensionMap: ->  Invoke hook  trussDoxSourceMarkdownTransform      @extensionMap = {}\n    for transform in pkgman.invokeFlat 'trussDoxSourceMarkdownTransform'\n      for extension in transform.extensions\n        @extensionMap[extension] = transform.TransformClass\n\n  processMarkdown: ->  Convert to markdown.      transforms = @streamsToTransforms @streams\n    promises = for stream, i in @streams\n      destination = fs.createWriteStream \"docs/source/#{stream.file}\"\n      transforms[i].pipe destination\n      promiseForStream destination\n\n    Promise.all promises\n\n  process: ->\n\n    @buildDirectoryStructure()\n    @buildExtensionMap()\n    @processMarkdown()\n\n  transformForStream: (stream) ->  Handler for this extension?      extension = path.extname(stream.file).substr 1\n    TransformClass = if @extensionMap[extension]?\n      @extensionMap[extension]\n\n    else  Otherwise pass the source through as markdown: one big fenced code\nblock.        class PassthroughToMarkdown extends Transform\n\n        constructor: ->\n          super null\n\n          @push \"```\\n\"\n          @on 'finish', => @unshift \"```no-highlight\\n\"\n\n        _transform: (chunk, encoding, done) ->\n          @push \"#{chunk.toString 'utf8'}\\n\"\n          done()",
            "title": "Markdown source pages"
        },
        {
            "location": "/source/packages/truss-dox/",
            "text": "Documentation\n\n\nBuild the documentation in \ngh-pages\n.\n\n\npath = require 'path'\n\n{fork, spawn} = require 'child_process'\n\n{Transform} = require 'stream'\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \ntrussDoxSourceList\n\n\n  registrar.registerHook 'trussDoxSourceList', -> [\n    '*.coffee'\n    'src/**/*.coffee'\n    'config/default.settings.yml'\n    'packages/**/*.coffee'\n  ]\n\n\n\n\nImplements hook \ntrussDoxSourceMarkdownTransform\n\n\n  registrar.registerHook 'trussDoxSourceMarkdownTransform', ->\n\n\n\n\nImplement a transform stream to convert a source using hash comments to\nmarkdown. This applies to coffee and yaml files.\n\n\n    extensions: [\n      'coffee', 'litcoffee'\n      'yaml', 'yml'\n    ]\n    TransformClass: class HashCommentToMarkdown extends Transform\n\n      constructor: (@processor, @stream) ->\n        super null\n\n\n\n\nLanguage to highlight in fenced code.\n\n\n        @fencing = if @stream.file.match /\\.(?:lit)?coffee$/\n          'coffeescript'\n        else if @stream.file.match /\\.ya?ml$/\n          'yaml'\n\n        @hanging = []\n        @hasWrittenCode = false\n        @commenting = false\n\n        @on 'finish', => @unshift \"```\\n\" if @hasWrittenCode and not @commenting\n\n      _transform: (chunk, encoding, done) ->\n\n        line = chunk.toString 'utf8'\n\n\n\n\nEmit comment.\n\n\n        if '#'.charCodeAt(0) is line.trim().charCodeAt(0)\n\n\n\n\nEnd fenced code.\n\n\n          @push \"```\\n\\n\" if @hasWrittenCode and not @commenting\n\n          comment = line.trim().substr 2\n\n\n\n\nLink hook i(nvoc|mplement)ation comments to the hook page.\n\n\n          matches = comment.match /^#### (I(?:nvoke|mplements)) hook `([^`]+)`/\n          if matches\n\n            parts = path.dirname(@stream.file).split('/')\n            parts.push '' if 'index.coffee' isnt path.basename @stream.file\n            backpath = parts.map(-> '..').join '/'\n\n            @push \"#### #{\n              matches[1]\n            } hook [`#{\n              matches[2]\n            }`](#{\n              backpath\n            }/hooks##{\n              matches[2].toLowerCase()\n            })\\n\"\n\n\n\n\nJust pass the comment through.\n\n\n          else\n\n            @push \"#{comment}\\n\"\n\n          @commenting = true\n\n\n\n\nEmit code.\n\n\n        else\n\n          @hanging = [] if @commenting\n          @push \"\\n```#{@fencing}\\n\" if @commenting or not @hasWrittenCode\n\n          if line.length is 0\n            @hanging.push '' unless @commenting\n          else\n            @push \"\\n\" for blank in @hanging\n            @hanging = []\n            @push \"#{line}\\n\"\n\n          @commenting = false\n          @hasWrittenCode = true\n\n        done()\n\n\n\n\nImplements hook \ntrussServerGruntConfig\n\n\n  registrar.registerHook 'trussServerGruntConfig', (gruntConfig, grunt) ->\n\n\n\n\nClean task.\n\n\n    gruntConfig.configureTask 'clean', 'truss-dox', [\n      'mkdocs.yml'\n      'docs/source'\n      'docs/{hooks,packages,todos}.md'\n      'gh-pages/*'\n      '!gh-pages/.git'\n      '!gh-pages/.gitignore'\n    ]\n\n\n\n\nMake sure the \nghh-pages\n directory exists.\n\n\n    gruntConfig.registerTask 'truss-dox:prepareDirectory', ->\n      grunt.file.mkdir 'gh-pages'\n\n\n\n\nGenerate dynamic documentation.\n\n\n    gruntConfig.registerTask 'truss-dox:dynamic', ->\n      done = @async()\n\n      {promise} = require \"#{__dirname}/dynamic\"\n      promise.then(done).catch (error) -> grunt.fail.fatal \"\n        Dynamic documentation generation failed: #{error.stack}\n      \", 1\n\n\n\n\nRun mkdocs to generate the documentation in \ngh-pages\n.\n\n\n    gruntConfig.registerTask 'truss-dox:mkdocs', ->\n      done = @async()\n\n      spawn('mkdocs', ['build']).on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Running `mkdocs build` failed', code\n\n    gruntConfig.registerTask 'truss-dox', [\n       'truss-dox:prepareDirectory'\n       'truss-dox:dynamic'\n       'truss-dox:mkdocs'\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/truss-dox/#documentation",
            "text": "Build the documentation in  gh-pages .  path = require 'path'\n\n{fork, spawn} = require 'child_process'\n\n{Transform} = require 'stream'\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  trussDoxSourceList    registrar.registerHook 'trussDoxSourceList', -> [\n    '*.coffee'\n    'src/**/*.coffee'\n    'config/default.settings.yml'\n    'packages/**/*.coffee'\n  ]  Implements hook  trussDoxSourceMarkdownTransform    registrar.registerHook 'trussDoxSourceMarkdownTransform', ->  Implement a transform stream to convert a source using hash comments to\nmarkdown. This applies to coffee and yaml files.      extensions: [\n      'coffee', 'litcoffee'\n      'yaml', 'yml'\n    ]\n    TransformClass: class HashCommentToMarkdown extends Transform\n\n      constructor: (@processor, @stream) ->\n        super null  Language to highlight in fenced code.          @fencing = if @stream.file.match /\\.(?:lit)?coffee$/\n          'coffeescript'\n        else if @stream.file.match /\\.ya?ml$/\n          'yaml'\n\n        @hanging = []\n        @hasWrittenCode = false\n        @commenting = false\n\n        @on 'finish', => @unshift \"```\\n\" if @hasWrittenCode and not @commenting\n\n      _transform: (chunk, encoding, done) ->\n\n        line = chunk.toString 'utf8'  Emit comment.          if '#'.charCodeAt(0) is line.trim().charCodeAt(0)  End fenced code.            @push \"```\\n\\n\" if @hasWrittenCode and not @commenting\n\n          comment = line.trim().substr 2  Link hook i(nvoc|mplement)ation comments to the hook page.            matches = comment.match /^#### (I(?:nvoke|mplements)) hook `([^`]+)`/\n          if matches\n\n            parts = path.dirname(@stream.file).split('/')\n            parts.push '' if 'index.coffee' isnt path.basename @stream.file\n            backpath = parts.map(-> '..').join '/'\n\n            @push \"#### #{\n              matches[1]\n            } hook [`#{\n              matches[2]\n            }`](#{\n              backpath\n            }/hooks##{\n              matches[2].toLowerCase()\n            })\\n\"  Just pass the comment through.            else\n\n            @push \"#{comment}\\n\"\n\n          @commenting = true  Emit code.          else\n\n          @hanging = [] if @commenting\n          @push \"\\n```#{@fencing}\\n\" if @commenting or not @hasWrittenCode\n\n          if line.length is 0\n            @hanging.push '' unless @commenting\n          else\n            @push \"\\n\" for blank in @hanging\n            @hanging = []\n            @push \"#{line}\\n\"\n\n          @commenting = false\n          @hasWrittenCode = true\n\n        done()  Implements hook  trussServerGruntConfig    registrar.registerHook 'trussServerGruntConfig', (gruntConfig, grunt) ->  Clean task.      gruntConfig.configureTask 'clean', 'truss-dox', [\n      'mkdocs.yml'\n      'docs/source'\n      'docs/{hooks,packages,todos}.md'\n      'gh-pages/*'\n      '!gh-pages/.git'\n      '!gh-pages/.gitignore'\n    ]  Make sure the  ghh-pages  directory exists.      gruntConfig.registerTask 'truss-dox:prepareDirectory', ->\n      grunt.file.mkdir 'gh-pages'  Generate dynamic documentation.      gruntConfig.registerTask 'truss-dox:dynamic', ->\n      done = @async()\n\n      {promise} = require \"#{__dirname}/dynamic\"\n      promise.then(done).catch (error) -> grunt.fail.fatal \"\n        Dynamic documentation generation failed: #{error.stack}\n      \", 1  Run mkdocs to generate the documentation in  gh-pages .      gruntConfig.registerTask 'truss-dox:mkdocs', ->\n      done = @async()\n\n      spawn('mkdocs', ['build']).on 'close', (code) ->\n        return done() if code is 0\n\n        grunt.fail.fatal 'Running `mkdocs build` failed', code\n\n    gruntConfig.registerTask 'truss-dox', [\n       'truss-dox:prepareDirectory'\n       'truss-dox:dynamic'\n       'truss-dox:mkdocs'\n    ]",
            "title": "Documentation"
        },
        {
            "location": "/source/packages/truss-frontend/client/require/",
            "text": "Require system for browser.\n\n\nImplement require in the spirit of NodeJS.\n\n\n\n\n\nResolve the module name.\n\n\n_resolveModuleName = (name, parentFilename) ->\n\n\n\n\nStrip \n/index\n from the end, if necessary.\n\n\n  checkModuleName = (name) ->\n    return name if _requires[name]?\n    return \"#{name}/index\" if _requires[\"#{name}/index\"]?\n\n\n\n\nAbsolute path match?\n\n\n  return checked if (checked = checkModuleName name)?\n\n\n\n\nResolve relative paths. We have to check methods on \npath\n. See below for\nmore.\n\n\n  path = _require 'path'\n  return checked if (checked = checkModuleName(\n    path.resolve(path.dirname(parentFilename), name).substr 1\n  ))? if path.dirname? and path.resolve?\n\n\n\n\nOops, nothing resolved...\n\n\n  throw new Error \"Cannot find module '#{name}'\"\n\n\n\n\nInternal require function. Uses the parent filename to resolve relative\npaths.\n\n\n_require = (name, parentFilename) ->\n\n\n\n\nModule inclusion is cached.\n\n\n  unless _requires[name = _resolveModuleName name, parentFilename].module?\n\n\n\n\nExtract the module function ahead of time, so we can set up\nmodule/exports and assign it to the old value. Setting this up ahead of\ntime avoids cycles.\n\n\n    f = _requires[name]\n    exports = {}\n    module = exports: exports\n    _requires[name] = module: module\n\n\n\n\nInclude \npath\n, you may observe that this is dangerous because we're\nwithin the require system itself. This is correct and we have to check\nfor \ndirname\n to ensure the object has been required and populated.\n\n\n    path = _require 'path'\n    __dirname = (path.dirname? name) ? ''\n    __filename = name\n\n\n\n\nExecute the top-level module function, passing in all of our objects.\n\n\n    f(\n      module, exports, (name) -> _require name, __filename\n      __dirname, __filename\n    )\n\n  _requires[name].module.exports\n\n\n\n\nExport require API.\n\n\n@require = (name) -> _require name, ''",
            "title": "require.coffee"
        },
        {
            "location": "/source/packages/truss-frontend/client/require/#require-system-for-browser",
            "text": "Implement require in the spirit of NodeJS.   Resolve the module name.  _resolveModuleName = (name, parentFilename) ->  Strip  /index  from the end, if necessary.    checkModuleName = (name) ->\n    return name if _requires[name]?\n    return \"#{name}/index\" if _requires[\"#{name}/index\"]?  Absolute path match?    return checked if (checked = checkModuleName name)?  Resolve relative paths. We have to check methods on  path . See below for\nmore.    path = _require 'path'\n  return checked if (checked = checkModuleName(\n    path.resolve(path.dirname(parentFilename), name).substr 1\n  ))? if path.dirname? and path.resolve?  Oops, nothing resolved...    throw new Error \"Cannot find module '#{name}'\"  Internal require function. Uses the parent filename to resolve relative\npaths.  _require = (name, parentFilename) ->  Module inclusion is cached.    unless _requires[name = _resolveModuleName name, parentFilename].module?  Extract the module function ahead of time, so we can set up\nmodule/exports and assign it to the old value. Setting this up ahead of\ntime avoids cycles.      f = _requires[name]\n    exports = {}\n    module = exports: exports\n    _requires[name] = module: module  Include  path , you may observe that this is dangerous because we're\nwithin the require system itself. This is correct and we have to check\nfor  dirname  to ensure the object has been required and populated.      path = _require 'path'\n    __dirname = (path.dirname? name) ? ''\n    __filename = name  Execute the top-level module function, passing in all of our objects.      f(\n      module, exports, (name) -> _require name, __filename\n      __dirname, __filename\n    )\n\n  _requires[name].module.exports  Export require API.  @require = (name) -> _require name, ''",
            "title": "Require system for browser."
        },
        {
            "location": "/source/packages/truss-frontend/",
            "text": "Front-end system\n\n\nFront-end abstraction: respond to client, render response, etc.\n\n\npath = require 'path'\n\n_ = require 'lodash'\ncheerio = require 'cheerio'\n\npkgman = require 'pkgman'\n\nconfig = require 'config'\n{Config} = config\n\nassets = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \ntrussFrontendAssetsMiddleware\n\n\n  registrar.registerHook 'trussFrontendAssetsMiddleware', ->\n\n    label: 'Modules'\n    middleware: [\n\n      (req, assets, next) ->\n\n\n\n\nConfig script.\n\n\n        clientConfig = new Config()\n\n\n\n\nGather client-side packages\n\n\n        packagesLists = pkgman.invokeFlat 'trussFrontendPackageList', req\n        packageList = _.flatten packagesLists\n\n\n\n\nUse package list to build client package configuration.\n\n\n        clientPackageConfig = new Config()\n        for path in pkgman.packagesImplementing 'trussFrontendPackageConfig'\n          clientPackageConfig.set(\n            path.replace /\\//g, ':'\n            pkgman.invokePackage path, 'trussFrontendPackageConfig', req\n          )\n\n        clientConfig.set 'packageList', config.get 'packageList'\n        clientConfig.set 'packageConfig', clientPackageConfig.toJSON()\n\n\n\n\nAssign the config variable.\n\n\n        assets.scripts.push\n          type: 'inline'\n          data: \"window.__trussConfig = #{\n            JSON.stringify clientConfig\n          }\"\n\n\n\n\nModules.\n\n\n        if 'production' is config.get 'NODE_ENV'\n          assets.scripts.push '/frontend/modules.min.js'\n        else\n          assets.scripts.push '/frontend/modules.js'\n\n\n\n\nServe livereload script if we aren't running in production mode.\n\n\n        unless 'production' is config.get 'NODE_ENV'\n          [hostname] = config.get('packageConfig:truss-http:hostname').split ':'\n          assets.scripts.push \"http://#{hostname}:35729/livereload.js\"\n\n        next()\n\n    ]\n\n\n\n\nImplements hook \ntrussFrontendPackageTasks\n\n\n  registrar.registerHook 'trussFrontendPackageTasks', (gruntConfig, grunt) ->\n\n\n\n\nWatch rule.\n\n\n    gruntConfig.configureTask 'watch', 'truss-frontend-truss-frontend', {\n      files: [\"packages/truss-frontend/client/require.coffee\"]\n      tasks: ['build:truss-frontend']\n      options: livereload: true\n    }\n\n\n\n\nBuild the require stub out-of-band, it shouldn't be included as a\nregular client module.\n\n\n    gruntConfig.configureTask 'coffee', \"truss-frontend-truss-frontend\", files: [\n      src: \"packages/truss-frontend/client/require.coffee\"\n      dest: 'build/js/client/require.js'\n    ]\n\n    return 'newer:coffee:truss-frontend-truss-frontend'\n\n\n\n\nImplements hook \ntrussServerGruntConfig\n\n\n  registrar.registerHook 'trussServerGruntConfig', (gruntConfig, grunt) ->\n\n\n\n\nCleaning rules.\n\n\n    gruntConfig.configureTask 'clean', 'truss-frontend', ['build', 'frontend']\n\n\n\n\nBuild each package's frontend tasks.\n\n\n    packageTasks = []\n    for pkg in pkgman.packageList()\n\n      tasks = if pkgman.packageImplements pkg, 'trussFrontendPackageTasks'\n        pkgman.invokePackage(\n          pkg, 'trussFrontendPackageTasks', gruntConfig, grunt\n        )\n\n      else\n\n\n\n\nWatch rules.\n\n\n        gruntConfig.configureTask 'watch', \"truss-frontend-#{pkg}\", {\n          files: [\"#{pkgman.packagePath pkg}/client/**/*.coffee\"]\n          tasks: ['build:truss-frontend']\n          options: livereload: true\n        }\n\n\n\n\nCompilation rules.\n\n\n        gruntConfig.configureTask 'coffee', \"truss-frontend-#{pkg}\", files: [\n          src: \"#{pkgman.packagePath pkg}/client/**/*.coffee\"\n          dest: 'build/js/client/raw'\n          expand: true\n          ext: '.js'\n        ]\n\n        \"newer:coffee:truss-frontend-#{pkg}\"\n\n      gruntConfig.registerTask 'truss-frontend-packages', tasks\n\n\n\n\nBrowserify modules.\n\n\n    gruntConfig.configureTask 'browserify', 'truss-node-path', {\n      src: ['node_modules/path-browserify/index.js']\n      dest: 'build/js/client/raw/path.js'\n      options: browserifyOptions: standalone: 'path'\n    }\n    gruntConfig.registerTask 'truss-frontend-browserify', [\n      'newer:browserify:truss-node-path'\n    ]\n\n\n\n\nWrap all modules with the require function.\n\n\n    gruntConfig.configureTask(\n      'wrap', 'truss-frontend'\n\n      files: [\n        src: [\n          'build/js/client/raw/**/*.js'\n        ]\n        dest: 'build/js/client/modules-raw.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: (filepath) ->\n\n\n\n\nSlice past the number of slashes in \nbuild/js/client/raw\n.\n\n\n          modulePath = filepath.split('/').slice(4).join '/'\n\n\n\n\nLittle acrobatics to handle root-level paths.\n\n\n          dirname = path.dirname modulePath\n          if '.' is dirname = path.dirname modulePath\n            dirname = ''\n          else\n            dirname += '/'\n          basename = path.basename modulePath, path.extname modulePath\n\n          [\n            \"\"\"\n_requires['#{\n  dirname\n}#{\n  basename\n}'] = function(module, exports, require, __dirname, __filename) {\n\n\n\"\"\"\n            \"\"\"\n\n};\n\n\n\"\"\"\n          ]\n\n    )\n\n\n\n\nConcatenate the require stub to the bottom of the modules.\n\n\n    gruntConfig.configureTask 'concat', 'truss-frontend', files: [\n      src: [\n        'build/js/client/modules-raw.js'\n        'build/js/client/require.js'\n      ]\n      dest: 'build/js/client/modules-raw-with-require.js'\n    ]\n\n\n\n\nWrap the whole thing in an IIFE and define the _requires object to hold\nall module implementations.\n\n\n    gruntConfig.configureTask(\n      'wrap', 'truss-frontend-modules'\n\n      files: [\n        src: [\n          'build/js/client/modules-raw-with-require.js'\n        ]\n        dest: 'frontend/modules.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: [\n          '(function() {\\n\\n  var _requires = {};\\n\\n\\n'\n          '\\n\\n})();\\n\\n'\n        ]\n\n    )\n\n\n\n\nMinimize the module sources.\n\n\n    gruntConfig.configureTask 'uglify', 'truss-frontend', files: [\n      src: [\n        'frontend/modules.js'\n      ]\n      dest: 'frontend/modules.min.js'\n    ]\n\n    gruntConfig.registerTask 'production', ['uglify:truss-frontend']\n\n    gruntConfig.registerTask 'build:truss-frontend', [\n      'truss-frontend-packages'\n      'truss-frontend-browserify'\n      'newer:wrap:truss-frontend'\n      'newer:concat:truss-frontend'\n      'newer:wrap:truss-frontend-modules'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:truss-frontend']\n\n    gruntConfig.loadNpmTasks [\n      'grunt-browserify'\n      'grunt-contrib-clean'\n      'grunt-contrib-coffee'\n      'grunt-contrib-concat'\n      'grunt-contrib-uglify'\n      'grunt-contrib-watch'\n      'grunt-newer'\n      'grunt-wrap'\n    ]\n\n\n\n\nImplements hook \ntrussFrontendPackageConfig\n\n\n  registrar.registerHook 'trussFrontendPackageConfig', ->\n\n\n\n\nImplements hook \ntrussFrontendPackageList\n\n\n  registrar.registerHook 'trussFrontendPackageList', (path) ->\n\n\n\n\nImplements hook \ntrussHttpServerRoutes\n\n\n  registrar.registerHook 'config', 'trussHttpServerRoutes', -> [\n    path: '/frontend/modules.js'\n    receiver: (req, res, next) -> require('fs').createReadStream(\n      \"#{config.get 'path'}/frontend/modules.js\"\n    ).pipe res\n  ]\n\n\n\n\nImplements hook \ntrussHttpServerRequestMiddleware\n\n\n  registrar.registerHook 'trussHttpServerRequestMiddleware', ->\n\n    debug = require('debug') 'truss-silly:assets:middleware'\n\n    middleware = require 'middleware'\n\n\n\n\nInvoke hook \ntrussFrontendAssetsMiddleware\n\n\n    debug '- Loading asset middleware...'\n\n    assetsMiddleware = middleware.fromConfig 'truss-frontend:assetsMiddleware'\n\n    debug '- Asset middleware loaded.'\n\n    label: 'Serve frontend'\n\n    middleware: [\n\n      (req, res, next) ->\n\n        $ = res.$ = cheerio.load '''\n<!doctype html><html><head></head><body></body></html>\n'''\n\n\n\n\nAdd mobile-first tags.\n\n\n        head = $('head')\n        head.append $('<meta>').attr 'charset', 'utf-8'\n        head.append $('<meta>').attr(\n          name: 'viewport'\n          content: 'width=device-width, initial-scale=1.0'\n        )\n\n\n\n\nGather assets.\n\n\n        body = $('body')\n        assets = scripts: [], styleSheets: []\n        assetsMiddleware.dispatch req, assets, (error) ->\n          return next error if error?\n\n\n\n\nInject scripts.\n\n\n          for script in assets.scripts\n            script = type: 'src', data: script if _.isString script\n\n            switch script.type\n\n              when 'src'\n                body.append $('<script>').attr(\n                  'src', script.data\n                  type: 'text/javascript'\n                )\n\n              when 'inline'\n                body.append $('<script>').html script.data\n\n\n\n\nInject CSS.\n\n\n          for styleSheet in assets.styleSheets\n            body.append $('<style>').attr(\n              href: styleSheet\n              rel: 'stylesheet'\n            )\n\n\n\n\nBuild the HTML and serve it.\n\n\n          res.delivery = res.$.html()\n          next()\n\n    ]\n\n\n\n\nImplements hook \ntrussServerPackageConfig\n\n\n  registrar.registerHook 'trussServerPackageConfig', ->\n\n    assetsMiddleware: [\n      'truss-frontend'\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/truss-frontend/#front-end-system",
            "text": "Front-end abstraction: respond to client, render response, etc.  path = require 'path'\n\n_ = require 'lodash'\ncheerio = require 'cheerio'\n\npkgman = require 'pkgman'\n\nconfig = require 'config'\n{Config} = config\n\nassets = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  trussFrontendAssetsMiddleware    registrar.registerHook 'trussFrontendAssetsMiddleware', ->\n\n    label: 'Modules'\n    middleware: [\n\n      (req, assets, next) ->  Config script.          clientConfig = new Config()  Gather client-side packages          packagesLists = pkgman.invokeFlat 'trussFrontendPackageList', req\n        packageList = _.flatten packagesLists  Use package list to build client package configuration.          clientPackageConfig = new Config()\n        for path in pkgman.packagesImplementing 'trussFrontendPackageConfig'\n          clientPackageConfig.set(\n            path.replace /\\//g, ':'\n            pkgman.invokePackage path, 'trussFrontendPackageConfig', req\n          )\n\n        clientConfig.set 'packageList', config.get 'packageList'\n        clientConfig.set 'packageConfig', clientPackageConfig.toJSON()  Assign the config variable.          assets.scripts.push\n          type: 'inline'\n          data: \"window.__trussConfig = #{\n            JSON.stringify clientConfig\n          }\"  Modules.          if 'production' is config.get 'NODE_ENV'\n          assets.scripts.push '/frontend/modules.min.js'\n        else\n          assets.scripts.push '/frontend/modules.js'  Serve livereload script if we aren't running in production mode.          unless 'production' is config.get 'NODE_ENV'\n          [hostname] = config.get('packageConfig:truss-http:hostname').split ':'\n          assets.scripts.push \"http://#{hostname}:35729/livereload.js\"\n\n        next()\n\n    ]  Implements hook  trussFrontendPackageTasks    registrar.registerHook 'trussFrontendPackageTasks', (gruntConfig, grunt) ->  Watch rule.      gruntConfig.configureTask 'watch', 'truss-frontend-truss-frontend', {\n      files: [\"packages/truss-frontend/client/require.coffee\"]\n      tasks: ['build:truss-frontend']\n      options: livereload: true\n    }  Build the require stub out-of-band, it shouldn't be included as a\nregular client module.      gruntConfig.configureTask 'coffee', \"truss-frontend-truss-frontend\", files: [\n      src: \"packages/truss-frontend/client/require.coffee\"\n      dest: 'build/js/client/require.js'\n    ]\n\n    return 'newer:coffee:truss-frontend-truss-frontend'  Implements hook  trussServerGruntConfig    registrar.registerHook 'trussServerGruntConfig', (gruntConfig, grunt) ->  Cleaning rules.      gruntConfig.configureTask 'clean', 'truss-frontend', ['build', 'frontend']  Build each package's frontend tasks.      packageTasks = []\n    for pkg in pkgman.packageList()\n\n      tasks = if pkgman.packageImplements pkg, 'trussFrontendPackageTasks'\n        pkgman.invokePackage(\n          pkg, 'trussFrontendPackageTasks', gruntConfig, grunt\n        )\n\n      else  Watch rules.          gruntConfig.configureTask 'watch', \"truss-frontend-#{pkg}\", {\n          files: [\"#{pkgman.packagePath pkg}/client/**/*.coffee\"]\n          tasks: ['build:truss-frontend']\n          options: livereload: true\n        }  Compilation rules.          gruntConfig.configureTask 'coffee', \"truss-frontend-#{pkg}\", files: [\n          src: \"#{pkgman.packagePath pkg}/client/**/*.coffee\"\n          dest: 'build/js/client/raw'\n          expand: true\n          ext: '.js'\n        ]\n\n        \"newer:coffee:truss-frontend-#{pkg}\"\n\n      gruntConfig.registerTask 'truss-frontend-packages', tasks  Browserify modules.      gruntConfig.configureTask 'browserify', 'truss-node-path', {\n      src: ['node_modules/path-browserify/index.js']\n      dest: 'build/js/client/raw/path.js'\n      options: browserifyOptions: standalone: 'path'\n    }\n    gruntConfig.registerTask 'truss-frontend-browserify', [\n      'newer:browserify:truss-node-path'\n    ]  Wrap all modules with the require function.      gruntConfig.configureTask(\n      'wrap', 'truss-frontend'\n\n      files: [\n        src: [\n          'build/js/client/raw/**/*.js'\n        ]\n        dest: 'build/js/client/modules-raw.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: (filepath) ->  Slice past the number of slashes in  build/js/client/raw .            modulePath = filepath.split('/').slice(4).join '/'  Little acrobatics to handle root-level paths.            dirname = path.dirname modulePath\n          if '.' is dirname = path.dirname modulePath\n            dirname = ''\n          else\n            dirname += '/'\n          basename = path.basename modulePath, path.extname modulePath\n\n          [\n            \"\"\"\n_requires['#{\n  dirname\n}#{\n  basename\n}'] = function(module, exports, require, __dirname, __filename) {\n\n\n\"\"\"\n            \"\"\"\n\n};\n\n\n\"\"\"\n          ]\n\n    )  Concatenate the require stub to the bottom of the modules.      gruntConfig.configureTask 'concat', 'truss-frontend', files: [\n      src: [\n        'build/js/client/modules-raw.js'\n        'build/js/client/require.js'\n      ]\n      dest: 'build/js/client/modules-raw-with-require.js'\n    ]  Wrap the whole thing in an IIFE and define the _requires object to hold\nall module implementations.      gruntConfig.configureTask(\n      'wrap', 'truss-frontend-modules'\n\n      files: [\n        src: [\n          'build/js/client/modules-raw-with-require.js'\n        ]\n        dest: 'frontend/modules.js'\n      ]\n      options:\n        indent: '  '\n        wrapper: [\n          '(function() {\\n\\n  var _requires = {};\\n\\n\\n'\n          '\\n\\n})();\\n\\n'\n        ]\n\n    )  Minimize the module sources.      gruntConfig.configureTask 'uglify', 'truss-frontend', files: [\n      src: [\n        'frontend/modules.js'\n      ]\n      dest: 'frontend/modules.min.js'\n    ]\n\n    gruntConfig.registerTask 'production', ['uglify:truss-frontend']\n\n    gruntConfig.registerTask 'build:truss-frontend', [\n      'truss-frontend-packages'\n      'truss-frontend-browserify'\n      'newer:wrap:truss-frontend'\n      'newer:concat:truss-frontend'\n      'newer:wrap:truss-frontend-modules'\n    ]\n\n    gruntConfig.registerTask 'build', ['build:truss-frontend']\n\n    gruntConfig.loadNpmTasks [\n      'grunt-browserify'\n      'grunt-contrib-clean'\n      'grunt-contrib-coffee'\n      'grunt-contrib-concat'\n      'grunt-contrib-uglify'\n      'grunt-contrib-watch'\n      'grunt-newer'\n      'grunt-wrap'\n    ]  Implements hook  trussFrontendPackageConfig    registrar.registerHook 'trussFrontendPackageConfig', ->  Implements hook  trussFrontendPackageList    registrar.registerHook 'trussFrontendPackageList', (path) ->  Implements hook  trussHttpServerRoutes    registrar.registerHook 'config', 'trussHttpServerRoutes', -> [\n    path: '/frontend/modules.js'\n    receiver: (req, res, next) -> require('fs').createReadStream(\n      \"#{config.get 'path'}/frontend/modules.js\"\n    ).pipe res\n  ]  Implements hook  trussHttpServerRequestMiddleware    registrar.registerHook 'trussHttpServerRequestMiddleware', ->\n\n    debug = require('debug') 'truss-silly:assets:middleware'\n\n    middleware = require 'middleware'  Invoke hook  trussFrontendAssetsMiddleware      debug '- Loading asset middleware...'\n\n    assetsMiddleware = middleware.fromConfig 'truss-frontend:assetsMiddleware'\n\n    debug '- Asset middleware loaded.'\n\n    label: 'Serve frontend'\n\n    middleware: [\n\n      (req, res, next) ->\n\n        $ = res.$ = cheerio.load '''\n<!doctype html><html><head></head><body></body></html>\n'''  Add mobile-first tags.          head = $('head')\n        head.append $('<meta>').attr 'charset', 'utf-8'\n        head.append $('<meta>').attr(\n          name: 'viewport'\n          content: 'width=device-width, initial-scale=1.0'\n        )  Gather assets.          body = $('body')\n        assets = scripts: [], styleSheets: []\n        assetsMiddleware.dispatch req, assets, (error) ->\n          return next error if error?  Inject scripts.            for script in assets.scripts\n            script = type: 'src', data: script if _.isString script\n\n            switch script.type\n\n              when 'src'\n                body.append $('<script>').attr(\n                  'src', script.data\n                  type: 'text/javascript'\n                )\n\n              when 'inline'\n                body.append $('<script>').html script.data  Inject CSS.            for styleSheet in assets.styleSheets\n            body.append $('<style>').attr(\n              href: styleSheet\n              rel: 'stylesheet'\n            )  Build the HTML and serve it.            res.delivery = res.$.html()\n          next()\n\n    ]  Implements hook  trussServerPackageConfig    registrar.registerHook 'trussServerPackageConfig', ->\n\n    assetsMiddleware: [\n      'truss-frontend'\n    ]",
            "title": "Front-end system"
        },
        {
            "location": "/source/packages/truss-http/abstract/",
            "text": "Abstract HTTP server\n\n\nAn abstract HTTP server interface.\n\n\n_ = require 'lodash'\nPromise = require 'bluebird'\n\nconfig = require 'config'\nmiddleware = require 'middleware'\npkgman = require 'pkgman'\n\nhttpDebug = require('debug') 'truss:http'\nhttpMiddlewareDebug = require('debug') 'truss-silly:http:middleware'\n\n\n\n\nTrussHttpServerAbstract\n\n\nAn abstract interface to be implemented by an HTTP server (e.g.\n\nExpress\n).\n\n\nmodule.exports = class TrussHttpServerAbstract\n\n\n\n\nconstructor\n\n\nCreate the server.\n\n\n  constructor: ->\n\n    @_requestMiddleware = null\n    @_routes = []\n\n\n\n\nTrussHttpServerAbstract#addRoute\n\n\nAdd HTTP routes.\n\n\n  addRoute: (route) -> @_routes.push route\n\n\n\n\nTrussHttpServerAbstract#listen\n\n\nListen for HTTP connections.\n\n\n  listen: ->\n    self = this\n\n\n\n\nPromise to be resolved when listening starts.\n\n\n    promise = new Promise (resolve, reject) ->\n\n      do tryListener = -> self.listener().done(\n        resolve\n\n        (error) ->\n          return reject error unless 'EADDRINUSE' is error.code\n\n          httpDebug 'HTTP listen target in use... retrying in 2 seconds'\n          setTimeout tryListener, 2000\n\n      )\n\n\n\n\nOnce listening, log about it.\n\n\n    promise.then ->\n\n      listenTarget = config.get 'packageConfig:truss-http:listenTarget'\n      listenTarget = [listenTarget] unless Array.isArray listenTarget\n\n      if listenTarget.length is 1\n\n        target = listenTarget[0]\n        target = \"port #{target}\" if _.isNumber target\n\n      else\n\n        target = \"#{listenTarget[1]}:#{listenTarget[0]}\"\n\n      httpDebug \"Shrub HTTP server up and running on #{target}!\"\n\n\n\n\nPost a message about it.\n\n\n      global?.postMessage?(\n        type: 'truss-http-server-start'\n        listenTarget: listenTarget\n      )\n\n    return promise\n\n\n\n\nTrussHttpServerAbstract#registerMiddleware\n\n\nGather and initialize HTTP middleware.\n\n\n  registerMiddleware: ->\n\n    httpMiddlewareDebug '- Loading HTTP middleware...'\n\n    httpMiddleware = config.get(\n      'packageConfig:truss-http:requestMiddleware'\n    ).concat()\n\n\n\n\nMake absolutely sure the requests are finalized.\n\n\n    httpMiddleware.push 'truss-http'\n\n\n\n\nInvoke hook \ntrussHttpServerRequestMiddleware\n\n\nInvoked every time an HTTP connection is established.\n\n\n    @_requestMiddleware = middleware.fromHook(\n      'trussHttpServerRequestMiddleware', httpMiddleware, this\n    )\n\n    httpMiddlewareDebug '- HTTP middleware loaded.'\n\n\n\n\nEnsure any subclass implements these \"pure virtual\" methods.\n\n\n  [\n    'listener', 'server', 'trustProxy'\n  ].forEach (method) -> TrussHttpServerAbstract::[method] = ->\n    throw new ReferenceError(\n      \"TrussHttpServerAbstract::#{method} is a pure virtual method!\"\n    )",
            "title": "abstract.coffee"
        },
        {
            "location": "/source/packages/truss-http/abstract/#abstract-http-server",
            "text": "An abstract HTTP server interface.  _ = require 'lodash'\nPromise = require 'bluebird'\n\nconfig = require 'config'\nmiddleware = require 'middleware'\npkgman = require 'pkgman'\n\nhttpDebug = require('debug') 'truss:http'\nhttpMiddlewareDebug = require('debug') 'truss-silly:http:middleware'",
            "title": "Abstract HTTP server"
        },
        {
            "location": "/source/packages/truss-http/abstract/#trusshttpserverabstract",
            "text": "An abstract interface to be implemented by an HTTP server (e.g. Express ).  module.exports = class TrussHttpServerAbstract",
            "title": "TrussHttpServerAbstract"
        },
        {
            "location": "/source/packages/truss-http/abstract/#constructor",
            "text": "Create the server.    constructor: ->\n\n    @_requestMiddleware = null\n    @_routes = []",
            "title": "constructor"
        },
        {
            "location": "/source/packages/truss-http/abstract/#trusshttpserverabstractaddroute",
            "text": "Add HTTP routes.    addRoute: (route) -> @_routes.push route",
            "title": "TrussHttpServerAbstract#addRoute"
        },
        {
            "location": "/source/packages/truss-http/abstract/#trusshttpserverabstractlisten",
            "text": "Listen for HTTP connections.    listen: ->\n    self = this  Promise to be resolved when listening starts.      promise = new Promise (resolve, reject) ->\n\n      do tryListener = -> self.listener().done(\n        resolve\n\n        (error) ->\n          return reject error unless 'EADDRINUSE' is error.code\n\n          httpDebug 'HTTP listen target in use... retrying in 2 seconds'\n          setTimeout tryListener, 2000\n\n      )  Once listening, log about it.      promise.then ->\n\n      listenTarget = config.get 'packageConfig:truss-http:listenTarget'\n      listenTarget = [listenTarget] unless Array.isArray listenTarget\n\n      if listenTarget.length is 1\n\n        target = listenTarget[0]\n        target = \"port #{target}\" if _.isNumber target\n\n      else\n\n        target = \"#{listenTarget[1]}:#{listenTarget[0]}\"\n\n      httpDebug \"Shrub HTTP server up and running on #{target}!\"  Post a message about it.        global?.postMessage?(\n        type: 'truss-http-server-start'\n        listenTarget: listenTarget\n      )\n\n    return promise",
            "title": "TrussHttpServerAbstract#listen"
        },
        {
            "location": "/source/packages/truss-http/abstract/#trusshttpserverabstractregistermiddleware",
            "text": "Gather and initialize HTTP middleware.    registerMiddleware: ->\n\n    httpMiddlewareDebug '- Loading HTTP middleware...'\n\n    httpMiddleware = config.get(\n      'packageConfig:truss-http:requestMiddleware'\n    ).concat()  Make absolutely sure the requests are finalized.      httpMiddleware.push 'truss-http'  Invoke hook  trussHttpServerRequestMiddleware  Invoked every time an HTTP connection is established.      @_requestMiddleware = middleware.fromHook(\n      'trussHttpServerRequestMiddleware', httpMiddleware, this\n    )\n\n    httpMiddlewareDebug '- HTTP middleware loaded.'  Ensure any subclass implements these \"pure virtual\" methods.    [\n    'listener', 'server', 'trustProxy'\n  ].forEach (method) -> TrussHttpServerAbstract::[method] = ->\n    throw new ReferenceError(\n      \"TrussHttpServerAbstract::#{method} is a pure virtual method!\"\n    )",
            "title": "TrussHttpServerAbstract#registerMiddleware"
        },
        {
            "location": "/source/packages/truss-http/",
            "text": "HTTP server\n\n\nManage HTTP connections.\n\n\n_ = require 'lodash'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'truss:http'\nerrors = require 'errors'\n\nhttpDebugSilly = require('debug') 'truss-silly:http'\n\nhttpServer = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \ntrussServerBootstrapMiddleware\n\n\n  registrar.registerHook 'trussServerBootstrapMiddleware', ->\n\n    label: 'Bootstrap HTTP server'\n    middleware: [\n\n      (next) ->\n\n        {module, listenTarget} = config.get 'packageConfig:truss-http'\n\n\n\n\nSpin up the HTTP server, and initialize it.\n\n\n        Server = require module\n        httpServer = new Server()\n\n\n\n\nCompute the hostname if it isn't explicitly set.\n\n\n        unless config.get 'packageConfig:truss-http:hostname'\n\n          listenTarget = config.get 'packageConfig:truss-http:listenTarget'\n          listenTarget = [listenTarget] unless Array.isArray listenTarget\n\n          if listenTarget.length is 1\n\n            hostname = listenTarget[0]\n            hostname = \"localhost:#{hostname}\" if _.isNumber hostname\n\n          else\n\n            hostname = \"#{listenTarget[1]}:#{listenTarget[0]}\"\n\n          config.set 'packageConfig:truss-http:hostname', hostname\n\n\n\n\nMark proxies as trusted addresses.\n\n\n        httpServer.trustProxy(\n          config.get 'packageConfig:truss-http:trustedProxies'\n        )\n\n\n\n\nInvoke hook \ntrussHttpServerRoutes\n\n\n        httpDebugSilly '- Registering routes...'\n        for routeList in pkgman.invokeFlat 'trussHttpServerRoutes', httpServer\n          for route in routeList\n            route.verb ?= 'get'\n            httpDebugSilly \"- - #{route.verb.toUpperCase()} #{route.path}\"\n            httpServer.addRoute route\n        httpDebugSilly '- Routes registered.'\n\n\n\n\nRegister middleware.\n\n\n        httpServer.registerMiddleware()\n\n\n\n\nListen...\n\n\n        httpServer.listen().then(-> next()).catch next\n\n    ]\n\n\n\n\nImplements hook \ntrussHttpServerRequestMiddleware\n\n\n  registrar.registerHook 'trussHttpServerRequestMiddleware', (http) ->\n\n    label: 'Finalize HTTP request'\n    middleware: [\n\n      (req, res, next) ->\n\n\n\n\nIf there's something to deliver, do it.\n\n\n        return res.end res.delivery if res.delivery?\n\n\n\n\nNothing specified for delivery? Return a 'not implemented' error.\n\n\n        res.writeHead 501\n        res.end '<h1>501 Not Implemented</h1>'\n\n      (error, req, res, next) ->\n\n\n\n\nEmit error.\n\n\n        res.writeHead code = error.code ? 500\n        res.end \"<h1>#{\n          code\n        } Internal Server Error: #{\n          errors.message error\n        }</h1>\"\n\n    ]\n\n\n\n\nImplements hook \ntrussServerPackageConfig\n\n\n  registrar.registerHook 'trussServerPackageConfig', ->\n\n\n\n\nModule implementing the HTTP server.\n\n\n    module: 'truss-http/stub/instance'\n\n\n\n\nThe server hostname. Derived from \nlistenTarget\n if not explicitly set.\n\n\n    hostname: ''\n\n\n\n\nMiddleware stack run for every request.\n\n\n    requestMiddleware: []\n\n\n\n\nWhere the server will be listening. This can be:\n\n\n\n\nA numeric port.\n  \nlistenTarget: 4201\n\n\nAn array where the port is the first element, and the host is the\n  second element: \nlistenTarget: [4201, '0.0.0.0']\n\n\n\n\n    listenTarget: 4201\n\n\n\n\nIt's not uncommon to run your HTTP application behind a reverse proxy.\nBy default, we'll provide both ipv4 and embedded ipv6 addresses for\nlocalhost. If a reverse proxy is running on the same machine you will\ntherefore automatically see the correct IP address in \nreq.normalizedIp\n\nwhich is provided to HTTP requests.\n\n\n    trustedProxies: [\n      '127.0.0.1'\n      '::ffff:127.0.0.1'\n    ]\n\n  registrar.recur [\n    'stub'\n  ]\n\nexports.server = -> httpServer",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/truss-http/#http-server",
            "text": "Manage HTTP connections.  _ = require 'lodash'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'truss:http'\nerrors = require 'errors'\n\nhttpDebugSilly = require('debug') 'truss-silly:http'\n\nhttpServer = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  trussServerBootstrapMiddleware    registrar.registerHook 'trussServerBootstrapMiddleware', ->\n\n    label: 'Bootstrap HTTP server'\n    middleware: [\n\n      (next) ->\n\n        {module, listenTarget} = config.get 'packageConfig:truss-http'  Spin up the HTTP server, and initialize it.          Server = require module\n        httpServer = new Server()  Compute the hostname if it isn't explicitly set.          unless config.get 'packageConfig:truss-http:hostname'\n\n          listenTarget = config.get 'packageConfig:truss-http:listenTarget'\n          listenTarget = [listenTarget] unless Array.isArray listenTarget\n\n          if listenTarget.length is 1\n\n            hostname = listenTarget[0]\n            hostname = \"localhost:#{hostname}\" if _.isNumber hostname\n\n          else\n\n            hostname = \"#{listenTarget[1]}:#{listenTarget[0]}\"\n\n          config.set 'packageConfig:truss-http:hostname', hostname  Mark proxies as trusted addresses.          httpServer.trustProxy(\n          config.get 'packageConfig:truss-http:trustedProxies'\n        )  Invoke hook  trussHttpServerRoutes          httpDebugSilly '- Registering routes...'\n        for routeList in pkgman.invokeFlat 'trussHttpServerRoutes', httpServer\n          for route in routeList\n            route.verb ?= 'get'\n            httpDebugSilly \"- - #{route.verb.toUpperCase()} #{route.path}\"\n            httpServer.addRoute route\n        httpDebugSilly '- Routes registered.'  Register middleware.          httpServer.registerMiddleware()  Listen...          httpServer.listen().then(-> next()).catch next\n\n    ]  Implements hook  trussHttpServerRequestMiddleware    registrar.registerHook 'trussHttpServerRequestMiddleware', (http) ->\n\n    label: 'Finalize HTTP request'\n    middleware: [\n\n      (req, res, next) ->  If there's something to deliver, do it.          return res.end res.delivery if res.delivery?  Nothing specified for delivery? Return a 'not implemented' error.          res.writeHead 501\n        res.end '<h1>501 Not Implemented</h1>'\n\n      (error, req, res, next) ->  Emit error.          res.writeHead code = error.code ? 500\n        res.end \"<h1>#{\n          code\n        } Internal Server Error: #{\n          errors.message error\n        }</h1>\"\n\n    ]  Implements hook  trussServerPackageConfig    registrar.registerHook 'trussServerPackageConfig', ->  Module implementing the HTTP server.      module: 'truss-http/stub/instance'  The server hostname. Derived from  listenTarget  if not explicitly set.      hostname: ''  Middleware stack run for every request.      requestMiddleware: []  Where the server will be listening. This can be:   A numeric port.\n   listenTarget: 4201  An array where the port is the first element, and the host is the\n  second element:  listenTarget: [4201, '0.0.0.0']       listenTarget: 4201  It's not uncommon to run your HTTP application behind a reverse proxy.\nBy default, we'll provide both ipv4 and embedded ipv6 addresses for\nlocalhost. If a reverse proxy is running on the same machine you will\ntherefore automatically see the correct IP address in  req.normalizedIp \nwhich is provided to HTTP requests.      trustedProxies: [\n      '127.0.0.1'\n      '::ffff:127.0.0.1'\n    ]\n\n  registrar.recur [\n    'stub'\n  ]\n\nexports.server = -> httpServer",
            "title": "HTTP server"
        },
        {
            "location": "/source/packages/truss-http/stub/",
            "text": "exports.pkgmanRegister = (registrar) ->\n\n  registrar.recur [\n    'router'\n  ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/truss-http/stub/instance/",
            "text": "HTTP server stub implementation\n\n\nA barebones HT TP server implementation.\n\n\nhttp = require 'http'\n\nPromise = require 'bluebird'\n\nconfig = require 'config'\n\nTrussHttpServerAbstract = require '../abstract'\n\n\n\n\nTrussHttpServerStub\n\n\nA little HTTP stub. Just barely implementing the abstract Truss HTTP\nserver API.\n\n\nmodule.exports = class TrussHttpServerStub extends TrussHttpServerAbstract\n\n\n\n\nTrussHttpServerStub#constructor\n\n\n  constructor: ->\n    super\n\n    @_server = http.createServer()\n\n\n\n\nTrussHttpServerStub#listener\n\n\nListen for HTTP connections.\n\n\n  listener: ->\n    self = this\n\n    new Promise (resolve, reject) ->\n\n      self._server.on 'error', reject\n\n      self._server.once 'listening', ->\n        self._server.removeListener 'error', reject\n        resolve()\n\n\n\n\nBind to the listen target.\n\n\n      listenTarget = config.get 'packageConfig:truss-http:listenTarget'\n      listenTarget = [listenTarget] unless Array.isArray listenTarget\n      self._server.listen listenTarget...\n\n  registerMiddleware: ->\n    self = this\n\n    super\n\n\n\n\nInvoke the request middleware.\n\n\n    @_server.on 'request', (req, res) ->\n      self._requestMiddleware.dispatch req, res, ->\n\n  server: -> @_server\n\n  trustProxy: (proxyList) ->",
            "title": "instance.coffee"
        },
        {
            "location": "/source/packages/truss-http/stub/instance/#http-server-stub-implementation",
            "text": "A barebones HT TP server implementation.  http = require 'http'\n\nPromise = require 'bluebird'\n\nconfig = require 'config'\n\nTrussHttpServerAbstract = require '../abstract'",
            "title": "HTTP server stub implementation"
        },
        {
            "location": "/source/packages/truss-http/stub/instance/#trusshttpserverstub",
            "text": "A little HTTP stub. Just barely implementing the abstract Truss HTTP\nserver API.  module.exports = class TrussHttpServerStub extends TrussHttpServerAbstract",
            "title": "TrussHttpServerStub"
        },
        {
            "location": "/source/packages/truss-http/stub/instance/#trusshttpserverstubconstructor",
            "text": "constructor: ->\n    super\n\n    @_server = http.createServer()",
            "title": "TrussHttpServerStub#constructor"
        },
        {
            "location": "/source/packages/truss-http/stub/instance/#trusshttpserverstublistener",
            "text": "Listen for HTTP connections.    listener: ->\n    self = this\n\n    new Promise (resolve, reject) ->\n\n      self._server.on 'error', reject\n\n      self._server.once 'listening', ->\n        self._server.removeListener 'error', reject\n        resolve()  Bind to the listen target.        listenTarget = config.get 'packageConfig:truss-http:listenTarget'\n      listenTarget = [listenTarget] unless Array.isArray listenTarget\n      self._server.listen listenTarget...\n\n  registerMiddleware: ->\n    self = this\n\n    super  Invoke the request middleware.      @_server.on 'request', (req, res) ->\n      self._requestMiddleware.dispatch req, res, ->\n\n  server: -> @_server\n\n  trustProxy: (proxyList) ->",
            "title": "TrussHttpServerStub#listener"
        },
        {
            "location": "/source/packages/truss-http/stub/router/",
            "text": "exports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \ntrussHttpServerRequestMiddleware\n\n\n  registrar.registerHook 'trussHttpServerRequestMiddleware', (http) ->\n\n\n\n\nBuild a route lookup by path and verb.\n\n\n    routeLookup = {}\n    for route in http._routes\n      routeLookup ?= {}\n      routeLookup[route.path] ?= {}\n      routeLookup[route.path][route.verb.toLowerCase()] = route.receiver\n\n    label: 'HTTP routes'\n    middleware: [\n\n      (req, res, next) ->\n\n\n\n\nDispatch route if we find a path/verb match.\n\n\n        return next() unless routeLookup[req.url]\n        return next() unless routeLookup[req.url][req.method.toLowerCase()]\n        routeLookup[req.url][req.method.toLowerCase()] req, res, next\n\n    ]",
            "title": "router.coffee"
        },
        {
            "location": "/source/packages/truss-repl/",
            "text": "REPL\n\n\nRuns a REPL and allows packages to add values to its context.\n\n\nCoffeeScript = require 'coffee-script'\nfs = require 'fs'\nnet = require 'net'\nreplServer = require 'repl'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'truss:repl'\n\n\n\n\nThe socket server.\n\n\nserver = null\n\nexports.pkgmanRegister = (registrar) ->\n\n\n\n\nImplements hook \ntrussServerPackageConfig\n\n\n  registrar.registerHook 'trussServerPackageConfig', ->\n\n\n\n\nThe prompt display for REPL clients.\n\n\n    prompt: 'truss> '\n\n\n\n\nThe location of the socket.\n\n\n    socket: \"#{__dirname}/socket\"\n\n\n\n\nUse a CoffeeScript REPL?\n\n\n    useCoffee: true\n\n\n\n\nImplements hook \ntrussServerProcessExit\n\n\n  registrar.registerHook 'trussServerProcessExit', -> server?.close()\n\n\n\n\nImplements hook \ntrussServerBootstrapMiddleware\n\n\n  registrar.registerHook 'trussServerBootstrapMiddleware', ->\n\n    label: 'REPL'\n    middleware: [\n\n      (next) ->\n\n        settings = config.get 'packageConfig:truss-repl'\n\n        server = net.createServer (socket) ->\n\n\n\n\nInvoke hook \ntrussReplServerContext\n\n\n          pkgman.invoke 'trussReplServerContext', context = {}\n\n\n\n\nREPL server options.\n\n\n          opts =\n            prompt: settings.prompt\n            input: socket\n            output: socket\n            ignoreUndefined: true\n\n\n\n\nCoffeeScript?\n\n\n          if settings.useCoffee\n\n            opts.prompt = \"(coffee) #{settings.prompt}\"\n\n\n\n\nDefine our own eval function, using CoffeeScript.\n\n\n            opts.eval = (cmd, context, filename, callback) ->\n\n\n\n\nHandle blank lines correctly.\n\n\n              return callback null, undefined if cmd is '(\\n)'\n\n\n\n\nForward the input to CoffeeScript for evalulation.\n\n\n              try\n\n                callback null, CoffeeScript.eval(\n                  cmd\n                  sandbox: context\n                  filename: filename\n                )\n\n              catch error\n\n                callback error\n\n\n\n\nSpin up the server, inject the values from\n\ntrussReplServerContext\n, and prepare for later cleanup.\n\n\n          repl = replServer.start opts\n          repl.context[key] = value for key, value of context\n          repl.on 'exit', -> socket.end()\n\n\n\n\nTry to be tidy about things.\n\n\n        fs.unlink settings.socket, (error) ->\n\n\n\n\nIgnore the error if it's just saying the socket didn't exist.\n\n\n          return next error if error.code isnt 'ENOENT' if error?\n\n\n\n\nBind the REPL server socket.\n\n\n          server.listen settings.socket, (error) ->\n            return next error if error?\n            debug \"REPL server listening at #{settings.socket}\"\n            next()\n\n    ]",
            "title": "index.coffee"
        },
        {
            "location": "/source/packages/truss-repl/#repl",
            "text": "Runs a REPL and allows packages to add values to its context.  CoffeeScript = require 'coffee-script'\nfs = require 'fs'\nnet = require 'net'\nreplServer = require 'repl'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\ndebug = require('debug') 'truss:repl'  The socket server.  server = null\n\nexports.pkgmanRegister = (registrar) ->  Implements hook  trussServerPackageConfig    registrar.registerHook 'trussServerPackageConfig', ->  The prompt display for REPL clients.      prompt: 'truss> '  The location of the socket.      socket: \"#{__dirname}/socket\"  Use a CoffeeScript REPL?      useCoffee: true  Implements hook  trussServerProcessExit    registrar.registerHook 'trussServerProcessExit', -> server?.close()  Implements hook  trussServerBootstrapMiddleware    registrar.registerHook 'trussServerBootstrapMiddleware', ->\n\n    label: 'REPL'\n    middleware: [\n\n      (next) ->\n\n        settings = config.get 'packageConfig:truss-repl'\n\n        server = net.createServer (socket) ->  Invoke hook  trussReplServerContext            pkgman.invoke 'trussReplServerContext', context = {}  REPL server options.            opts =\n            prompt: settings.prompt\n            input: socket\n            output: socket\n            ignoreUndefined: true  CoffeeScript?            if settings.useCoffee\n\n            opts.prompt = \"(coffee) #{settings.prompt}\"  Define our own eval function, using CoffeeScript.              opts.eval = (cmd, context, filename, callback) ->  Handle blank lines correctly.                return callback null, undefined if cmd is '(\\n)'  Forward the input to CoffeeScript for evalulation.                try\n\n                callback null, CoffeeScript.eval(\n                  cmd\n                  sandbox: context\n                  filename: filename\n                )\n\n              catch error\n\n                callback error  Spin up the server, inject the values from trussReplServerContext , and prepare for later cleanup.            repl = replServer.start opts\n          repl.context[key] = value for key, value of context\n          repl.on 'exit', -> socket.end()  Try to be tidy about things.          fs.unlink settings.socket, (error) ->  Ignore the error if it's just saying the socket didn't exist.            return next error if error.code isnt 'ENOENT' if error?  Bind the REPL server socket.            server.listen settings.socket, (error) ->\n            return next error if error?\n            debug \"REPL server listening at #{settings.socket}\"\n            next()\n\n    ]",
            "title": "REPL"
        },
        {
            "location": "/source/server/",
            "text": "Native server application entry point.\n\n\n\n\n\nEnsure proper environment exists.\n\n\nrequire(\"#{__dirname}/src/bootstrap\").bootstrap()\n\npath = require 'path'\nfs = require 'fs'\n\nconfig = require 'config'\npkgman = require 'pkgman'\nyaml = require 'js-yaml'\n\n\n\n\nSet up exit hooks.\n\n\nInvoke hook \ntrussServerProcessExit\n\n\nprocess.on 'exit', -> pkgman.invoke 'trussServerProcessExit'\n\nprocess.on 'SIGINT', -> process.exit()\nprocess.on 'SIGTERM', -> process.exit()\nprocess.on 'unhandledException', -> process.exit()\n\n\n\n\nSet environment variables into config.\n\n\nconfig.set 'path', __dirname\nconfig.set k, v for k, v of process.env\n\n\n\n\nRead configuration file.\n\n\nsettingsFilename = config.get 'path'\nsettingsFilename += '/config/settings.yml'\n\nthrow new Error '\n  Settings file not found!\n  You should copy config/default.settings.yml to config/settings.yml\n' unless fs.existsSync settingsFilename\n\nsettings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\nconfig.set k, v for k, v of settings\n\n\n\n\nSpin up the server.\n\n\nrequire('main').start config, (error) ->\n  return unless error?\n\n  console.error require('errors').stack error\n  process.exit 1",
            "title": "server.coffee"
        },
        {
            "location": "/source/server/#native-server-application-entry-point",
            "text": "Ensure proper environment exists.  require(\"#{__dirname}/src/bootstrap\").bootstrap()\n\npath = require 'path'\nfs = require 'fs'\n\nconfig = require 'config'\npkgman = require 'pkgman'\nyaml = require 'js-yaml'  Set up exit hooks.  Invoke hook  trussServerProcessExit  process.on 'exit', -> pkgman.invoke 'trussServerProcessExit'\n\nprocess.on 'SIGINT', -> process.exit()\nprocess.on 'SIGTERM', -> process.exit()\nprocess.on 'unhandledException', -> process.exit()  Set environment variables into config.  config.set 'path', __dirname\nconfig.set k, v for k, v of process.env  Read configuration file.  settingsFilename = config.get 'path'\nsettingsFilename += '/config/settings.yml'\n\nthrow new Error '\n  Settings file not found!\n  You should copy config/default.settings.yml to config/settings.yml\n' unless fs.existsSync settingsFilename\n\nsettings = yaml.safeLoad fs.readFileSync settingsFilename, 'utf8'\nconfig.set k, v for k, v of settings  Spin up the server.  require('main').start config, (error) ->\n  return unless error?\n\n  console.error require('errors').stack error\n  process.exit 1",
            "title": "Native server application entry point."
        },
        {
            "location": "/source/src/bootstrap/",
            "text": "Process bootstrap\n\n\nBootstrap the application and ensure require paths are set\nby default.\n\n\nexports.bootstrap = ->\n\n\n\n\nEnsure we have default require paths.\n\n\n  TRUSS_REQUIRE_PATH = if process.env.TRUSS_REQUIRE_PATH?\n    process.env.TRUSS_REQUIRE_PATH\n  else\n    'custom:packages:src'\n\n\n\n\nIntegrate any NODE_PATH after the Truss require paths.\n\n\n  if process.env.NODE_PATH?\n    TRUSS_REQUIRE_PATH += \":#{process.env.NODE_PATH}\"\n\n\n\n\nHACK ALERT: Use internal node.js structure to modify the require paths\non-the-fly.\n\n\n  module = require 'module'\n  process.env['NODE_PATH'] = TRUSS_REQUIRE_PATH\n  module._initPaths()\n\n  return",
            "title": "bootstrap.coffee"
        },
        {
            "location": "/source/src/bootstrap/#process-bootstrap",
            "text": "Bootstrap the application and ensure require paths are set\nby default.  exports.bootstrap = ->  Ensure we have default require paths.    TRUSS_REQUIRE_PATH = if process.env.TRUSS_REQUIRE_PATH?\n    process.env.TRUSS_REQUIRE_PATH\n  else\n    'custom:packages:src'  Integrate any NODE_PATH after the Truss require paths.    if process.env.NODE_PATH?\n    TRUSS_REQUIRE_PATH += \":#{process.env.NODE_PATH}\"  HACK ALERT: Use internal node.js structure to modify the require paths\non-the-fly.    module = require 'module'\n  process.env['NODE_PATH'] = TRUSS_REQUIRE_PATH\n  module._initPaths()\n\n  return",
            "title": "Process bootstrap"
        },
        {
            "location": "/source/src/config/",
            "text": "Configuration system.\n\n\nHandle getting, setting, and checking configuration state.\n\n\nmodule.exports = new class Config\n\n\n\n\nThis class allows us to wrap and subsequently get, set, and check the\nexistence of values in a configuration tree. The configuration tree may be\ntraversed with colons, e.g. \nparent:child:grandchild\n. Supposing we have a\nconfiguration structure:\n\n\nconfiguration =\n  visible: true\n  child:\n    id: 200\n    tag: null\n\n\n\n\nWe may wrap and interact with it as follows:\n\n\nwrapped = new Config configuration\nwrapped.get 'visible'\n\n\n\n\nReturns: \ntrue\n\n\nwrapped.set 'child:name', 'Billy'\nwrapped.get 'child'\n\n\n\n\nReturns: \n{ id: 200, name: 'Billy' }\n\n\nwrapped.has 'child:id'\n\n\n\n\nReturns: \ntrue\n\n\nwrapped.has 'child:thing'\n\n\n\n\nReturns: \nfalse\n\n\nNOTE:\n \nhas\n works with null values:\n\n\nwrapped.has 'child:tag'\n\n\n\n\nReturns: \ntrue\n\n\nProvide the class externally.\n\n\n  Config: Config\n\n\n\n\nconstructor\n\n\n\n\n(object) \nconfig\n - The configuration tree.\n\n\n\n\nCreate a configuration wrapper.\n\n\n  constructor: (config = {}) -> @from config\n\n\n\n\nConfig#from\n\n\n\n\n(object) \nconfig\n - The configuration object.\n\n\n\n\nSet configuration from an object.\n\n\n  from: (@config) ->\n\n\n\n\nConfig#get\n\n\n\n\n(string) \npath\n - The path to look up, e.g. parent:child:grandchild\n\n\n\n\nGet a value by path.\n\n\n  get: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      current = current?[part]\n    current\n\n\n\n\nConfig#has\n\n\n\n\n(string) \npath\n - The path to look up, e.g. \n'parent:child:grandchild'\n\n\n\n\nCheck whether a path exists.\n\n\n  has: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      return false unless 'object' is typeof current\n      return false unless part of current\n      current = current[part]\n\n    return true\n\n\n\n\nConfig#set\n\n\n\n\n\n\n(string) \npath\n - The path to look up, e.g. parent:child:grandchild\n\n\n\n\n\n\n(any) \nvalue\n - The value to store at the path location.\n\n\n\n\n\n\nSet a value by path.\n\n\n  set: (path, value) ->\n\n    [parts..., last] = path.split ':'\n    current = @config\n    for part in parts\n      current = (current[part] ?= {})\n\n    current[last] = value\n\n\n\n\nConfig#setDefault\n\n\n\n\n\n\n(string) \npath\n - The path to look up, e.g. parent:child:grandchild\n\n\n\n\n\n\n(any) \nvalue\n - The value to store at the path location.\n\n\n\n\n\n\nSet a value by path if one doesn't already exist.\n\n\n  setDefault: (path, value) -> @set path, value unless @has path, value\n\n\n\n\nConfig#setDefaults\n\n\n\n\n(object) \ndefaults\n - A Config object containing default paths/values.\n\n\n\n\nSet values by path if they doesn't already exist.\n\n\n  setDefaults: (defaults) ->\n    self = this\n\n    recur = (object, path) ->\n\n      if self.has pathString = path.join ':'\n        if object? and 'object' is typeof object\n\n          recur object[k], path.concat k for k of object\n\n      else\n\n        self.set pathString, object\n\n    recur defaults[k], [k] for k of defaults\n\n    return\n\n\n\n\nConfig#toJSON\n\n\nReturn config object for serialization.\n\n\n  toJSON: -> @config",
            "title": "config.coffee"
        },
        {
            "location": "/source/src/config/#configuration-system",
            "text": "Handle getting, setting, and checking configuration state.  module.exports = new class Config  This class allows us to wrap and subsequently get, set, and check the\nexistence of values in a configuration tree. The configuration tree may be\ntraversed with colons, e.g.  parent:child:grandchild . Supposing we have a\nconfiguration structure:  configuration =\n  visible: true\n  child:\n    id: 200\n    tag: null  We may wrap and interact with it as follows:  wrapped = new Config configuration\nwrapped.get 'visible'  Returns:  true  wrapped.set 'child:name', 'Billy'\nwrapped.get 'child'  Returns:  { id: 200, name: 'Billy' }  wrapped.has 'child:id'  Returns:  true  wrapped.has 'child:thing'  Returns:  false  NOTE:   has  works with null values:  wrapped.has 'child:tag'  Returns:  true",
            "title": "Configuration system."
        },
        {
            "location": "/source/src/config/#provide-the-class-externally",
            "text": "Config: Config",
            "title": "Provide the class externally."
        },
        {
            "location": "/source/src/config/#constructor",
            "text": "(object)  config  - The configuration tree.   Create a configuration wrapper.    constructor: (config = {}) -> @from config",
            "title": "constructor"
        },
        {
            "location": "/source/src/config/#configfrom",
            "text": "(object)  config  - The configuration object.   Set configuration from an object.    from: (@config) ->",
            "title": "Config#from"
        },
        {
            "location": "/source/src/config/#configget",
            "text": "(string)  path  - The path to look up, e.g. parent:child:grandchild   Get a value by path.    get: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      current = current?[part]\n    current",
            "title": "Config#get"
        },
        {
            "location": "/source/src/config/#confighas",
            "text": "(string)  path  - The path to look up, e.g.  'parent:child:grandchild'   Check whether a path exists.    has: (path) ->\n\n    current = @config\n    for part in path.split ':'\n      return false unless 'object' is typeof current\n      return false unless part of current\n      current = current[part]\n\n    return true",
            "title": "Config#has"
        },
        {
            "location": "/source/src/config/#configset",
            "text": "(string)  path  - The path to look up, e.g. parent:child:grandchild    (any)  value  - The value to store at the path location.    Set a value by path.    set: (path, value) ->\n\n    [parts..., last] = path.split ':'\n    current = @config\n    for part in parts\n      current = (current[part] ?= {})\n\n    current[last] = value",
            "title": "Config#set"
        },
        {
            "location": "/source/src/config/#configsetdefault",
            "text": "(string)  path  - The path to look up, e.g. parent:child:grandchild    (any)  value  - The value to store at the path location.    Set a value by path if one doesn't already exist.    setDefault: (path, value) -> @set path, value unless @has path, value",
            "title": "Config#setDefault"
        },
        {
            "location": "/source/src/config/#configsetdefaults",
            "text": "(object)  defaults  - A Config object containing default paths/values.   Set values by path if they doesn't already exist.    setDefaults: (defaults) ->\n    self = this\n\n    recur = (object, path) ->\n\n      if self.has pathString = path.join ':'\n        if object? and 'object' is typeof object\n\n          recur object[k], path.concat k for k of object\n\n      else\n\n        self.set pathString, object\n\n    recur defaults[k], [k] for k of defaults\n\n    return",
            "title": "Config#setDefaults"
        },
        {
            "location": "/source/src/config/#configtojson",
            "text": "Return config object for serialization.    toJSON: -> @config",
            "title": "Config#toJSON"
        },
        {
            "location": "/source/src/errors/",
            "text": "Error handling\n\n\npkgman = require 'pkgman'\n\n\n\n\nTransmittableError\n\n\nExtend this class if you'd like to implement an error.\n\n\nexports.TransmittableError = class TransmittableError extends Error\n\n\n\n\nTransmittableError#constructor\n\n\nSee:\n\nhttps://github.com/jashkenas/coffee-script/issues/2359\n\n\n  constructor: (@message) ->\n\n\n\n\nTransmittableError#errorType\n\n\nA unique key for this error.\n\n\n  errorType: 'unknown'\n\n\n\n\nTransmittableError#template\n\n\nThe template used to format the error output.\n\n\n  template: 'Unknown error: :message'\n\n\n\n\nTransmittableError#toJSON\n\n\nImplement this if you need to transmit more than just the error type and\nthe message. Truss uses the result from this function to serialize the\nerror over the wire.\n\n\n  toJSON: -> [@errorType, @message]\n\n\n\n\nerrors.instantiate\n\n\n\n\n\n\n(string) \nerrorType\n - The error type.\n\n\n\n\n\n\n(any) \nargs...\n - Additional arguments to pass to the error type's\n\n\n\n\n\n\nconstructor. \nInstantiate an error based on error type, passing along args\nto the error's constructor.\n\n\nexports.instantiate = (errorType, args...) ->\n\n\n\n\nLook up the error type and use it. If it's not registered, fall back to\nthe TransmittableError superclass.\n\n\n  Types = exports.transmittableErrors()\n  Type = if Types[errorType]? then Types[errorType] else TransmittableError\n\n\n\n\nTrickery to be able to essentially call \nnew\n with \nFunction::apply\n.\n\n\n  IType = do (Type) ->\n    F = (args) -> Type.apply this, args\n    F.prototype = Type.prototype\n    (args) -> new F args\n\n  error = IType args\n\n\n\n\nThrow so we have a (possibly) meaningful stack.\n\n\n  try\n    throw new Error()\n  catch stackError\n    stackError.message = exports.message error\n    error.stack = stackError.stack\n\n  error\n\n\n\n\nerrors.message\n\n\n\n\n(Error) \nerror\n - The error object.\n\n\n\n\nExtract an error message from an error.\n\n\nexports.message = (error) ->\n\n\n\n\nOne of us! One of us!\n\n\n  output = if error instanceof TransmittableError\n    error.template\n\n\n\n\nAbstract Error.\n\n\n  else if error instanceof Error\n    TransmittableError::template.replace ':message', error.message\n\n\n\n\nNot an instance of \nError\n. This probably shouldn't happen, but we deal\nwith it anyway.\n\n\n  else\n    TransmittableError::template.replace ':message', error.toString()\n\n\n\n\nReplace placeholders in the template.\n\n\n  output = output.replace \":#{key}\", value for key, value of error\n  output\n\n\n\n\nerrors.serialize\n\n\n\n\n(Error) \nerror\n - The error object.\n\n\n\n\nSerialize an error to send over the wire.\n\n\nexports.serialize = (error) ->\n\n\n\n\nOne of us! One of us!\n\n\n  if error instanceof TransmittableError\n    error.toJSON()\n\n\n\n\nAbstract Error.\n\n\n  else if error instanceof Error\n    [undefined, error.message]\n\n\n\n\nNot an instance of \nError\n. This probably shouldn't happen, but we deal\nwith it anyway.\n\n\n  else\n    [undefined, error]\n\n\n\n\nerrors.stack\n\n\n\n\n(Error) \nerror\n - The error object.\n\n\n\n\nExtract the stack trace from an error.\n\n\nexports.stack = (error) ->\n\n\n\n\nDoes the stack trace exist?\n\n\n  formatStack = if (formatStack = error.stack)?\n\n\n\n\nIf so, shift off the first line (the message).\n\n\n    formatStack = formatStack.split '\\n'\n    formatStack.shift()\n    '\\n' + formatStack.join '\\n'\n\n\n\n\nOtherwise, we don't have much to work with...\n\n\n  else\n    ''\n\n\n\n\nPrepend our pretty formatted message before the stack trace.\n\n\n  \"#{@message error}#{formatStack}\"\n\n\n\n\nerrors.transmittableErrors\n\n\nCollect the error types implemented by packages.\n\n\nexports.transmittableErrors = ->\n\n  _ = require 'lodash'\n\n\n\n\nInvoke hook \ntrussTransmittableErrors\n\n\nAllows packages to specify transmittable errors. Implementations should\nreturn a subclass of \nTransmittableError\n.\n\n\n  Types = {}\n\n  Types[Type::errorType] = Type for Type in [TransmittableError].concat(\n    _.flatten pkgman.invokeFlat 'trussTransmittableErrors'\n  )\n\n  Types\n\n\n\n\nerrors.unserialize\n\n\nUnserialize an error from over the wire.\n\n\nexports.unserialize = (data) -> exports.instantiate.apply null, data",
            "title": "errors.coffee"
        },
        {
            "location": "/source/src/errors/#error-handling",
            "text": "pkgman = require 'pkgman'",
            "title": "Error handling"
        },
        {
            "location": "/source/src/errors/#transmittableerror",
            "text": "Extend this class if you'd like to implement an error.  exports.TransmittableError = class TransmittableError extends Error",
            "title": "TransmittableError"
        },
        {
            "location": "/source/src/errors/#transmittableerrorconstructor",
            "text": "See: https://github.com/jashkenas/coffee-script/issues/2359    constructor: (@message) ->",
            "title": "TransmittableError#constructor"
        },
        {
            "location": "/source/src/errors/#transmittableerrorerrortype",
            "text": "A unique key for this error.    errorType: 'unknown'",
            "title": "TransmittableError#errorType"
        },
        {
            "location": "/source/src/errors/#transmittableerrortemplate",
            "text": "The template used to format the error output.    template: 'Unknown error: :message'",
            "title": "TransmittableError#template"
        },
        {
            "location": "/source/src/errors/#transmittableerrortojson",
            "text": "Implement this if you need to transmit more than just the error type and\nthe message. Truss uses the result from this function to serialize the\nerror over the wire.    toJSON: -> [@errorType, @message]",
            "title": "TransmittableError#toJSON"
        },
        {
            "location": "/source/src/errors/#errorsinstantiate",
            "text": "(string)  errorType  - The error type.    (any)  args...  - Additional arguments to pass to the error type's    constructor.  Instantiate an error based on error type, passing along args\nto the error's constructor.  exports.instantiate = (errorType, args...) ->  Look up the error type and use it. If it's not registered, fall back to\nthe TransmittableError superclass.    Types = exports.transmittableErrors()\n  Type = if Types[errorType]? then Types[errorType] else TransmittableError  Trickery to be able to essentially call  new  with  Function::apply .    IType = do (Type) ->\n    F = (args) -> Type.apply this, args\n    F.prototype = Type.prototype\n    (args) -> new F args\n\n  error = IType args  Throw so we have a (possibly) meaningful stack.    try\n    throw new Error()\n  catch stackError\n    stackError.message = exports.message error\n    error.stack = stackError.stack\n\n  error",
            "title": "errors.instantiate"
        },
        {
            "location": "/source/src/errors/#errorsmessage",
            "text": "(Error)  error  - The error object.   Extract an error message from an error.  exports.message = (error) ->  One of us! One of us!    output = if error instanceof TransmittableError\n    error.template  Abstract Error.    else if error instanceof Error\n    TransmittableError::template.replace ':message', error.message  Not an instance of  Error . This probably shouldn't happen, but we deal\nwith it anyway.    else\n    TransmittableError::template.replace ':message', error.toString()  Replace placeholders in the template.    output = output.replace \":#{key}\", value for key, value of error\n  output",
            "title": "errors.message"
        },
        {
            "location": "/source/src/errors/#errorsserialize",
            "text": "(Error)  error  - The error object.   Serialize an error to send over the wire.  exports.serialize = (error) ->  One of us! One of us!    if error instanceof TransmittableError\n    error.toJSON()  Abstract Error.    else if error instanceof Error\n    [undefined, error.message]  Not an instance of  Error . This probably shouldn't happen, but we deal\nwith it anyway.    else\n    [undefined, error]",
            "title": "errors.serialize"
        },
        {
            "location": "/source/src/errors/#errorsstack",
            "text": "(Error)  error  - The error object.   Extract the stack trace from an error.  exports.stack = (error) ->  Does the stack trace exist?    formatStack = if (formatStack = error.stack)?  If so, shift off the first line (the message).      formatStack = formatStack.split '\\n'\n    formatStack.shift()\n    '\\n' + formatStack.join '\\n'  Otherwise, we don't have much to work with...    else\n    ''  Prepend our pretty formatted message before the stack trace.    \"#{@message error}#{formatStack}\"",
            "title": "errors.stack"
        },
        {
            "location": "/source/src/errors/#errorstransmittableerrors",
            "text": "Collect the error types implemented by packages.  exports.transmittableErrors = ->\n\n  _ = require 'lodash'  Invoke hook  trussTransmittableErrors  Allows packages to specify transmittable errors. Implementations should\nreturn a subclass of  TransmittableError .    Types = {}\n\n  Types[Type::errorType] = Type for Type in [TransmittableError].concat(\n    _.flatten pkgman.invokeFlat 'trussTransmittableErrors'\n  )\n\n  Types",
            "title": "errors.transmittableErrors"
        },
        {
            "location": "/source/src/errors/#errorsunserialize",
            "text": "Unserialize an error from over the wire.  exports.unserialize = (data) -> exports.instantiate.apply null, data",
            "title": "errors.unserialize"
        },
        {
            "location": "/source/src/logging/",
            "text": "Server logging\n\n\nProvide a unified interface for logging messages.\n\n\n_ = require 'lodash'\n\nutil = require 'util'\n\nconfig = require 'config'\nerrors = require 'errors'\n\ndebug = require('debug') 'truss:logger'\n\n\n\n\nlogging.create\n\n\n\n\n(string) \nfilename\n - The filename where the log will be written.\n\n\n\n\nCreate a new logger instance.\n\n\nexports.create = (options) ->\n\n  winston = require 'winston'\n  {Transport} = require 'winston/lib/winston/transports/transport'\n\n  class DebugTransport extends Transport\n\n    log: (level, msg, meta, callback) ->\n\n      output = \"#{level}: \"\n      output += if _.isString msg\n        msg\n      else\n        util.inspect msg\n      output += errors.stack meta if meta instanceof Error\n\n      debug output\n\n      @emit 'logged'\n      callback null, true\n\n  options ?= {}\n  options.transports ?= []\n\n  options.console ?= {}\n  options.console.level ?= if 'production' is config.get 'NODE_ENV'\n    'error'\n  else\n    'silly'\n  options.transports.push new DebugTransport options.console\n\n  options.file ?= {}\n  options.file.level ?= if 'production' is config.get 'NODE_ENV'\n    'error'\n  else\n    'silly'\n  options.file.json ?= false\n  if options.file.filename?\n    options.transports.push new winston.transports.File options.file\n\n  new winston.Logger transports: options.transports\n\n\n\n\nCreate a default logger, for convenience.\n\n\ndefaultLogger = exports.create file: filename: 'logs/truss.log'\nexports.defaultLogger = defaultLogger",
            "title": "logging.coffee"
        },
        {
            "location": "/source/src/logging/#server-logging",
            "text": "Provide a unified interface for logging messages.  _ = require 'lodash'\n\nutil = require 'util'\n\nconfig = require 'config'\nerrors = require 'errors'\n\ndebug = require('debug') 'truss:logger'",
            "title": "Server logging"
        },
        {
            "location": "/source/src/logging/#loggingcreate",
            "text": "(string)  filename  - The filename where the log will be written.   Create a new logger instance.  exports.create = (options) ->\n\n  winston = require 'winston'\n  {Transport} = require 'winston/lib/winston/transports/transport'\n\n  class DebugTransport extends Transport\n\n    log: (level, msg, meta, callback) ->\n\n      output = \"#{level}: \"\n      output += if _.isString msg\n        msg\n      else\n        util.inspect msg\n      output += errors.stack meta if meta instanceof Error\n\n      debug output\n\n      @emit 'logged'\n      callback null, true\n\n  options ?= {}\n  options.transports ?= []\n\n  options.console ?= {}\n  options.console.level ?= if 'production' is config.get 'NODE_ENV'\n    'error'\n  else\n    'silly'\n  options.transports.push new DebugTransport options.console\n\n  options.file ?= {}\n  options.file.level ?= if 'production' is config.get 'NODE_ENV'\n    'error'\n  else\n    'silly'\n  options.file.json ?= false\n  if options.file.filename?\n    options.transports.push new winston.transports.File options.file\n\n  new winston.Logger transports: options.transports  Create a default logger, for convenience.  defaultLogger = exports.create file: filename: 'logs/truss.log'\nexports.defaultLogger = defaultLogger",
            "title": "logging.create"
        },
        {
            "location": "/source/src/main/",
            "text": "Server application entry point\n\n\nLoad the configuration, invoke the bootstrap hooks, and listen for signals\nand process exit.\n The core bootstrap phase injects environment into a\nforked copy of the application including require paths to allow core and\ncustom packages to be included without qualification.\n\n\ndebug = require('debug') 'truss:main'\nmiddleware = require 'middleware'\npkgman = require 'pkgman'\n\nexports.start = (config, fn) ->\n\n\n\n\nRegister the configured packages.\n\n\n  pkgman.registerPackages config.get 'packageList'\n\n\n\n\nLoad the packages' configuration settings and set into the default config.\n\n\nInvoke hook \ntrussServerPackageConfig\n\n\n  packageConfig = new config.Config()\n  for path, value of pkgman.invoke 'trussServerPackageConfig'\n    packageConfig.set path.replace(/\\//g, ':'), value\n  config.setDefaults packageConfig: packageConfig.toJSON()\n\n\n\n\nRun the pre-bootstrap phase.\n\n\nInvoke hook \ntrussServerPreBootstrap\n\n\n  debug 'Pre bootstrap started...'\n  pkgman.invoke 'trussServerPreBootstrap'\n  debug 'Pre bootstrap complete.'\n\n\n\n\nLoad the bootstrap middleware.\n\n\nInvoke hook \ntrussServerBootstrapMiddleware\n\n\n  debug 'Bootstrap started...'\n  bootstrapMiddleware = middleware.fromHook(\n    'trussServerBootstrapMiddleware'\n    config.get 'serverBootstrapMiddleware'\n  )\n\n\n\n\nDispatch the bootstrap middleware and log if everything is okay.\n\n\n  bootstrapMiddleware.dispatch (error) ->\n    debug 'Bootstrap complete.' unless error?\n\n\n\n\nFinish the bootstrap.\n\n\n    fn error",
            "title": "main.coffee"
        },
        {
            "location": "/source/src/main/#server-application-entry-point",
            "text": "Load the configuration, invoke the bootstrap hooks, and listen for signals\nand process exit.  The core bootstrap phase injects environment into a\nforked copy of the application including require paths to allow core and\ncustom packages to be included without qualification.  debug = require('debug') 'truss:main'\nmiddleware = require 'middleware'\npkgman = require 'pkgman'\n\nexports.start = (config, fn) ->  Register the configured packages.    pkgman.registerPackages config.get 'packageList'  Load the packages' configuration settings and set into the default config.  Invoke hook  trussServerPackageConfig    packageConfig = new config.Config()\n  for path, value of pkgman.invoke 'trussServerPackageConfig'\n    packageConfig.set path.replace(/\\//g, ':'), value\n  config.setDefaults packageConfig: packageConfig.toJSON()  Run the pre-bootstrap phase.  Invoke hook  trussServerPreBootstrap    debug 'Pre bootstrap started...'\n  pkgman.invoke 'trussServerPreBootstrap'\n  debug 'Pre bootstrap complete.'  Load the bootstrap middleware.  Invoke hook  trussServerBootstrapMiddleware    debug 'Bootstrap started...'\n  bootstrapMiddleware = middleware.fromHook(\n    'trussServerBootstrapMiddleware'\n    config.get 'serverBootstrapMiddleware'\n  )  Dispatch the bootstrap middleware and log if everything is okay.    bootstrapMiddleware.dispatch (error) ->\n    debug 'Bootstrap complete.' unless error?  Finish the bootstrap.      fn error",
            "title": "Server application entry point"
        },
        {
            "location": "/source/src/middleware/",
            "text": "Abstract middleware stacks\n\n\n{EventEmitter} = require 'events'\n\nconfig = require 'config'\npkgman = require 'pkgman'\n\n\n\n\nImplements a middleware stack. Middleware functions can be added to the\nstack with \nuse\n. Calling \ndispatch\n invokes the middleware functions\nserially.\n\n\nDefining middleware\n\n\nEach middleware accepts an arbitrary parameters and finally a \nnext\n\nfunction. When a middleware finishes, it must call the \nnext\n function.\nIf there was an error, it must be thrown or passed as the first argument to\n\nnext\n. If no error occurred, \nnext\n must be invoked without arguments.\nError-handling middleware can also be defined. These middleware take an\nadditional parameter at the beginning of the function signature: \nerror\n.\nError-handling middleware are only called if a previous middleware threw\nor passed an error. Conversely, non-error-handling middleware are skipped\nif a previous error occurred.\n\n\nexports.Middleware = class Middleware extends EventEmitter\n\n\n\n\nconstructor\n\n\nCreate a middleware stack.\n\n\n  constructor: -> @_middleware = []\n\n\n\n\nMiddlware#use\n\n\n\n\n(function) \nfn\n - A middleware function.\n\n\n\n\nAdd a middleware function to the stack.\n\n\n  use: (fn) -> @_middleware.push fn\n\n\n\n\nMiddleware#dispatch\n\n\n\n\n\n\n(mixed) \n...\n - Zero or more values to pass to the middleware.\n\n\n\n\n\n\n(function) \nfn\n - A function invoked when the middleware stack has\nfinished. If an error occurred, it will be passed as the first argument.\n\n\n\n\n\n\nInvoke the middleware functions serially.\n\n\n  dispatch: (args..., fn) ->\n    self = this\n\n    index = 0\n\n    invoke = (error) ->\n\n      self.emit 'invoked', self._middleware[index - 1] if index > 0\n\n\n\n\nCall \nfn\n with any error if we're done.\n\n\n      if index is self._middleware.length\n\n\n\n\nIgnore any final error, as we don't want it to cascade back up the\nrecursive invocation path.\n\n\n        try\n          return fn error\n        catch error\n          return\n\n      current = self._middleware[index++]\n\n\n\n\nError-handling middleware.\n\n\n      if current.length is args.length + 2\n\n\n\n\nAn error occurred previously.\n\n\n        if error?\n\n\n\n\nTry to invoke the middleware, if it throws, just catch the error\nand pass it along.\n\n\n          try\n            localArgs = args.concat()\n            localArgs.unshift error\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error\n\n\n\n\nNo previous error; skip this middleware.\n\n\n        else\n\n          invoke error\n\n\n\n\nNon-error-handling middleware.\n\n\n      else\n\n\n\n\nAn error occurred previously, skip this middleware.\n\n\n        if error?\n\n          invoke error\n\n\n\n\nNo previous error.\n\n\n        else\n\n\n\n\nTry to invoke the middleware, if it throws, just catch the error\nand pass it along.\n\n\n          try\n            localArgs = args.concat()\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error\n\n\n\n\nKick things off.\n\n\n    invoke()\n\n\n\n\nmiddleware.fromHook\n\n\nCreate a middleware stack from the results of a hook and path\nconfiguration.\n\n\nexports.fromHook = (hook, paths, args...) ->\n\n  debugSilly = require('debug') 'truss-silly:middleware'\n\n  middleware = new Middleware()\n\n\n\n\nInvoke the hook and \nuse\n the middleware in the paths configuration order.\n\n\n  args.unshift hook\n  hookResults = pkgman.invoke args...\n  for path in paths ? []\n    continue unless (spec = hookResults[path])?\n\n    debugSilly \"- - #{spec.label}\"\n\n    middleware.use fn for fn in spec.middleware ? []\n\n  middleware\n\n\n\n\nmiddleware.fromConfig\n\n\nCreate a middleware stack from a configuration path.\n\n\nexports.fromConfig = (path) ->\n\n  exports.fromHook(\n    pkgman.PackageManager.normalizePath path\n    config.get \"packageConfig:#{path}\"\n  )",
            "title": "middleware.coffee"
        },
        {
            "location": "/source/src/middleware/#abstract-middleware-stacks",
            "text": "{EventEmitter} = require 'events'\n\nconfig = require 'config'\npkgman = require 'pkgman'  Implements a middleware stack. Middleware functions can be added to the\nstack with  use . Calling  dispatch  invokes the middleware functions\nserially.",
            "title": "Abstract middleware stacks"
        },
        {
            "location": "/source/src/middleware/#defining-middleware",
            "text": "Each middleware accepts an arbitrary parameters and finally a  next \nfunction. When a middleware finishes, it must call the  next  function.\nIf there was an error, it must be thrown or passed as the first argument to next . If no error occurred,  next  must be invoked without arguments.\nError-handling middleware can also be defined. These middleware take an\nadditional parameter at the beginning of the function signature:  error .\nError-handling middleware are only called if a previous middleware threw\nor passed an error. Conversely, non-error-handling middleware are skipped\nif a previous error occurred.  exports.Middleware = class Middleware extends EventEmitter",
            "title": "Defining middleware"
        },
        {
            "location": "/source/src/middleware/#constructor",
            "text": "Create a middleware stack.    constructor: -> @_middleware = []",
            "title": "constructor"
        },
        {
            "location": "/source/src/middleware/#middlwareuse",
            "text": "(function)  fn  - A middleware function.   Add a middleware function to the stack.    use: (fn) -> @_middleware.push fn",
            "title": "Middlware#use"
        },
        {
            "location": "/source/src/middleware/#middlewaredispatch",
            "text": "(mixed)  ...  - Zero or more values to pass to the middleware.    (function)  fn  - A function invoked when the middleware stack has\nfinished. If an error occurred, it will be passed as the first argument.    Invoke the middleware functions serially.    dispatch: (args..., fn) ->\n    self = this\n\n    index = 0\n\n    invoke = (error) ->\n\n      self.emit 'invoked', self._middleware[index - 1] if index > 0  Call  fn  with any error if we're done.        if index is self._middleware.length  Ignore any final error, as we don't want it to cascade back up the\nrecursive invocation path.          try\n          return fn error\n        catch error\n          return\n\n      current = self._middleware[index++]  Error-handling middleware.        if current.length is args.length + 2  An error occurred previously.          if error?  Try to invoke the middleware, if it throws, just catch the error\nand pass it along.            try\n            localArgs = args.concat()\n            localArgs.unshift error\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error  No previous error; skip this middleware.          else\n\n          invoke error  Non-error-handling middleware.        else  An error occurred previously, skip this middleware.          if error?\n\n          invoke error  No previous error.          else  Try to invoke the middleware, if it throws, just catch the error\nand pass it along.            try\n            localArgs = args.concat()\n            localArgs.push invoke\n            self.emit 'invoking', current\n            current localArgs...\n          catch error\n            invoke error  Kick things off.      invoke()",
            "title": "Middleware#dispatch"
        },
        {
            "location": "/source/src/middleware/#middlewarefromhook",
            "text": "Create a middleware stack from the results of a hook and path\nconfiguration.  exports.fromHook = (hook, paths, args...) ->\n\n  debugSilly = require('debug') 'truss-silly:middleware'\n\n  middleware = new Middleware()  Invoke the hook and  use  the middleware in the paths configuration order.    args.unshift hook\n  hookResults = pkgman.invoke args...\n  for path in paths ? []\n    continue unless (spec = hookResults[path])?\n\n    debugSilly \"- - #{spec.label}\"\n\n    middleware.use fn for fn in spec.middleware ? []\n\n  middleware",
            "title": "middleware.fromHook"
        },
        {
            "location": "/source/src/middleware/#middlewarefromconfig",
            "text": "Create a middleware stack from a configuration path.  exports.fromConfig = (path) ->\n\n  exports.fromHook(\n    pkgman.PackageManager.normalizePath path\n    config.get \"packageConfig:#{path}\"\n  )",
            "title": "middleware.fromConfig"
        },
        {
            "location": "/source/src/pkgman/",
            "text": "path = require 'path'\n\nconfig = require 'config'\n\nclass PackageManager\n\n  @normalizePath: (path, capitalize = false) ->\n\n    i8n = require 'inflection'\n\n    parts = for part, i in path.split '/'\n      i8n.camelize i8n.underscore(\n        part.replace /[^\\w]/g, '_'\n        0 is i\n      )\n\n    i8n.camelize (i8n.underscore parts.join ''), not capitalize\n\n\n\n\nPackageManager#constructor\n\n\n  constructor: ->\n\n    @_hookIndex = {}\n    @_pkgIndex = {}\n\n    @_packageList = []\n\n\n\n\nPackageManager#invoke\n\n\n\n\n\n\n(String) \nhook\n - The hook to invoke.\n\n\n\n\n\n\n(Array) \nargs\n - The arguments passed to the hook implementations.\n\n\n\n\n\n\nInvoke a hook, heying the results by package implementations.\n\n\n  invoke: (hook, args...) ->\n    results = {}\n    for pkg in @packagesImplementing hook\n      results[pkg] = @invokePackage pkg, hook, args...\n    return results\n\n\n\n\nPackageManager#invokeFlat\n\n\n\n\n\n\n(String) \nhook\n - The hook to invoke.\n\n\n\n\n\n\n(Array) \nargs\n - The arguments passed to the hook implementations.\n\n\n\n\n\n\nInvoke a hook, returning the results as a flattened array.\n\n\n  invokeFlat: (hook, args...) ->\n    for pkg in @packagesImplementing hook\n      @invokePackage pkg, hook, args...\n\n\n\n\nPackageManager#invokePackage\n\n\n\n\n\n\n(String) \npkg\n - The package.\n\n\n\n\n\n\n(String) \nhook\n - The hook to invoke.\n\n\n\n\n\n\n(Array) \nargs\n - The arguments passed to the hook implementation.\n\n\n\n\n\n\nInvoke a hook, returning the result.\n\n\n  invokePackage: (pkg, hook, args...) -> @_pkgIndex?[pkg]?[hook]? args...\n\n\n\n\nPackageManager#isPackageRegistered\n\n\n\n\n(String) \npkg\n - The package.\n\n\n\n\nCheck whether a package is registered.\n\n\n  isPackageRegistered: (pkg) -> -1 isnt @_packageList.indexOf pkg\n\n\n\n\nPackageManager#packageImplements\n\n\n\n\n\n\n(String) \npkg\n - The package.\n\n\n\n\n\n\n(String) \nhook\n - The hook to check.\n\n\n\n\n\n\nCheck whether a package implements a hook.\n\n\n  packageImplements: (pkg, hook) -> @_pkgIndex?[pkg]?[hook]?\n\n\n\n\nPackageManager#packageList\n\n\nGet the list of registered packages.\n\n\n  packageList: -> @_packageList\n\n\n\n\nPackageManager#packagePath\n\n\n\n\n(String) \npkg\n - The package.\n\n\n\n\nGet the filepath of a package.\n\n\n  packagePath: (pkg) ->\n\n    path_ = config.get 'path'\n    path.relative path_, path.dirname require.resolve pkg\n\n\n\n\nPackageManager#packagesImplementing\n\n\n\n\n(String) \nhook\n - The hook to check.\n\n\n\n\nGet the list of registered packages implementing a hook.\n\n\n  packagesImplementing: (hook) -> @_hookIndex?[hook] ? []\n\n\n\n\nPackageManager#registerPackage\n\n\n\n\n(String) \npkg\n - The package.\n\n\n\n\nRegister a package.\n\n\n  registerPackage: (pkg) ->\n    return if @isPackageRegistered pkg\n\n    try\n      module_ = require pkg\n\n\n\n\nSuppress missing package errors.\n\n\n    catch error\n      if error.toString() is \"Error: Cannot find module '#{pkg}'\"\n        return\n\n      throw error\n\n    @_packageList.push pkg\n\n    module_.pkgmanRegister? new PackageManager.Registrar(\n      @_hookIndex, @_pkgIndex, pkg\n    )\n\n\n\n\nPackageManager#registerPackages\n\n\n\n\n(Array of String) \npkgs\n - The packages.\n\n\n\n\nRegister packages.\n\n\n  registerPackages: (pkgs) -> @registerPackage pkg for pkg in pkgs\n\n\n\n\nPackageManager#unregisterPackage\n\n\n\n\n(String) \npkg\n - The package.\n\n\n\n\nUnregister a package.\n\n\n  unregisterPackage: (pkg) ->\n    return unless @isPackageRegistered pkg\n\n    for hook of @_pkgIndex[pkg]\n\n      if -1 isnt index = @_hookIndex[hook].indexOf pkg\n        @_hookIndex[hook].splice index, 1\n        delete @_hookIndex[hook] if @_hookIndex[hook].length is 0\n\n    delete @_pkgIndex[pkg]\n\n    index = @_packageList.indexOf pkg\n    @_packageList.splice index, 1\n\n    return\n\n\n\n\nPackageManager#unregisterPackages\n\n\n\n\n(Array of String) \npkgs\n - The packages.\n\n\n\n\nUnregister a list of packages.\n\n\n  unregisterPackages: (pkgs) -> @unregisterPackage pkg for pkg in pkgs\n\nclass PackageManager.Registrar\n\n  constructor: (@_hookIndex, @_pkgIndex, @_path) ->\n\n  path: -> @_path\n\n  recur: (paths) ->\n    for path_ in paths\n      subpath = \"#{@_path}/#{path_}\"\n      submodule = require subpath\n      submodule.pkgmanRegister? new PackageManager.Registrar(\n        @_hookIndex, @_pkgIndex, subpath\n      )\n\n  registerHook: (submodule, hook, impl) ->\n\n\n\n\nIf \nsubmodule\n was passed in, modify the path this hook is registered\nagainst.\n\n\n    if impl?\n\n      path_ = \"#{@_path}/#{submodule}\"\n\n\n\n\nOtherwise, fix up the args.\n\n\n    else\n\n      path_ = @_path\n      impl = hook\n      hook = submodule\n\n    (@_hookIndex[hook] ?= []).push path_\n    (@_pkgIndex[path_] ?= {})[hook] = impl\n\nmodule.exports = new PackageManager()\nmodule.exports.PackageManager = PackageManager",
            "title": "pkgman.coffee"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerconstructor",
            "text": "constructor: ->\n\n    @_hookIndex = {}\n    @_pkgIndex = {}\n\n    @_packageList = []",
            "title": "PackageManager#constructor"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerinvoke",
            "text": "(String)  hook  - The hook to invoke.    (Array)  args  - The arguments passed to the hook implementations.    Invoke a hook, heying the results by package implementations.    invoke: (hook, args...) ->\n    results = {}\n    for pkg in @packagesImplementing hook\n      results[pkg] = @invokePackage pkg, hook, args...\n    return results",
            "title": "PackageManager#invoke"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerinvokeflat",
            "text": "(String)  hook  - The hook to invoke.    (Array)  args  - The arguments passed to the hook implementations.    Invoke a hook, returning the results as a flattened array.    invokeFlat: (hook, args...) ->\n    for pkg in @packagesImplementing hook\n      @invokePackage pkg, hook, args...",
            "title": "PackageManager#invokeFlat"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerinvokepackage",
            "text": "(String)  pkg  - The package.    (String)  hook  - The hook to invoke.    (Array)  args  - The arguments passed to the hook implementation.    Invoke a hook, returning the result.    invokePackage: (pkg, hook, args...) -> @_pkgIndex?[pkg]?[hook]? args...",
            "title": "PackageManager#invokePackage"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerispackageregistered",
            "text": "(String)  pkg  - The package.   Check whether a package is registered.    isPackageRegistered: (pkg) -> -1 isnt @_packageList.indexOf pkg",
            "title": "PackageManager#isPackageRegistered"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerpackageimplements",
            "text": "(String)  pkg  - The package.    (String)  hook  - The hook to check.    Check whether a package implements a hook.    packageImplements: (pkg, hook) -> @_pkgIndex?[pkg]?[hook]?",
            "title": "PackageManager#packageImplements"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerpackagelist",
            "text": "Get the list of registered packages.    packageList: -> @_packageList",
            "title": "PackageManager#packageList"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerpackagepath",
            "text": "(String)  pkg  - The package.   Get the filepath of a package.    packagePath: (pkg) ->\n\n    path_ = config.get 'path'\n    path.relative path_, path.dirname require.resolve pkg",
            "title": "PackageManager#packagePath"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerpackagesimplementing",
            "text": "(String)  hook  - The hook to check.   Get the list of registered packages implementing a hook.    packagesImplementing: (hook) -> @_hookIndex?[hook] ? []",
            "title": "PackageManager#packagesImplementing"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerregisterpackage",
            "text": "(String)  pkg  - The package.   Register a package.    registerPackage: (pkg) ->\n    return if @isPackageRegistered pkg\n\n    try\n      module_ = require pkg  Suppress missing package errors.      catch error\n      if error.toString() is \"Error: Cannot find module '#{pkg}'\"\n        return\n\n      throw error\n\n    @_packageList.push pkg\n\n    module_.pkgmanRegister? new PackageManager.Registrar(\n      @_hookIndex, @_pkgIndex, pkg\n    )",
            "title": "PackageManager#registerPackage"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerregisterpackages",
            "text": "(Array of String)  pkgs  - The packages.   Register packages.    registerPackages: (pkgs) -> @registerPackage pkg for pkg in pkgs",
            "title": "PackageManager#registerPackages"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerunregisterpackage",
            "text": "(String)  pkg  - The package.   Unregister a package.    unregisterPackage: (pkg) ->\n    return unless @isPackageRegistered pkg\n\n    for hook of @_pkgIndex[pkg]\n\n      if -1 isnt index = @_hookIndex[hook].indexOf pkg\n        @_hookIndex[hook].splice index, 1\n        delete @_hookIndex[hook] if @_hookIndex[hook].length is 0\n\n    delete @_pkgIndex[pkg]\n\n    index = @_packageList.indexOf pkg\n    @_packageList.splice index, 1\n\n    return",
            "title": "PackageManager#unregisterPackage"
        },
        {
            "location": "/source/src/pkgman/#packagemanagerunregisterpackages",
            "text": "(Array of String)  pkgs  - The packages.   Unregister a list of packages.    unregisterPackages: (pkgs) -> @unregisterPackage pkg for pkg in pkgs\n\nclass PackageManager.Registrar\n\n  constructor: (@_hookIndex, @_pkgIndex, @_path) ->\n\n  path: -> @_path\n\n  recur: (paths) ->\n    for path_ in paths\n      subpath = \"#{@_path}/#{path_}\"\n      submodule = require subpath\n      submodule.pkgmanRegister? new PackageManager.Registrar(\n        @_hookIndex, @_pkgIndex, subpath\n      )\n\n  registerHook: (submodule, hook, impl) ->  If  submodule  was passed in, modify the path this hook is registered\nagainst.      if impl?\n\n      path_ = \"#{@_path}/#{submodule}\"  Otherwise, fix up the args.      else\n\n      path_ = @_path\n      impl = hook\n      hook = submodule\n\n    (@_hookIndex[hook] ?= []).push path_\n    (@_pkgIndex[path_] ?= {})[hook] = impl\n\nmodule.exports = new PackageManager()\nmodule.exports.PackageManager = PackageManager",
            "title": "PackageManager#unregisterPackages"
        }
    ]
}